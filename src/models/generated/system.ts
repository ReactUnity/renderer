//
// Types in assemblies: mscorlib, System.Core, System
// Generated 18/02/2023 03:04:19
//
/* eslint-disable */

interface Pointer<T> {
  type?: T;
  __pointer: true;
}

interface Ref<T> {
  type?: T;
  __ref: true;
}

type Byte = number;

export declare namespace System {
  export class String {
    constructor(value: System.Char[]);
    constructor(value: System.Char[], startIndex: number, length: number);
    constructor(c: System.Char, count: number);
    constructor(value: System.ReadOnlySpan<System.Char>);
    Length: number;
    static Empty: string;
    static Compare(strA: string, strB: string): number;
    static Compare(strA: string, strB: string, ignoreCase: boolean): number;
    static Compare(strA: string, strB: string, comparisonType: System.StringComparison): number;
    static Compare(strA: string, strB: string, culture: System.Globalization.CultureInfo, options: System.Globalization.CompareOptions): number;
    static Compare(strA: string, strB: string, ignoreCase: boolean, culture: System.Globalization.CultureInfo): number;
    static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number): number;
    static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, ignoreCase: boolean): number;
    static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, ignoreCase: boolean, culture: System.Globalization.CultureInfo): number;
    static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, culture: System.Globalization.CultureInfo, options: System.Globalization.CompareOptions): number;
    static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, comparisonType: System.StringComparison): number;
    static CompareOrdinal(strA: string, strB: string): number;
    static CompareOrdinal(strA: string, indexA: number, strB: string, indexB: number, length: number): number;
    CompareTo(value: any): number;
    CompareTo(strB: string): number;
    EndsWith(value: string): boolean;
    EndsWith(value: string, comparisonType: System.StringComparison): boolean;
    EndsWith(value: string, ignoreCase: boolean, culture: System.Globalization.CultureInfo): boolean;
    EndsWith(value: System.Char): boolean;
    Equals(obj: any): boolean;
    Equals(value: string): boolean;
    Equals(value: string, comparisonType: System.StringComparison): boolean;
    static Equals(a: string, b: string): boolean;
    static Equals(a: string, b: string, comparisonType: System.StringComparison): boolean;
    GetHashCode(): number;
    GetHashCode(comparisonType: System.StringComparison): number;
    StartsWith(value: string): boolean;
    StartsWith(value: string, comparisonType: System.StringComparison): boolean;
    StartsWith(value: string, ignoreCase: boolean, culture: System.Globalization.CultureInfo): boolean;
    StartsWith(value: System.Char): boolean;
    static Concat(arg0: any): string;
    static Concat(arg0: any, arg1: any): string;
    static Concat(arg0: any, arg1: any, arg2: any): string;
    static Concat(...args: any[]): string;
    static Concat(values: any): string;
    static Concat(str0: string, str1: string): string;
    static Concat(str0: string, str1: string, str2: string): string;
    static Concat(str0: string, str1: string, str2: string, str3: string): string;
    static Concat(...values: string[]): string;
    static Format(format: string, arg0: any): string;
    static Format(format: string, arg0: any, arg1: any): string;
    static Format(format: string, arg0: any, arg1: any, arg2: any): string;
    static Format(format: string, ...args: any[]): string;
    static Format(provider: System.IFormatProvider, format: string, arg0: any): string;
    static Format(provider: System.IFormatProvider, format: string, arg0: any, arg1: any): string;
    static Format(provider: System.IFormatProvider, format: string, arg0: any, arg1: any, arg2: any): string;
    static Format(provider: System.IFormatProvider, format: string, ...args: any[]): string;
    Insert(startIndex: number, value: string): string;
    static Join(separator: System.Char, ...value: string[]): string;
    static Join(separator: System.Char, ...values: any[]): string;
    static Join(separator: System.Char, value: string[], startIndex: number, count: number): string;
    static Join(separator: string, ...value: string[]): string;
    static Join(separator: string, ...values: any[]): string;
    static Join(separator: string, values: any): string;
    static Join(separator: string, value: string[], startIndex: number, count: number): string;
    PadLeft(totalWidth: number): string;
    PadLeft(totalWidth: number, paddingChar: System.Char): string;
    PadRight(totalWidth: number): string;
    PadRight(totalWidth: number, paddingChar: System.Char): string;
    Remove(startIndex: number, count: number): string;
    Remove(startIndex: number): string;
    Replace(oldValue: string, newValue: string, ignoreCase: boolean, culture: System.Globalization.CultureInfo): string;
    Replace(oldValue: string, newValue: string, comparisonType: System.StringComparison): string;
    Replace(oldChar: System.Char, newChar: System.Char): string;
    Replace(oldValue: string, newValue: string): string;
    Split(separator: System.Char, options?: System.StringSplitOptions): string[];
    Split(separator: System.Char, count: number, options?: System.StringSplitOptions): string[];
    Split(...separator: System.Char[]): string[];
    Split(separator: System.Char[], count: number): string[];
    Split(separator: System.Char[], options: System.StringSplitOptions): string[];
    Split(separator: System.Char[], count: number, options: System.StringSplitOptions): string[];
    Split(separator: string, options?: System.StringSplitOptions): string[];
    Split(separator: string, count: number, options?: System.StringSplitOptions): string[];
    Split(separator: string[], options: System.StringSplitOptions): string[];
    Split(separator: string[], count: number, options: System.StringSplitOptions): string[];
    Substring(startIndex: number): string;
    Substring(startIndex: number, length: number): string;
    ToLower(): string;
    ToLower(culture: System.Globalization.CultureInfo): string;
    ToLowerInvariant(): string;
    ToUpper(): string;
    ToUpper(culture: System.Globalization.CultureInfo): string;
    ToUpperInvariant(): string;
    Trim(): string;
    Trim(trimChar: System.Char): string;
    Trim(...trimChars: System.Char[]): string;
    TrimStart(): string;
    TrimStart(trimChar: System.Char): string;
    TrimStart(...trimChars: System.Char[]): string;
    TrimEnd(): string;
    TrimEnd(trimChar: System.Char): string;
    TrimEnd(...trimChars: System.Char[]): string;
    Contains(value: string): boolean;
    Contains(value: string, comparisonType: System.StringComparison): boolean;
    Contains(value: System.Char): boolean;
    Contains(value: System.Char, comparisonType: System.StringComparison): boolean;
    IndexOf(value: System.Char): number;
    IndexOf(value: System.Char, startIndex: number): number;
    IndexOf(value: System.Char, comparisonType: System.StringComparison): number;
    IndexOf(value: System.Char, startIndex: number, count: number): number;
    IndexOfAny(anyOf: System.Char[]): number;
    IndexOfAny(anyOf: System.Char[], startIndex: number): number;
    IndexOfAny(anyOf: System.Char[], startIndex: number, count: number): number;
    IndexOf(value: string): number;
    IndexOf(value: string, startIndex: number): number;
    IndexOf(value: string, startIndex: number, count: number): number;
    IndexOf(value: string, comparisonType: System.StringComparison): number;
    IndexOf(value: string, startIndex: number, comparisonType: System.StringComparison): number;
    IndexOf(value: string, startIndex: number, count: number, comparisonType: System.StringComparison): number;
    LastIndexOf(value: System.Char): number;
    LastIndexOf(value: System.Char, startIndex: number): number;
    LastIndexOf(value: System.Char, startIndex: number, count: number): number;
    LastIndexOfAny(anyOf: System.Char[]): number;
    LastIndexOfAny(anyOf: System.Char[], startIndex: number): number;
    LastIndexOfAny(anyOf: System.Char[], startIndex: number, count: number): number;
    LastIndexOf(value: string): number;
    LastIndexOf(value: string, startIndex: number): number;
    LastIndexOf(value: string, startIndex: number, count: number): number;
    LastIndexOf(value: string, comparisonType: System.StringComparison): number;
    LastIndexOf(value: string, startIndex: number, comparisonType: System.StringComparison): number;
    LastIndexOf(value: string, startIndex: number, count: number, comparisonType: System.StringComparison): number;
    Clone(): any;
    static Copy(str: string): string;
    CopyTo(sourceIndex: number, destination: System.Char[], destinationIndex: number, count: number): void;
    ToCharArray(): System.Char[];
    ToCharArray(startIndex: number, length: number): System.Char[];
    static IsNullOrEmpty(value: string): boolean;
    static IsNullOrWhiteSpace(value: string): boolean;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    GetEnumerator(): System.CharEnumerator;
    GetTypeCode(): System.TypeCode;
    IsNormalized(): boolean;
    IsNormalized(normalizationForm: System.Text.NormalizationForm): boolean;
    Normalize(): string;
    Normalize(normalizationForm: System.Text.NormalizationForm): string;
    static Concat(arg0: any, arg1: any, arg2: any, arg3: any): string;
    static Intern(str: string): string;
    static IsInterned(str: string): string;
    GetType(): System.Type;
  }
  export class TimeZoneInfo {
    Id: string;
    DisplayName: string;
    StandardName: string;
    DaylightName: string;
    BaseUtcOffset: System.TimeSpan;
    SupportsDaylightSavingTime: boolean;
    static Local: System.TimeZoneInfo;
    static Utc: System.TimeZoneInfo;
    GetAdjustmentRules(): System.TimeZoneInfo_AdjustmentRule[];
    static FindSystemTimeZoneById(id: string): System.TimeZoneInfo;
    GetAmbiguousTimeOffsets(dateTimeOffset: System.DateTimeOffset): System.TimeSpan[];
    GetAmbiguousTimeOffsets(dateTime: System.DateTime): System.TimeSpan[];
    GetUtcOffset(dateTimeOffset: System.DateTimeOffset): System.TimeSpan;
    GetUtcOffset(dateTime: System.DateTime): System.TimeSpan;
    IsAmbiguousTime(dateTimeOffset: System.DateTimeOffset): boolean;
    IsAmbiguousTime(dateTime: System.DateTime): boolean;
    IsDaylightSavingTime(dateTimeOffset: System.DateTimeOffset): boolean;
    IsDaylightSavingTime(dateTime: System.DateTime): boolean;
    IsInvalidTime(dateTime: System.DateTime): boolean;
    static ClearCachedData(): void;
    static ConvertTimeBySystemTimeZoneId(dateTimeOffset: System.DateTimeOffset, destinationTimeZoneId: string): System.DateTimeOffset;
    static ConvertTimeBySystemTimeZoneId(dateTime: System.DateTime, destinationTimeZoneId: string): System.DateTime;
    static ConvertTimeBySystemTimeZoneId(dateTime: System.DateTime, sourceTimeZoneId: string, destinationTimeZoneId: string): System.DateTime;
    static ConvertTime(dateTimeOffset: System.DateTimeOffset, destinationTimeZone: System.TimeZoneInfo): System.DateTimeOffset;
    static ConvertTime(dateTime: System.DateTime, destinationTimeZone: System.TimeZoneInfo): System.DateTime;
    static ConvertTime(dateTime: System.DateTime, sourceTimeZone: System.TimeZoneInfo, destinationTimeZone: System.TimeZoneInfo): System.DateTime;
    static ConvertTimeFromUtc(dateTime: System.DateTime, destinationTimeZone: System.TimeZoneInfo): System.DateTime;
    static ConvertTimeToUtc(dateTime: System.DateTime): System.DateTime;
    static ConvertTimeToUtc(dateTime: System.DateTime, sourceTimeZone: System.TimeZoneInfo): System.DateTime;
    Equals(other: System.TimeZoneInfo): boolean;
    Equals(obj: any): boolean;
    static FromSerializedString(source: string): System.TimeZoneInfo;
    GetHashCode(): number;
    static GetSystemTimeZones(): System.TimeZoneInfo[];
    HasSameRules(other: System.TimeZoneInfo): boolean;
    ToSerializedString(): string;
    ToString(): string;
    static CreateCustomTimeZone(id: string, baseUtcOffset: System.TimeSpan, displayName: string, standardDisplayName: string): System.TimeZoneInfo;
    static CreateCustomTimeZone(id: string, baseUtcOffset: System.TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: System.TimeZoneInfo_AdjustmentRule[]): System.TimeZoneInfo;
    static CreateCustomTimeZone(id: string, baseUtcOffset: System.TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: System.TimeZoneInfo_AdjustmentRule[], disableDaylightSavingTime: boolean): System.TimeZoneInfo;
    GetType(): System.Type;
  }
  export class TimeZoneInfo_AdjustmentRule {
    DateStart: System.DateTime;
    DateEnd: System.DateTime;
    DaylightDelta: System.TimeSpan;
    DaylightTransitionStart: System.TimeZoneInfo_TransitionTime;
    DaylightTransitionEnd: System.TimeZoneInfo_TransitionTime;
    Equals(other: System.TimeZoneInfo_AdjustmentRule): boolean;
    GetHashCode(): number;
    static CreateAdjustmentRule(dateStart: System.DateTime, dateEnd: System.DateTime, daylightDelta: System.TimeSpan, daylightTransitionStart: System.TimeZoneInfo_TransitionTime, daylightTransitionEnd: System.TimeZoneInfo_TransitionTime): System.TimeZoneInfo_AdjustmentRule;
    Equals(obj: any): boolean;
    GetType(): System.Type;
    ToString(): string;
  }
  export class TimeZoneInfo_TransitionTime {
    TimeOfDay: System.DateTime;
    Month: number;
    Week: number;
    Day: number;
    DayOfWeek: System.DayOfWeek;
    IsFixedDateRule: boolean;
    Equals(obj: any): boolean;
    Equals(other: System.TimeZoneInfo_TransitionTime): boolean;
    GetHashCode(): number;
    static CreateFixedDateRule(timeOfDay: System.DateTime, month: number, day: number): System.TimeZoneInfo_TransitionTime;
    static CreateFloatingDateRule(timeOfDay: System.DateTime, month: number, week: number, dayOfWeek: System.DayOfWeek): System.TimeZoneInfo_TransitionTime;
    ToString(): string;
    GetType(): System.Type;
  }
  export class AccessViolationException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Action<T1 = any, T2 = any, T3 = any, T4 = any, T5 = any, T6 = any, T7 = any, T8 = any, T9 = any, T10 = any, T11 = any, T12 = any, T13 = any, T14 = any, T15 = any, T16 = any> {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16): void;
    BeginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): void;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Func<T1 = any, T2 = any, T3 = any, T4 = any, T5 = any, T6 = any, T7 = any, T8 = any, T9 = any, T10 = any, T11 = any, T12 = any, T13 = any, T14 = any, T15 = any, T16 = any, TResult = any> {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16): TResult;
    BeginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): TResult;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Comparison<T = any> {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(x: T, y: T): number;
    BeginInvoke(x: T, y: T, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Converter<TInput = any, TOutput = any> {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(input: TInput): TOutput;
    BeginInvoke(input: TInput, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): TOutput;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Predicate<T = any> {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(obj: T): boolean;
    BeginInvoke(obj: T, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): boolean;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class AggregateException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    constructor(innerExceptions: System.Collections.Generic.IEnumerable<System.Exception>);
    constructor(...innerExceptions: System.Exception[]);
    constructor(message: string, innerExceptions: System.Collections.Generic.IEnumerable<System.Exception>);
    constructor(message: string, ...innerExceptions: System.Exception[]);
    InnerExceptions: System.Exception[];
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    Handle(predicate: ((arg: System.Exception) => boolean)): void;
    Flatten(): System.AggregateException;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ApplicationException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ArgumentException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    constructor(message: string, paramName: string, innerException: System.Exception);
    constructor(message: string, paramName: string);
    Message: string;
    ParamName: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ArgumentNullException {
    constructor();
    constructor(paramName: string);
    constructor(message: string, innerException: System.Exception);
    constructor(paramName: string, message: string);
    Message: string;
    ParamName: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ArgumentOutOfRangeException {
    constructor();
    constructor(paramName: string);
    constructor(paramName: string, message: string);
    constructor(message: string, innerException: System.Exception);
    constructor(paramName: string, actualValue: any, message: string);
    Message: string;
    ActualValue: any; // System.Object
    ParamName: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ArithmeticException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ArraySegment<T = any> {
    constructor(array: T[]);
    constructor(array: T[], offset: number, count: number);
    static Empty: any[];
    Array: T[];
    Offset: number;
    Count: number;
    GetEnumerator(): System.ArraySegment<T>;
    GetHashCode(): number;
    CopyTo(destination: T[]): void;
    CopyTo(destination: T[], destinationIndex: number): void;
    CopyTo(destination: T[]): void;
    Equals(obj: any): boolean;
    Equals(obj: T[]): boolean;
    Slice(index: number): T[];
    Slice(index: number, count: number): T[];
    ToArray(): T[];
    ToString(): string;
    GetType(): System.Type;
  }
  export class ArrayTypeMismatchException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class AssemblyLoadEventArgs {
    constructor(loadedAssembly: System.Reflection.Assembly);
    LoadedAssembly: System.Reflection.Assembly;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class AssemblyLoadEventHandler {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(sender: any, args: System.AssemblyLoadEventArgs): void;
    BeginInvoke(sender: any, args: System.AssemblyLoadEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): void;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class AsyncCallback {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(ar: System.IAsyncResult): void;
    BeginInvoke(ar: System.IAsyncResult, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): void;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export enum AttributeTargets {
    Assembly = 1,
    Module = 2,
    Class = 4,
    Struct = 8,
    Enum = 16,
    Constructor = 32,
    Method = 64,
    Property = 128,
    Field = 256,
    Event = 512,
    Interface = 1024,
    Parameter = 2048,
    Delegate = 4096,
    ReturnValue = 8192,
    GenericParameter = 16384,
    All = 32767,
  }
  export class BadImageFormatException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    constructor(message: string, fileName: string);
    constructor(message: string, fileName: string, inner: System.Exception);
    Message: string;
    FileName: string;
    FusionLog: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    ToString(): string;
    GetBaseException(): System.Exception;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class BitConverter {
    static IsLittleEndian: boolean;
    static GetBytes(value: boolean): Byte[];
    static TryWriteBytes(destination: any, value: boolean): boolean;
    static GetBytes(value: System.Char): Byte[];
    static TryWriteBytes(destination: any, value: System.Char): boolean;
    static GetBytes(value: number): Byte[];
    static TryWriteBytes(destination: any, value: number): boolean;
    static GetBytes(value: number): Byte[];
    static TryWriteBytes(destination: any, value: number): boolean;
    static GetBytes(value: number): Byte[];
    static TryWriteBytes(destination: any, value: number): boolean;
    static GetBytes(value: number): Byte[];
    static TryWriteBytes(destination: any, value: number): boolean;
    static GetBytes(value: number): Byte[];
    static TryWriteBytes(destination: any, value: number): boolean;
    static GetBytes(value: number): Byte[];
    static TryWriteBytes(destination: any, value: number): boolean;
    static GetBytes(value: number): Byte[];
    static TryWriteBytes(destination: any, value: number): boolean;
    static GetBytes(value: number): Byte[];
    static TryWriteBytes(destination: any, value: number): boolean;
    static ToChar(value: Byte[], startIndex: number): System.Char;
    static ToChar(value: any): System.Char;
    static ToInt16(value: Byte[], startIndex: number): number;
    static ToInt16(value: any): number;
    static ToInt32(value: Byte[], startIndex: number): number;
    static ToInt32(value: any): number;
    static ToInt64(value: Byte[], startIndex: number): number;
    static ToInt64(value: any): number;
    static ToUInt16(value: Byte[], startIndex: number): number;
    static ToUInt16(value: any): number;
    static ToUInt32(value: Byte[], startIndex: number): number;
    static ToUInt32(value: any): number;
    static ToUInt64(value: Byte[], startIndex: number): number;
    static ToUInt64(value: any): number;
    static ToSingle(value: Byte[], startIndex: number): number;
    static ToSingle(value: any): number;
    static ToDouble(value: Byte[], startIndex: number): number;
    static ToDouble(value: any): number;
    static ToString(value: Byte[], startIndex: number, length: number): string;
    static ToString(value: Byte[]): string;
    static ToString(value: Byte[], startIndex: number): string;
    static ToBoolean(value: Byte[], startIndex: number): boolean;
    static ToBoolean(value: any): boolean;
    static DoubleToInt64Bits(value: number): number;
    static Int64BitsToDouble(value: number): number;
    static SingleToInt32Bits(value: number): number;
    static Int32BitsToSingle(value: number): number;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Boolean {
    static TrueString: string;
    static FalseString: string;
    GetHashCode(): number;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    Equals(obj: any): boolean;
    Equals(obj: boolean): boolean;
    CompareTo(obj: any): number;
    CompareTo(value: boolean): number;
    static Parse(value: string): boolean;
    static Parse(value: any): boolean;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class Byte {
    static MaxValue: Byte;
    static MinValue: Byte;
    CompareTo(value: any): number;
    CompareTo(value: Byte): number;
    Equals(obj: any): boolean;
    Equals(obj: Byte): boolean;
    GetHashCode(): number;
    static Parse(s: string): Byte;
    static Parse(s: string, style: System.Globalization.NumberStyles): Byte;
    static Parse(s: string, provider: System.IFormatProvider): Byte;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): Byte;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): Byte;
    ToString(): string;
    ToString(format: string): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class Char {
    static MaxValue: System.Char;
    static MinValue: System.Char;
    GetHashCode(): number;
    Equals(obj: any): boolean;
    Equals(obj: System.Char): boolean;
    CompareTo(value: any): number;
    CompareTo(value: System.Char): number;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    static ToString(c: System.Char): string;
    static Parse(s: string): System.Char;
    static IsDigit(c: System.Char): boolean;
    static IsLetter(c: System.Char): boolean;
    static IsWhiteSpace(c: System.Char): boolean;
    static IsUpper(c: System.Char): boolean;
    static IsLower(c: System.Char): boolean;
    static IsPunctuation(c: System.Char): boolean;
    static IsLetterOrDigit(c: System.Char): boolean;
    static ToUpper(c: System.Char, culture: System.Globalization.CultureInfo): System.Char;
    static ToUpper(c: System.Char): System.Char;
    static ToUpperInvariant(c: System.Char): System.Char;
    static ToLower(c: System.Char, culture: System.Globalization.CultureInfo): System.Char;
    static ToLower(c: System.Char): System.Char;
    static ToLowerInvariant(c: System.Char): System.Char;
    GetTypeCode(): System.TypeCode;
    static IsControl(c: System.Char): boolean;
    static IsControl(s: string, index: number): boolean;
    static IsDigit(s: string, index: number): boolean;
    static IsLetter(s: string, index: number): boolean;
    static IsLetterOrDigit(s: string, index: number): boolean;
    static IsLower(s: string, index: number): boolean;
    static IsNumber(c: System.Char): boolean;
    static IsNumber(s: string, index: number): boolean;
    static IsPunctuation(s: string, index: number): boolean;
    static IsSeparator(c: System.Char): boolean;
    static IsSeparator(s: string, index: number): boolean;
    static IsSurrogate(c: System.Char): boolean;
    static IsSurrogate(s: string, index: number): boolean;
    static IsSymbol(c: System.Char): boolean;
    static IsSymbol(s: string, index: number): boolean;
    static IsUpper(s: string, index: number): boolean;
    static IsWhiteSpace(s: string, index: number): boolean;
    static GetUnicodeCategory(c: System.Char): System.Globalization.UnicodeCategory;
    static GetUnicodeCategory(s: string, index: number): System.Globalization.UnicodeCategory;
    static GetNumericValue(c: System.Char): number;
    static GetNumericValue(s: string, index: number): number;
    static IsHighSurrogate(c: System.Char): boolean;
    static IsHighSurrogate(s: string, index: number): boolean;
    static IsLowSurrogate(c: System.Char): boolean;
    static IsLowSurrogate(s: string, index: number): boolean;
    static IsSurrogatePair(s: string, index: number): boolean;
    static IsSurrogatePair(highSurrogate: System.Char, lowSurrogate: System.Char): boolean;
    static ConvertFromUtf32(utf32: number): string;
    static ConvertToUtf32(highSurrogate: System.Char, lowSurrogate: System.Char): number;
    static ConvertToUtf32(s: string, index: number): number;
    GetType(): System.Type;
  }
  export class CharEnumerator {
    Current: System.Char;
    Clone(): any;
    MoveNext(): boolean;
    Dispose(): void;
    Reset(): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Convert {
    static DBNull: any; // System.Object
    static GetTypeCode(value: any): System.TypeCode;
    static IsDBNull(value: any): boolean;
    static ChangeType(value: any, typeCode: System.TypeCode): any;
    static ChangeType(value: any, typeCode: System.TypeCode, provider: System.IFormatProvider): any;
    static ChangeType(value: any, conversionType: System.Type): any;
    static ChangeType(value: any, conversionType: System.Type, provider: System.IFormatProvider): any;
    static ToBoolean(value: any): boolean;
    static ToBoolean(value: any, provider: System.IFormatProvider): boolean;
    static ToBoolean(value: boolean): boolean;
    static ToBoolean(value: System.SByte): boolean;
    static ToBoolean(value: System.Char): boolean;
    static ToBoolean(value: Byte): boolean;
    static ToBoolean(value: number): boolean;
    static ToBoolean(value: number): boolean;
    static ToBoolean(value: number): boolean;
    static ToBoolean(value: number): boolean;
    static ToBoolean(value: number): boolean;
    static ToBoolean(value: number): boolean;
    static ToBoolean(value: string): boolean;
    static ToBoolean(value: string, provider: System.IFormatProvider): boolean;
    static ToBoolean(value: number): boolean;
    static ToBoolean(value: number): boolean;
    static ToBoolean(value: number): boolean;
    static ToBoolean(value: System.DateTime): boolean;
    static ToChar(value: any): System.Char;
    static ToChar(value: any, provider: System.IFormatProvider): System.Char;
    static ToChar(value: boolean): System.Char;
    static ToChar(value: System.Char): System.Char;
    static ToChar(value: System.SByte): System.Char;
    static ToChar(value: Byte): System.Char;
    static ToChar(value: number): System.Char;
    static ToChar(value: number): System.Char;
    static ToChar(value: number): System.Char;
    static ToChar(value: number): System.Char;
    static ToChar(value: number): System.Char;
    static ToChar(value: number): System.Char;
    static ToChar(value: string): System.Char;
    static ToChar(value: string, provider: System.IFormatProvider): System.Char;
    static ToChar(value: number): System.Char;
    static ToChar(value: number): System.Char;
    static ToChar(value: number): System.Char;
    static ToChar(value: System.DateTime): System.Char;
    static ToSByte(value: any): System.SByte;
    static ToSByte(value: any, provider: System.IFormatProvider): System.SByte;
    static ToSByte(value: boolean): System.SByte;
    static ToSByte(value: System.SByte): System.SByte;
    static ToSByte(value: System.Char): System.SByte;
    static ToSByte(value: Byte): System.SByte;
    static ToSByte(value: number): System.SByte;
    static ToSByte(value: number): System.SByte;
    static ToSByte(value: number): System.SByte;
    static ToSByte(value: number): System.SByte;
    static ToSByte(value: number): System.SByte;
    static ToSByte(value: number): System.SByte;
    static ToSByte(value: number): System.SByte;
    static ToSByte(value: number): System.SByte;
    static ToSByte(value: number): System.SByte;
    static ToSByte(value: string): System.SByte;
    static ToSByte(value: string, provider: System.IFormatProvider): System.SByte;
    static ToSByte(value: System.DateTime): System.SByte;
    static ToByte(value: any): Byte;
    static ToByte(value: any, provider: System.IFormatProvider): Byte;
    static ToByte(value: boolean): Byte;
    static ToByte(value: Byte): Byte;
    static ToByte(value: System.Char): Byte;
    static ToByte(value: System.SByte): Byte;
    static ToByte(value: number): Byte;
    static ToByte(value: number): Byte;
    static ToByte(value: number): Byte;
    static ToByte(value: number): Byte;
    static ToByte(value: number): Byte;
    static ToByte(value: number): Byte;
    static ToByte(value: number): Byte;
    static ToByte(value: number): Byte;
    static ToByte(value: number): Byte;
    static ToByte(value: string): Byte;
    static ToByte(value: string, provider: System.IFormatProvider): Byte;
    static ToByte(value: System.DateTime): Byte;
    static ToInt16(value: any): number;
    static ToInt16(value: any, provider: System.IFormatProvider): number;
    static ToInt16(value: boolean): number;
    static ToInt16(value: System.Char): number;
    static ToInt16(value: System.SByte): number;
    static ToInt16(value: Byte): number;
    static ToInt16(value: number): number;
    static ToInt16(value: number): number;
    static ToInt16(value: number): number;
    static ToInt16(value: number): number;
    static ToInt16(value: number): number;
    static ToInt16(value: number): number;
    static ToInt16(value: number): number;
    static ToInt16(value: number): number;
    static ToInt16(value: number): number;
    static ToInt16(value: string): number;
    static ToInt16(value: string, provider: System.IFormatProvider): number;
    static ToInt16(value: System.DateTime): number;
    static ToUInt16(value: any): number;
    static ToUInt16(value: any, provider: System.IFormatProvider): number;
    static ToUInt16(value: boolean): number;
    static ToUInt16(value: System.Char): number;
    static ToUInt16(value: System.SByte): number;
    static ToUInt16(value: Byte): number;
    static ToUInt16(value: number): number;
    static ToUInt16(value: number): number;
    static ToUInt16(value: number): number;
    static ToUInt16(value: number): number;
    static ToUInt16(value: number): number;
    static ToUInt16(value: number): number;
    static ToUInt16(value: number): number;
    static ToUInt16(value: number): number;
    static ToUInt16(value: number): number;
    static ToUInt16(value: string): number;
    static ToUInt16(value: string, provider: System.IFormatProvider): number;
    static ToUInt16(value: System.DateTime): number;
    static ToInt32(value: any): number;
    static ToInt32(value: any, provider: System.IFormatProvider): number;
    static ToInt32(value: boolean): number;
    static ToInt32(value: System.Char): number;
    static ToInt32(value: System.SByte): number;
    static ToInt32(value: Byte): number;
    static ToInt32(value: number): number;
    static ToInt32(value: number): number;
    static ToInt32(value: number): number;
    static ToInt32(value: number): number;
    static ToInt32(value: number): number;
    static ToInt32(value: number): number;
    static ToInt32(value: number): number;
    static ToInt32(value: number): number;
    static ToInt32(value: number): number;
    static ToInt32(value: string): number;
    static ToInt32(value: string, provider: System.IFormatProvider): number;
    static ToInt32(value: System.DateTime): number;
    static ToUInt32(value: any): number;
    static ToUInt32(value: any, provider: System.IFormatProvider): number;
    static ToUInt32(value: boolean): number;
    static ToUInt32(value: System.Char): number;
    static ToUInt32(value: System.SByte): number;
    static ToUInt32(value: Byte): number;
    static ToUInt32(value: number): number;
    static ToUInt32(value: number): number;
    static ToUInt32(value: number): number;
    static ToUInt32(value: number): number;
    static ToUInt32(value: number): number;
    static ToUInt32(value: number): number;
    static ToUInt32(value: number): number;
    static ToUInt32(value: number): number;
    static ToUInt32(value: number): number;
    static ToUInt32(value: string): number;
    static ToUInt32(value: string, provider: System.IFormatProvider): number;
    static ToUInt32(value: System.DateTime): number;
    static ToInt64(value: any): number;
    static ToInt64(value: any, provider: System.IFormatProvider): number;
    static ToInt64(value: boolean): number;
    static ToInt64(value: System.Char): number;
    static ToInt64(value: System.SByte): number;
    static ToInt64(value: Byte): number;
    static ToInt64(value: number): number;
    static ToInt64(value: number): number;
    static ToInt64(value: number): number;
    static ToInt64(value: number): number;
    static ToInt64(value: number): number;
    static ToInt64(value: number): number;
    static ToInt64(value: number): number;
    static ToInt64(value: number): number;
    static ToInt64(value: number): number;
    static ToInt64(value: string): number;
    static ToInt64(value: string, provider: System.IFormatProvider): number;
    static ToInt64(value: System.DateTime): number;
    static ToUInt64(value: any): number;
    static ToUInt64(value: any, provider: System.IFormatProvider): number;
    static ToUInt64(value: boolean): number;
    static ToUInt64(value: System.Char): number;
    static ToUInt64(value: System.SByte): number;
    static ToUInt64(value: Byte): number;
    static ToUInt64(value: number): number;
    static ToUInt64(value: number): number;
    static ToUInt64(value: number): number;
    static ToUInt64(value: number): number;
    static ToUInt64(value: number): number;
    static ToUInt64(value: number): number;
    static ToUInt64(value: number): number;
    static ToUInt64(value: number): number;
    static ToUInt64(value: number): number;
    static ToUInt64(value: string): number;
    static ToUInt64(value: string, provider: System.IFormatProvider): number;
    static ToUInt64(value: System.DateTime): number;
    static ToSingle(value: any): number;
    static ToSingle(value: any, provider: System.IFormatProvider): number;
    static ToSingle(value: System.SByte): number;
    static ToSingle(value: Byte): number;
    static ToSingle(value: System.Char): number;
    static ToSingle(value: number): number;
    static ToSingle(value: number): number;
    static ToSingle(value: number): number;
    static ToSingle(value: number): number;
    static ToSingle(value: number): number;
    static ToSingle(value: number): number;
    static ToSingle(value: number): number;
    static ToSingle(value: number): number;
    static ToSingle(value: number): number;
    static ToSingle(value: string): number;
    static ToSingle(value: string, provider: System.IFormatProvider): number;
    static ToSingle(value: boolean): number;
    static ToSingle(value: System.DateTime): number;
    static ToDouble(value: any): number;
    static ToDouble(value: any, provider: System.IFormatProvider): number;
    static ToDouble(value: System.SByte): number;
    static ToDouble(value: Byte): number;
    static ToDouble(value: number): number;
    static ToDouble(value: System.Char): number;
    static ToDouble(value: number): number;
    static ToDouble(value: number): number;
    static ToDouble(value: number): number;
    static ToDouble(value: number): number;
    static ToDouble(value: number): number;
    static ToDouble(value: number): number;
    static ToDouble(value: number): number;
    static ToDouble(value: number): number;
    static ToDouble(value: string): number;
    static ToDouble(value: string, provider: System.IFormatProvider): number;
    static ToDouble(value: boolean): number;
    static ToDouble(value: System.DateTime): number;
    static ToDecimal(value: any): number;
    static ToDecimal(value: any, provider: System.IFormatProvider): number;
    static ToDecimal(value: System.SByte): number;
    static ToDecimal(value: Byte): number;
    static ToDecimal(value: System.Char): number;
    static ToDecimal(value: number): number;
    static ToDecimal(value: number): number;
    static ToDecimal(value: number): number;
    static ToDecimal(value: number): number;
    static ToDecimal(value: number): number;
    static ToDecimal(value: number): number;
    static ToDecimal(value: number): number;
    static ToDecimal(value: number): number;
    static ToDecimal(value: string): number;
    static ToDecimal(value: string, provider: System.IFormatProvider): number;
    static ToDecimal(value: number): number;
    static ToDecimal(value: boolean): number;
    static ToDecimal(value: System.DateTime): number;
    static ToDateTime(value: System.DateTime): System.DateTime;
    static ToDateTime(value: any): System.DateTime;
    static ToDateTime(value: any, provider: System.IFormatProvider): System.DateTime;
    static ToDateTime(value: string): System.DateTime;
    static ToDateTime(value: string, provider: System.IFormatProvider): System.DateTime;
    static ToDateTime(value: System.SByte): System.DateTime;
    static ToDateTime(value: Byte): System.DateTime;
    static ToDateTime(value: number): System.DateTime;
    static ToDateTime(value: number): System.DateTime;
    static ToDateTime(value: number): System.DateTime;
    static ToDateTime(value: number): System.DateTime;
    static ToDateTime(value: number): System.DateTime;
    static ToDateTime(value: number): System.DateTime;
    static ToDateTime(value: boolean): System.DateTime;
    static ToDateTime(value: System.Char): System.DateTime;
    static ToDateTime(value: number): System.DateTime;
    static ToDateTime(value: number): System.DateTime;
    static ToDateTime(value: number): System.DateTime;
    static ToString(value: any): string;
    static ToString(value: any, provider: System.IFormatProvider): string;
    static ToString(value: boolean): string;
    static ToString(value: boolean, provider: System.IFormatProvider): string;
    static ToString(value: System.Char): string;
    static ToString(value: System.Char, provider: System.IFormatProvider): string;
    static ToString(value: System.SByte): string;
    static ToString(value: System.SByte, provider: System.IFormatProvider): string;
    static ToString(value: Byte): string;
    static ToString(value: Byte, provider: System.IFormatProvider): string;
    static ToString(value: number): string;
    static ToString(value: number, provider: System.IFormatProvider): string;
    static ToString(value: number): string;
    static ToString(value: number, provider: System.IFormatProvider): string;
    static ToString(value: number): string;
    static ToString(value: number, provider: System.IFormatProvider): string;
    static ToString(value: number): string;
    static ToString(value: number, provider: System.IFormatProvider): string;
    static ToString(value: number): string;
    static ToString(value: number, provider: System.IFormatProvider): string;
    static ToString(value: number): string;
    static ToString(value: number, provider: System.IFormatProvider): string;
    static ToString(value: number): string;
    static ToString(value: number, provider: System.IFormatProvider): string;
    static ToString(value: number): string;
    static ToString(value: number, provider: System.IFormatProvider): string;
    static ToString(value: number): string;
    static ToString(value: number, provider: System.IFormatProvider): string;
    static ToString(value: System.DateTime): string;
    static ToString(value: System.DateTime, provider: System.IFormatProvider): string;
    static ToString(value: string): string;
    static ToString(value: string, provider: System.IFormatProvider): string;
    static ToByte(value: string, fromBase: number): Byte;
    static ToSByte(value: string, fromBase: number): System.SByte;
    static ToInt16(value: string, fromBase: number): number;
    static ToUInt16(value: string, fromBase: number): number;
    static ToInt32(value: string, fromBase: number): number;
    static ToUInt32(value: string, fromBase: number): number;
    static ToInt64(value: string, fromBase: number): number;
    static ToUInt64(value: string, fromBase: number): number;
    static ToString(value: Byte, toBase: number): string;
    static ToString(value: number, toBase: number): string;
    static ToString(value: number, toBase: number): string;
    static ToString(value: number, toBase: number): string;
    static ToBase64String(inArray: Byte[]): string;
    static ToBase64String(inArray: Byte[], options: System.Base64FormattingOptions): string;
    static ToBase64String(inArray: Byte[], offset: number, length: number): string;
    static ToBase64String(inArray: Byte[], offset: number, length: number, options: System.Base64FormattingOptions): string;
    static ToBase64String(bytes: any, options?: System.Base64FormattingOptions): string;
    static ToBase64CharArray(inArray: Byte[], offsetIn: number, length: number, outArray: System.Char[], offsetOut: number): number;
    static ToBase64CharArray(inArray: Byte[], offsetIn: number, length: number, outArray: System.Char[], offsetOut: number, options: System.Base64FormattingOptions): number;
    static FromBase64String(s: string): Byte[];
    static FromBase64CharArray(inArray: System.Char[], offset: number, length: number): Byte[];
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export enum Base64FormattingOptions {
    None = 0,
    InsertLineBreaks = 1,
  }
  export class DBNull {
    static Value: System.DBNull;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    GetTypeCode(): System.TypeCode;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class DataMisalignedException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class DateTime {
    constructor(ticks: number);
    constructor(ticks: number, kind: System.DateTimeKind);
    constructor(year: number, month: number, day: number);
    constructor(year: number, month: number, day: number, calendar: System.Globalization.Calendar);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, kind: System.DateTimeKind);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, calendar: System.Globalization.Calendar);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, kind: System.DateTimeKind);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: System.Globalization.Calendar);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: System.Globalization.Calendar, kind: System.DateTimeKind);
    Date: System.DateTime;
    Day: number;
    DayOfWeek: System.DayOfWeek;
    DayOfYear: number;
    Hour: number;
    Kind: System.DateTimeKind;
    Millisecond: number;
    Minute: number;
    Month: number;
    static Now: System.DateTime;
    Second: number;
    Ticks: number;
    TimeOfDay: System.TimeSpan;
    static Today: System.DateTime;
    Year: number;
    static UtcNow: System.DateTime;
    static MinValue: System.DateTime;
    static MaxValue: System.DateTime;
    static UnixEpoch: System.DateTime;
    Add(value: System.TimeSpan): System.DateTime;
    AddDays(value: number): System.DateTime;
    AddHours(value: number): System.DateTime;
    AddMilliseconds(value: number): System.DateTime;
    AddMinutes(value: number): System.DateTime;
    AddMonths(months: number): System.DateTime;
    AddSeconds(value: number): System.DateTime;
    AddTicks(value: number): System.DateTime;
    AddYears(value: number): System.DateTime;
    static Compare(t1: System.DateTime, t2: System.DateTime): number;
    CompareTo(value: any): number;
    CompareTo(value: System.DateTime): number;
    static DaysInMonth(year: number, month: number): number;
    Equals(value: any): boolean;
    Equals(value: System.DateTime): boolean;
    static Equals(t1: System.DateTime, t2: System.DateTime): boolean;
    static FromBinary(dateData: number): System.DateTime;
    static FromFileTime(fileTime: number): System.DateTime;
    static FromFileTimeUtc(fileTime: number): System.DateTime;
    static FromOADate(d: number): System.DateTime;
    IsDaylightSavingTime(): boolean;
    static SpecifyKind(value: System.DateTime, kind: System.DateTimeKind): System.DateTime;
    ToBinary(): number;
    GetHashCode(): number;
    static IsLeapYear(year: number): boolean;
    static Parse(s: string): System.DateTime;
    static Parse(s: string, provider: System.IFormatProvider): System.DateTime;
    static Parse(s: string, provider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles): System.DateTime;
    static Parse(s: any, provider?: System.IFormatProvider, styles?: System.Globalization.DateTimeStyles): System.DateTime;
    static ParseExact(s: string, format: string, provider: System.IFormatProvider): System.DateTime;
    static ParseExact(s: string, format: string, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles): System.DateTime;
    static ParseExact(s: any, format: any, provider: System.IFormatProvider, style?: System.Globalization.DateTimeStyles): System.DateTime;
    static ParseExact(s: string, formats: string[], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles): System.DateTime;
    static ParseExact(s: any, formats: string[], provider: System.IFormatProvider, style?: System.Globalization.DateTimeStyles): System.DateTime;
    Subtract(value: System.DateTime): System.TimeSpan;
    Subtract(value: System.TimeSpan): System.DateTime;
    ToOADate(): number;
    ToFileTime(): number;
    ToFileTimeUtc(): number;
    ToLocalTime(): System.DateTime;
    ToLongDateString(): string;
    ToLongTimeString(): string;
    ToShortDateString(): string;
    ToShortTimeString(): string;
    ToString(): string;
    ToString(format: string): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    ToUniversalTime(): System.DateTime;
    GetDateTimeFormats(): string[];
    GetDateTimeFormats(provider: System.IFormatProvider): string[];
    GetDateTimeFormats(format: System.Char): string[];
    GetDateTimeFormats(format: System.Char, provider: System.IFormatProvider): string[];
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export enum DateTimeKind {
    Unspecified = 0,
    Utc = 1,
    Local = 2,
  }
  export class DateTimeOffset {
    constructor(ticks: number, offset: System.TimeSpan);
    constructor(dateTime: System.DateTime);
    constructor(dateTime: System.DateTime, offset: System.TimeSpan);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, offset: System.TimeSpan);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, offset: System.TimeSpan);
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: System.Globalization.Calendar, offset: System.TimeSpan);
    static Now: System.DateTimeOffset;
    static UtcNow: System.DateTimeOffset;
    DateTime: System.DateTime;
    UtcDateTime: System.DateTime;
    LocalDateTime: System.DateTime;
    Date: System.DateTime;
    Day: number;
    DayOfWeek: System.DayOfWeek;
    DayOfYear: number;
    Hour: number;
    Millisecond: number;
    Minute: number;
    Month: number;
    Offset: System.TimeSpan;
    Second: number;
    Ticks: number;
    UtcTicks: number;
    TimeOfDay: System.TimeSpan;
    Year: number;
    static MinValue: System.DateTimeOffset;
    static MaxValue: System.DateTimeOffset;
    static UnixEpoch: System.DateTimeOffset;
    ToOffset(offset: System.TimeSpan): System.DateTimeOffset;
    Add(timeSpan: System.TimeSpan): System.DateTimeOffset;
    AddDays(days: number): System.DateTimeOffset;
    AddHours(hours: number): System.DateTimeOffset;
    AddMilliseconds(milliseconds: number): System.DateTimeOffset;
    AddMinutes(minutes: number): System.DateTimeOffset;
    AddMonths(months: number): System.DateTimeOffset;
    AddSeconds(seconds: number): System.DateTimeOffset;
    AddTicks(ticks: number): System.DateTimeOffset;
    AddYears(years: number): System.DateTimeOffset;
    static Compare(first: System.DateTimeOffset, second: System.DateTimeOffset): number;
    CompareTo(other: System.DateTimeOffset): number;
    Equals(obj: any): boolean;
    Equals(other: System.DateTimeOffset): boolean;
    EqualsExact(other: System.DateTimeOffset): boolean;
    static Equals(first: System.DateTimeOffset, second: System.DateTimeOffset): boolean;
    static FromFileTime(fileTime: number): System.DateTimeOffset;
    static FromUnixTimeSeconds(seconds: number): System.DateTimeOffset;
    static FromUnixTimeMilliseconds(milliseconds: number): System.DateTimeOffset;
    GetHashCode(): number;
    static Parse(input: string): System.DateTimeOffset;
    static Parse(input: string, formatProvider: System.IFormatProvider): System.DateTimeOffset;
    static Parse(input: string, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles): System.DateTimeOffset;
    static Parse(input: any, formatProvider?: System.IFormatProvider, styles?: System.Globalization.DateTimeStyles): System.DateTimeOffset;
    static ParseExact(input: string, format: string, formatProvider: System.IFormatProvider): System.DateTimeOffset;
    static ParseExact(input: string, format: string, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles): System.DateTimeOffset;
    static ParseExact(input: any, format: any, formatProvider: System.IFormatProvider, styles?: System.Globalization.DateTimeStyles): System.DateTimeOffset;
    static ParseExact(input: string, formats: string[], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles): System.DateTimeOffset;
    static ParseExact(input: any, formats: string[], formatProvider: System.IFormatProvider, styles?: System.Globalization.DateTimeStyles): System.DateTimeOffset;
    Subtract(value: System.DateTimeOffset): System.TimeSpan;
    Subtract(value: System.TimeSpan): System.DateTimeOffset;
    ToFileTime(): number;
    ToUnixTimeSeconds(): number;
    ToUnixTimeMilliseconds(): number;
    ToLocalTime(): System.DateTimeOffset;
    ToString(): string;
    ToString(format: string): string;
    ToString(formatProvider: System.IFormatProvider): string;
    ToString(format: string, formatProvider: System.IFormatProvider): string;
    ToUniversalTime(): System.DateTimeOffset;
    GetType(): System.Type;
  }
  export enum DayOfWeek {
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
  }
  export class DivideByZeroException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class DllNotFoundException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    TypeName: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Double {
    static MinValue: number;
    static MaxValue: number;
    static Epsilon: number;
    static NegativeInfinity: number;
    static PositiveInfinity: number;
    static NaN: number;
    static IsFinite(d: number): boolean;
    static IsInfinity(d: number): boolean;
    static IsNaN(d: number): boolean;
    static IsNegative(d: number): boolean;
    static IsNegativeInfinity(d: number): boolean;
    static IsNormal(d: number): boolean;
    static IsPositiveInfinity(d: number): boolean;
    static IsSubnormal(d: number): boolean;
    CompareTo(value: any): number;
    CompareTo(value: number): number;
    Equals(obj: any): boolean;
    Equals(obj: number): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): number;
    static Parse(s: string, style: System.Globalization.NumberStyles): number;
    static Parse(s: string, provider: System.IFormatProvider): number;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): number;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): number;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class DuplicateWaitObjectException {
    constructor();
    constructor(parameterName: string);
    constructor(parameterName: string, message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    ParamName: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class EntryPointNotFoundException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    TypeName: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class EventArgs {
    constructor();
    static Empty: System.EventArgs;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class EventHandler<TEventArgs = any> {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(sender: any, e: TEventArgs): void;
    BeginInvoke(sender: any, e: TEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): void;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class ExecutionEngineException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class FieldAccessException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class FormatException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class FormattableString {
    Format: string;
    ArgumentCount: number;
    GetArguments(): any[];
    GetArgument(index: number): any;
    ToString(formatProvider: System.IFormatProvider): string;
    static Invariant(formattable: System.FormattableString): string;
    ToString(): string;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Guid {
    constructor(b: Byte[]);
    constructor(b: System.ReadOnlySpan<Byte>);
    constructor(a: number, b: number, c: number, d: Byte, e: Byte, f: Byte, g: Byte, h: Byte, i: Byte, j: Byte, k: Byte);
    constructor(a: number, b: number, c: number, d: Byte[]);
    constructor(a: number, b: number, c: number, d: Byte, e: Byte, f: Byte, g: Byte, h: Byte, i: Byte, j: Byte, k: Byte);
    constructor(g: string);
    static Empty: System.Guid;
    static NewGuid(): System.Guid;
    static Parse(input: string): System.Guid;
    static Parse(input: any): System.Guid;
    static ParseExact(input: string, format: string): System.Guid;
    static ParseExact(input: any, format: any): System.Guid;
    ToByteArray(): Byte[];
    TryWriteBytes(destination: System.Span<Byte>): boolean;
    ToString(): string;
    GetHashCode(): number;
    Equals(o: any): boolean;
    Equals(g: System.Guid): boolean;
    CompareTo(value: any): number;
    CompareTo(value: System.Guid): number;
    ToString(format: string): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    GetType(): System.Type;
  }
  export class HashCode {
    ToHashCode(): number;
    GetHashCode(): number;
    Equals(obj: any): boolean;
    ToString(): string;
    GetType(): System.Type;
  }
  export interface IAsyncDisposable {
    DisposeAsync(): System.Threading.Tasks.ValueTask;
  }
  export interface IAsyncResult {
    IsCompleted: boolean;
    AsyncWaitHandle: System.Threading.WaitHandle;
    AsyncState: any; // System.Object
    CompletedSynchronously: boolean;
  }
  export interface ICloneable {
    Clone(): any;
  }
  export interface IComparable<T = any> {
    CompareTo(other: T): number;
  }
  export interface IConvertible {
    GetTypeCode(): System.TypeCode;
    ToBoolean(provider: System.IFormatProvider): boolean;
    ToChar(provider: System.IFormatProvider): System.Char;
    ToSByte(provider: System.IFormatProvider): System.SByte;
    ToByte(provider: System.IFormatProvider): Byte;
    ToInt16(provider: System.IFormatProvider): number;
    ToUInt16(provider: System.IFormatProvider): number;
    ToInt32(provider: System.IFormatProvider): number;
    ToUInt32(provider: System.IFormatProvider): number;
    ToInt64(provider: System.IFormatProvider): number;
    ToUInt64(provider: System.IFormatProvider): number;
    ToSingle(provider: System.IFormatProvider): number;
    ToDouble(provider: System.IFormatProvider): number;
    ToDecimal(provider: System.IFormatProvider): number;
    ToDateTime(provider: System.IFormatProvider): System.DateTime;
    ToString(provider: System.IFormatProvider): string;
    ToType(conversionType: System.Type, provider: System.IFormatProvider): any;
  }
  export interface ICustomFormatter {
    Format(format: string, arg: any, formatProvider: System.IFormatProvider): string;
  }
  export interface IDisposable {
    Dispose(): void;
  }
  export interface IEquatable<T = any> {
    Equals(other: T): boolean;
  }
  export interface IFormatProvider {
    GetFormat(formatType: System.Type): any;
  }
  export interface IFormattable {
    ToString(format: string, formatProvider: System.IFormatProvider): string;
  }
  export interface IObservable<T = any> {
    Subscribe(observer: System.IObserver<T>): System.IDisposable;
  }
  export interface IObserver<T = any> {
    OnNext(value: T): void;
    OnError(error: System.Exception): void;
    OnCompleted(): void;
  }
  export interface IProgress<T = any> {
    Report(value: T): void;
  }
  export class Index {
    constructor(value: number, fromEnd?: boolean);
    static Start: System.Index;
    static End: System.Index;
    Value: number;
    IsFromEnd: boolean;
    static FromStart(value: number): System.Index;
    static FromEnd(value: number): System.Index;
    GetOffset(length: number): number;
    Equals(value: any): boolean;
    Equals(other: System.Index): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class IndexOutOfRangeException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class InsufficientExecutionStackException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Int16 {
    static MaxValue: number;
    static MinValue: number;
    CompareTo(value: any): number;
    CompareTo(value: number): number;
    Equals(obj: any): boolean;
    Equals(obj: number): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): number;
    static Parse(s: string, style: System.Globalization.NumberStyles): number;
    static Parse(s: string, provider: System.IFormatProvider): number;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): number;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): number;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class Int32 {
    static MaxValue: number;
    static MinValue: number;
    CompareTo(value: any): number;
    CompareTo(value: number): number;
    Equals(obj: any): boolean;
    Equals(obj: number): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): number;
    static Parse(s: string, style: System.Globalization.NumberStyles): number;
    static Parse(s: string, provider: System.IFormatProvider): number;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): number;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): number;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class Int64 {
    static MaxValue: number;
    static MinValue: number;
    CompareTo(value: any): number;
    CompareTo(value: number): number;
    Equals(obj: any): boolean;
    Equals(obj: number): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): number;
    static Parse(s: string, style: System.Globalization.NumberStyles): number;
    static Parse(s: string, provider: System.IFormatProvider): number;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): number;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): number;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class InvalidCastException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    constructor(message: string, errorCode: number);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class InvalidOperationException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class InvalidProgramException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class InvalidTimeZoneException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Lazy<T = any> {
    constructor();
    constructor(value: T);
    constructor(valueFactory: (() => T));
    constructor(isThreadSafe: boolean);
    constructor(mode: System.Threading.LazyThreadSafetyMode);
    constructor(valueFactory: (() => T), isThreadSafe: boolean);
    constructor(valueFactory: (() => T), mode: System.Threading.LazyThreadSafetyMode);
    IsValueCreated: boolean;
    Value: T;
    ToString(): string;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Math {
    static E: number;
    static PI: number;
    static Abs(value: number): number;
    static Abs(value: number): number;
    static Abs(value: number): number;
    static Abs(value: System.SByte): System.SByte;
    static Abs(value: number): number;
    static BigMul(a: number, b: number): number;
    static Ceiling(d: number): number;
    static Clamp(value: Byte, min: Byte, max: Byte): Byte;
    static Clamp(value: number, min: number, max: number): number;
    static Clamp(value: number, min: number, max: number): number;
    static Clamp(value: number, min: number, max: number): number;
    static Clamp(value: number, min: number, max: number): number;
    static Clamp(value: number, min: number, max: number): number;
    static Clamp(value: System.SByte, min: System.SByte, max: System.SByte): System.SByte;
    static Clamp(value: number, min: number, max: number): number;
    static Clamp(value: number, min: number, max: number): number;
    static Clamp(value: number, min: number, max: number): number;
    static Clamp(value: number, min: number, max: number): number;
    static Floor(d: number): number;
    static IEEERemainder(x: number, y: number): number;
    static Log(a: number, newBase: number): number;
    static Max(val1: Byte, val2: Byte): Byte;
    static Max(val1: number, val2: number): number;
    static Max(val1: number, val2: number): number;
    static Max(val1: number, val2: number): number;
    static Max(val1: number, val2: number): number;
    static Max(val1: number, val2: number): number;
    static Max(val1: System.SByte, val2: System.SByte): System.SByte;
    static Max(val1: number, val2: number): number;
    static Max(val1: number, val2: number): number;
    static Max(val1: number, val2: number): number;
    static Max(val1: number, val2: number): number;
    static Min(val1: Byte, val2: Byte): Byte;
    static Min(val1: number, val2: number): number;
    static Min(val1: number, val2: number): number;
    static Min(val1: number, val2: number): number;
    static Min(val1: number, val2: number): number;
    static Min(val1: number, val2: number): number;
    static Min(val1: System.SByte, val2: System.SByte): System.SByte;
    static Min(val1: number, val2: number): number;
    static Min(val1: number, val2: number): number;
    static Min(val1: number, val2: number): number;
    static Min(val1: number, val2: number): number;
    static Round(d: number): number;
    static Round(d: number, decimals: number): number;
    static Round(d: number, mode: System.MidpointRounding): number;
    static Round(d: number, decimals: number, mode: System.MidpointRounding): number;
    static Round(a: number): number;
    static Round(value: number, digits: number): number;
    static Round(value: number, mode: System.MidpointRounding): number;
    static Round(value: number, digits: number, mode: System.MidpointRounding): number;
    static Sign(value: number): number;
    static Sign(value: number): number;
    static Sign(value: number): number;
    static Sign(value: number): number;
    static Sign(value: number): number;
    static Sign(value: System.SByte): number;
    static Sign(value: number): number;
    static Truncate(d: number): number;
    static Truncate(d: number): number;
    static Abs(value: number): number;
    static Abs(value: number): number;
    static Acos(d: number): number;
    static Acosh(d: number): number;
    static Asin(d: number): number;
    static Asinh(d: number): number;
    static Atan(d: number): number;
    static Atan2(y: number, x: number): number;
    static Atanh(d: number): number;
    static Cbrt(d: number): number;
    static Ceiling(a: number): number;
    static Cos(d: number): number;
    static Cosh(value: number): number;
    static Exp(d: number): number;
    static Floor(d: number): number;
    static Log(d: number): number;
    static Log10(d: number): number;
    static Pow(x: number, y: number): number;
    static Sin(a: number): number;
    static Sinh(value: number): number;
    static Sqrt(d: number): number;
    static Tan(a: number): number;
    static Tanh(value: number): number;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class MathF {
    static E: number;
    static PI: number;
    static Abs(x: number): number;
    static IEEERemainder(x: number, y: number): number;
    static Log(x: number, y: number): number;
    static Max(x: number, y: number): number;
    static Min(x: number, y: number): number;
    static Round(x: number): number;
    static Round(x: number, digits: number): number;
    static Round(x: number, mode: System.MidpointRounding): number;
    static Round(x: number, digits: number, mode: System.MidpointRounding): number;
    static Sign(x: number): number;
    static Truncate(x: number): number;
    static Acos(x: number): number;
    static Acosh(x: number): number;
    static Asin(x: number): number;
    static Asinh(x: number): number;
    static Atan(x: number): number;
    static Atan2(y: number, x: number): number;
    static Atanh(x: number): number;
    static Cbrt(x: number): number;
    static Ceiling(x: number): number;
    static Cos(x: number): number;
    static Cosh(x: number): number;
    static Exp(x: number): number;
    static Floor(x: number): number;
    static Log(x: number): number;
    static Log10(x: number): number;
    static Pow(x: number, y: number): number;
    static Sin(x: number): number;
    static Sinh(x: number): number;
    static Sqrt(x: number): number;
    static Tan(x: number): number;
    static Tanh(x: number): number;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class MemberAccessException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Memory<T = any> {
    constructor(array: T[]);
    constructor(array: T[], start: number, length: number);
    static Empty: any; // System.Memory`1[T]
    Length: number;
    IsEmpty: boolean;
    Span: System.Span<T>;
    ToString(): string;
    Slice(start: number): System.Memory<T>;
    Slice(start: number, length: number): System.Memory<T>;
    CopyTo(destination: System.Memory<T>): void;
    TryCopyTo(destination: System.Memory<T>): boolean;
    Pin(): System.Buffers.MemoryHandle;
    ToArray(): T[];
    Equals(obj: any): boolean;
    Equals(other: System.Memory<T>): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class MemoryExtensions {
    static Contains(span: any, value: any, comparisonType: System.StringComparison): boolean;
    static Equals(span: any, other: any, comparisonType: System.StringComparison): boolean;
    static CompareTo(span: any, other: any, comparisonType: System.StringComparison): number;
    static IndexOf(span: any, value: any, comparisonType: System.StringComparison): number;
    static ToLower(source: any, destination: any, culture: System.Globalization.CultureInfo): number;
    static ToLowerInvariant(source: any, destination: any): number;
    static ToUpper(source: any, destination: any, culture: System.Globalization.CultureInfo): number;
    static ToUpperInvariant(source: any, destination: any): number;
    static EndsWith(span: any, value: any, comparisonType: System.StringComparison): boolean;
    static StartsWith(span: any, value: any, comparisonType: System.StringComparison): boolean;
    static AsSpan(text: string): any;
    static AsSpan(text: string, start: number): any;
    static AsSpan(text: string, start: number, length: number): any;
    static AsMemory(text: string): any;
    static AsMemory(text: string, start: number): any;
    static AsMemory(text: string, startIndex: System.Index): any;
    static AsMemory(text: string, start: number, length: number): any;
    static AsMemory(text: string, range: System.Range): any;
    static Trim(span: any): any;
    static TrimStart(span: any): any;
    static TrimEnd(span: any): any;
    static Trim(span: any, trimChar: System.Char): any;
    static TrimStart(span: any, trimChar: System.Char): any;
    static TrimEnd(span: any, trimChar: System.Char): any;
    static Trim(span: any, trimChars: any): any;
    static TrimStart(span: any, trimChars: any): any;
    static TrimEnd(span: any, trimChars: any): any;
    static IsWhiteSpace(span: any): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class MethodAccessException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export enum MidpointRounding {
    ToEven = 0,
    AwayFromZero = 1,
  }
  export class MissingMethodException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    constructor(className: string, methodName: string);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class MulticastNotSupportedException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class NotFiniteNumberException {
    constructor();
    constructor(offendingNumber: number);
    constructor(message: string);
    constructor(message: string, offendingNumber: number);
    constructor(message: string, innerException: System.Exception);
    constructor(message: string, offendingNumber: number, innerException: System.Exception);
    OffendingNumber: number;
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class NotImplementedException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class NotSupportedException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class NullReferenceException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Nullable<T = any> {
    constructor(value: T);
    HasValue: boolean;
    Value: T;
    GetValueOrDefault(): T;
    GetValueOrDefault(defaultValue: T): T;
    Equals(other: any): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class ObjectDisposedException {
    constructor(objectName: string);
    constructor(objectName: string, message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    ObjectName: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class OperationCanceledException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    constructor(token: System.Threading.CancellationToken);
    constructor(message: string, token: System.Threading.CancellationToken);
    constructor(message: string, innerException: System.Exception, token: System.Threading.CancellationToken);
    CancellationToken: System.Threading.CancellationToken;
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class OverflowException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class PlatformNotSupportedException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Progress<T = any> {
    constructor();
    constructor(handler: ((obj: T) => void));
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Random {
    constructor();
    constructor(Seed: number);
    Next(): number;
    Next(minValue: number, maxValue: number): number;
    Next(maxValue: number): number;
    NextDouble(): number;
    NextBytes(buffer: Byte[]): void;
    NextBytes(buffer: System.Span<Byte>): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Range {
    constructor(start: System.Index, end: System.Index);
    Start: System.Index;
    End: System.Index;
    static All: System.Range;
    Equals(value: any): boolean;
    Equals(other: System.Range): boolean;
    GetHashCode(): number;
    ToString(): string;
    static StartAt(start: System.Index): System.Range;
    static EndAt(end: System.Index): System.Range;
    GetOffsetAndLength(length: number): System.ValueTuple<number, number>;
    GetType(): System.Type;
  }
  export class RankException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ReadOnlyMemory<T = any> {
    constructor(array: T[]);
    constructor(array: T[], start: number, length: number);
    static Empty: any; // System.ReadOnlyMemory`1[T]
    Length: number;
    IsEmpty: boolean;
    Span: System.ReadOnlySpan<T>;
    ToString(): string;
    Slice(start: number): System.ReadOnlyMemory<T>;
    Slice(start: number, length: number): System.ReadOnlyMemory<T>;
    CopyTo(destination: System.Memory<T>): void;
    TryCopyTo(destination: System.Memory<T>): boolean;
    Pin(): System.Buffers.MemoryHandle;
    ToArray(): T[];
    Equals(obj: any): boolean;
    Equals(other: System.ReadOnlyMemory<T>): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ReadOnlySpan<T = any> {
    constructor(array: T[]);
    constructor(array: T[], start: number, length: number);
    Length: number;
    IsEmpty: boolean;
    static Empty: any; // System.ReadOnlySpan`1[T]
    CopyTo(destination: System.Span<T>): void;
    TryCopyTo(destination: System.Span<T>): boolean;
    ToString(): string;
    Slice(start: number): System.ReadOnlySpan<T>;
    Slice(start: number, length: number): System.ReadOnlySpan<T>;
    ToArray(): T[];
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetEnumerator(): System.ReadOnlySpan<T>;
    GetType(): System.Type;
  }
  export class ResolveEventArgs {
    constructor(name: string);
    constructor(name: string, requestingAssembly: System.Reflection.Assembly);
    Name: string;
    RequestingAssembly: System.Reflection.Assembly;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class ResolveEventHandler {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(sender: any, args: System.ResolveEventArgs): System.Reflection.Assembly;
    BeginInvoke(sender: any, args: System.ResolveEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): System.Reflection.Assembly;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class SByte {
    static MaxValue: System.SByte;
    static MinValue: System.SByte;
    CompareTo(obj: any): number;
    CompareTo(value: System.SByte): number;
    Equals(obj: any): boolean;
    Equals(obj: System.SByte): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): System.SByte;
    static Parse(s: string, style: System.Globalization.NumberStyles): System.SByte;
    static Parse(s: string, provider: System.IFormatProvider): System.SByte;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): System.SByte;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): System.SByte;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class Single {
    static MinValue: number;
    static Epsilon: number;
    static MaxValue: number;
    static PositiveInfinity: number;
    static NegativeInfinity: number;
    static NaN: number;
    static IsFinite(f: number): boolean;
    static IsInfinity(f: number): boolean;
    static IsNaN(f: number): boolean;
    static IsNegative(f: number): boolean;
    static IsNegativeInfinity(f: number): boolean;
    static IsNormal(f: number): boolean;
    static IsPositiveInfinity(f: number): boolean;
    static IsSubnormal(f: number): boolean;
    CompareTo(value: any): number;
    CompareTo(value: number): number;
    Equals(obj: any): boolean;
    Equals(obj: number): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): number;
    static Parse(s: string, style: System.Globalization.NumberStyles): number;
    static Parse(s: string, provider: System.IFormatProvider): number;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): number;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): number;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class Span<T = any> {
    constructor(array: T[]);
    constructor(array: T[], start: number, length: number);
    Length: number;
    IsEmpty: boolean;
    static Empty: any; // System.Span`1[T]
    Clear(): void;
    Fill(value: T): void;
    CopyTo(destination: System.Span<T>): void;
    TryCopyTo(destination: System.Span<T>): boolean;
    ToString(): string;
    Slice(start: number): System.Span<T>;
    Slice(start: number, length: number): System.Span<T>;
    ToArray(): T[];
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetEnumerator(): System.Span<T>;
    GetType(): System.Type;
  }
  export class StackOverflowException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class StringComparer {
    static InvariantCulture: System.StringComparer;
    static InvariantCultureIgnoreCase: System.StringComparer;
    static CurrentCulture: System.StringComparer;
    static CurrentCultureIgnoreCase: System.StringComparer;
    static Ordinal: System.StringComparer;
    static OrdinalIgnoreCase: System.StringComparer;
    static FromComparison(comparisonType: System.StringComparison): System.StringComparer;
    static Create(culture: System.Globalization.CultureInfo, ignoreCase: boolean): System.StringComparer;
    static Create(culture: System.Globalization.CultureInfo, options: System.Globalization.CompareOptions): System.StringComparer;
    Compare(x: any, y: any): number;
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): number;
    Compare(x: string, y: string): number;
    Equals(x: string, y: string): boolean;
    GetHashCode(obj: string): number;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class CultureAwareComparer {
    Compare(x: string, y: string): number;
    Equals(x: string, y: string): boolean;
    GetHashCode(obj: string): number;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Compare(x: any, y: any): number;
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class OrdinalComparer {
    Compare(x: string, y: string): number;
    Equals(x: string, y: string): boolean;
    GetHashCode(obj: string): number;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    Compare(x: any, y: any): number;
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export enum StringComparison {
    CurrentCulture = 0,
    CurrentCultureIgnoreCase = 1,
    InvariantCulture = 2,
    InvariantCultureIgnoreCase = 3,
    Ordinal = 4,
    OrdinalIgnoreCase = 5,
  }
  export enum StringSplitOptions {
    None = 0,
    RemoveEmptyEntries = 1,
  }
  export class SystemException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class TimeSpan {
    constructor(ticks: number);
    constructor(hours: number, minutes: number, seconds: number);
    constructor(days: number, hours: number, minutes: number, seconds: number);
    constructor(days: number, hours: number, minutes: number, seconds: number, milliseconds: number);
    Ticks: number;
    Days: number;
    Hours: number;
    Milliseconds: number;
    Minutes: number;
    Seconds: number;
    TotalDays: number;
    TotalHours: number;
    TotalMilliseconds: number;
    TotalMinutes: number;
    TotalSeconds: number;
    static TicksPerMillisecond: number;
    static TicksPerSecond: number;
    static TicksPerMinute: number;
    static TicksPerHour: number;
    static TicksPerDay: number;
    static Zero: System.TimeSpan;
    static MaxValue: System.TimeSpan;
    static MinValue: System.TimeSpan;
    Add(ts: System.TimeSpan): System.TimeSpan;
    static Compare(t1: System.TimeSpan, t2: System.TimeSpan): number;
    CompareTo(value: any): number;
    CompareTo(value: System.TimeSpan): number;
    static FromDays(value: number): System.TimeSpan;
    Duration(): System.TimeSpan;
    Equals(value: any): boolean;
    Equals(obj: System.TimeSpan): boolean;
    static Equals(t1: System.TimeSpan, t2: System.TimeSpan): boolean;
    GetHashCode(): number;
    static FromHours(value: number): System.TimeSpan;
    static FromMilliseconds(value: number): System.TimeSpan;
    static FromMinutes(value: number): System.TimeSpan;
    Negate(): System.TimeSpan;
    static FromSeconds(value: number): System.TimeSpan;
    Subtract(ts: System.TimeSpan): System.TimeSpan;
    Multiply(factor: number): System.TimeSpan;
    Divide(divisor: number): System.TimeSpan;
    Divide(ts: System.TimeSpan): number;
    static FromTicks(value: number): System.TimeSpan;
    static Parse(s: string): System.TimeSpan;
    static Parse(input: string, formatProvider: System.IFormatProvider): System.TimeSpan;
    static Parse(input: any, formatProvider?: System.IFormatProvider): System.TimeSpan;
    static ParseExact(input: string, format: string, formatProvider: System.IFormatProvider): System.TimeSpan;
    static ParseExact(input: string, formats: string[], formatProvider: System.IFormatProvider): System.TimeSpan;
    static ParseExact(input: string, format: string, formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles): System.TimeSpan;
    static ParseExact(input: any, format: any, formatProvider: System.IFormatProvider, styles?: System.Globalization.TimeSpanStyles): System.TimeSpan;
    static ParseExact(input: string, formats: string[], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles): System.TimeSpan;
    static ParseExact(input: any, formats: string[], formatProvider: System.IFormatProvider, styles?: System.Globalization.TimeSpanStyles): System.TimeSpan;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: System.IFormatProvider): string;
    GetType(): System.Type;
  }
  export class TimeZone {
    static CurrentTimeZone: System.TimeZone;
    StandardName: string;
    DaylightName: string;
    GetUtcOffset(time: System.DateTime): System.TimeSpan;
    ToUniversalTime(time: System.DateTime): System.DateTime;
    ToLocalTime(time: System.DateTime): System.DateTime;
    GetDaylightChanges(year: number): System.Globalization.DaylightTime;
    IsDaylightSavingTime(time: System.DateTime): boolean;
    static IsDaylightSavingTime(time: System.DateTime, daylightTimes: System.Globalization.DaylightTime): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class TimeZoneNotFoundException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class TimeoutException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Tuple<T1 = any, T2 = any, T3 = any, T4 = any, T5 = any, T6 = any, T7 = any, TRest = any> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, rest: TRest);
    Item1: T1;
    Item2: T2;
    Item3: T3;
    Item4: T4;
    Item5: T5;
    Item6: T6;
    Item7: T7;
    Rest: TRest;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class TupleExtensions {
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Type {
    IsSerializable: boolean;
    ContainsGenericParameters: boolean;
    IsVisible: boolean;
    MemberType: System.Reflection.MemberTypes;
    Namespace: string;
    AssemblyQualifiedName: string;
    FullName: string;
    Assembly: System.Reflection.Assembly;
    Module: System.Reflection.Module;
    IsNested: boolean;
    DeclaringType: System.Type;
    DeclaringMethod: System.Reflection.MethodBase;
    ReflectedType: System.Type;
    UnderlyingSystemType: System.Type;
    IsTypeDefinition: boolean;
    IsArray: boolean;
    IsByRef: boolean;
    IsPointer: boolean;
    IsConstructedGenericType: boolean;
    IsGenericParameter: boolean;
    IsGenericTypeParameter: boolean;
    IsGenericMethodParameter: boolean;
    IsGenericType: boolean;
    IsGenericTypeDefinition: boolean;
    IsSZArray: boolean;
    IsVariableBoundArray: boolean;
    IsByRefLike: boolean;
    HasElementType: boolean;
    GenericTypeArguments: System.Type[];
    GenericParameterPosition: number;
    GenericParameterAttributes: System.Reflection.GenericParameterAttributes;
    Attributes: System.Reflection.TypeAttributes;
    IsAbstract: boolean;
    IsImport: boolean;
    IsSealed: boolean;
    IsSpecialName: boolean;
    IsClass: boolean;
    IsNestedAssembly: boolean;
    IsNestedFamANDAssem: boolean;
    IsNestedFamily: boolean;
    IsNestedFamORAssem: boolean;
    IsNestedPrivate: boolean;
    IsNestedPublic: boolean;
    IsNotPublic: boolean;
    IsPublic: boolean;
    IsAutoLayout: boolean;
    IsExplicitLayout: boolean;
    IsLayoutSequential: boolean;
    IsAnsiClass: boolean;
    IsAutoClass: boolean;
    IsUnicodeClass: boolean;
    IsCOMObject: boolean;
    IsContextful: boolean;
    IsCollectible: boolean;
    IsEnum: boolean;
    IsMarshalByRef: boolean;
    IsPrimitive: boolean;
    IsValueType: boolean;
    IsSignatureType: boolean;
    IsSecurityCritical: boolean;
    IsSecuritySafeCritical: boolean;
    IsSecurityTransparent: boolean;
    StructLayoutAttribute: any; // System.Runtime.InteropServices.StructLayoutAttribute
    TypeInitializer: System.Reflection.ConstructorInfo;
    TypeHandle: System.RuntimeTypeHandle;
    GUID: System.Guid;
    BaseType: System.Type;
    static DefaultBinder: System.Reflection.Binder;
    IsInterface: boolean;
    Name: string;
    CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
    MetadataToken: number;
    static Delimiter: System.Char;
    static EmptyTypes: System.Type[];
    static Missing: any; // System.Object
    static FilterAttribute: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean);
    static FilterName: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean);
    static FilterNameIgnoreCase: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean);
    IsEnumDefined(value: any): boolean;
    GetEnumName(value: any): string;
    GetEnumNames(): string[];
    FindInterfaces(filter: ((m: System.Type, filterCriteria: any) => boolean), filterCriteria: any): System.Type[];
    FindMembers(memberType: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags, filter: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean), filterCriteria: any): System.Reflection.MemberInfo[];
    IsSubclassOf(c: System.Type): boolean;
    IsAssignableFrom(c: System.Type): boolean;
    GetType(): System.Type;
    GetElementType(): System.Type;
    GetArrayRank(): number;
    GetGenericTypeDefinition(): System.Type;
    GetGenericArguments(): System.Type[];
    GetGenericParameterConstraints(): System.Type[];
    GetConstructor(types: System.Type[]): System.Reflection.ConstructorInfo;
    GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
    GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
    GetConstructors(): System.Reflection.ConstructorInfo[];
    GetConstructors(bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];
    GetEvent(name: string): System.Reflection.EventInfo;
    GetEvent(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo;
    GetEvents(): System.Reflection.EventInfo[];
    GetEvents(bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];
    GetField(name: string): System.Reflection.FieldInfo;
    GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
    GetFields(): System.Reflection.FieldInfo[];
    GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
    GetMember(name: string): System.Reflection.MemberInfo[];
    GetMember(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
    GetMember(name: string, type: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
    GetMembers(): System.Reflection.MemberInfo[];
    GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
    GetMethod(name: string): System.Reflection.MethodInfo;
    GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo;
    GetMethod(name: string, types: System.Type[]): System.Reflection.MethodInfo;
    GetMethod(name: string, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
    GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
    GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
    GetMethod(name: string, genericParameterCount: number, types: System.Type[]): System.Reflection.MethodInfo;
    GetMethod(name: string, genericParameterCount: number, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
    GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
    GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
    GetMethods(): System.Reflection.MethodInfo[];
    GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
    GetNestedType(name: string): System.Type;
    GetNestedType(name: string, bindingAttr: System.Reflection.BindingFlags): System.Type;
    GetNestedTypes(): System.Type[];
    GetNestedTypes(bindingAttr: System.Reflection.BindingFlags): System.Type[];
    GetProperty(name: string): System.Reflection.PropertyInfo;
    GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo;
    GetProperty(name: string, returnType: System.Type): System.Reflection.PropertyInfo;
    GetProperty(name: string, types: System.Type[]): System.Reflection.PropertyInfo;
    GetProperty(name: string, returnType: System.Type, types: System.Type[]): System.Reflection.PropertyInfo;
    GetProperty(name: string, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
    GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
    GetProperties(): System.Reflection.PropertyInfo[];
    GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];
    GetDefaultMembers(): System.Reflection.MemberInfo[];
    static GetTypeHandle(o: any): System.RuntimeTypeHandle;
    static GetTypeArray(args: any[]): System.Type[];
    static GetTypeCode(type: System.Type): System.TypeCode;
    static GetTypeFromCLSID(clsid: System.Guid): System.Type;
    static GetTypeFromCLSID(clsid: System.Guid, throwOnError: boolean): System.Type;
    static GetTypeFromCLSID(clsid: System.Guid, server: string): System.Type;
    static GetTypeFromProgID(progID: string): System.Type;
    static GetTypeFromProgID(progID: string, throwOnError: boolean): System.Type;
    static GetTypeFromProgID(progID: string, server: string): System.Type;
    InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[]): any;
    InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], culture: System.Globalization.CultureInfo): any;
    InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], modifiers: System.Reflection.ParameterModifier[], culture: System.Globalization.CultureInfo, namedParameters: string[]): any;
    GetInterface(name: string): System.Type;
    GetInterface(name: string, ignoreCase: boolean): System.Type;
    GetInterfaces(): System.Type[];
    GetInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;
    IsInstanceOfType(o: any): boolean;
    IsEquivalentTo(other: System.Type): boolean;
    GetEnumUnderlyingType(): System.Type;
    GetEnumValues(): System.Array;
    MakeArrayType(): System.Type;
    MakeArrayType(rank: number): System.Type;
    MakeByRefType(): System.Type;
    MakeGenericType(...typeArguments: System.Type[]): System.Type;
    MakePointerType(): System.Type;
    static MakeGenericSignatureType(genericTypeDefinition: System.Type, ...typeArguments: System.Type[]): System.Type;
    static MakeGenericMethodParameter(position: number): System.Type;
    ToString(): string;
    Equals(o: any): boolean;
    GetHashCode(): number;
    Equals(o: System.Type): boolean;
    static GetTypeFromHandle(handle: System.RuntimeTypeHandle): System.Type;
    static GetType(typeName: string, throwOnError: boolean, ignoreCase: boolean): System.Type;
    static GetType(typeName: string, throwOnError: boolean): System.Type;
    static GetType(typeName: string): System.Type;
    static GetType(typeName: string, assemblyResolver: ((arg: System.Reflection.AssemblyName) => System.Reflection.Assembly), typeResolver: ((arg1: System.Reflection.Assembly, arg2: string, arg3: boolean) => System.Type)): System.Type;
    static GetType(typeName: string, assemblyResolver: ((arg: System.Reflection.AssemblyName) => System.Reflection.Assembly), typeResolver: ((arg1: System.Reflection.Assembly, arg2: string, arg3: boolean) => System.Type), throwOnError: boolean): System.Type;
    static GetType(typeName: string, assemblyResolver: ((arg: System.Reflection.AssemblyName) => System.Reflection.Assembly), typeResolver: ((arg1: System.Reflection.Assembly, arg2: string, arg3: boolean) => System.Type), throwOnError: boolean, ignoreCase: boolean): System.Type;
    static ReflectionOnlyGetType(typeName: string, throwIfNotFound: boolean, ignoreCase: boolean): System.Type;
    static GetTypeFromCLSID(clsid: System.Guid, server: string, throwOnError: boolean): System.Type;
    static GetTypeFromProgID(progID: string, server: string, throwOnError: boolean): System.Type;
    HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
    IsDefined(attributeType: System.Type, inherit: boolean): boolean;
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
    GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
    GetType(): System.Type;
  }
  export class TypeAccessException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    TypeName: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export enum TypeCode {
    Empty = 0,
    Object = 1,
    DBNull = 2,
    Boolean = 3,
    Char = 4,
    SByte = 5,
    Byte = 6,
    Int16 = 7,
    UInt16 = 8,
    Int32 = 9,
    UInt32 = 10,
    Int64 = 11,
    UInt64 = 12,
    Single = 13,
    Double = 14,
    Decimal = 15,
    DateTime = 16,
    String = 18,
  }
  export class TypeInitializationException {
    constructor(fullTypeName: string, innerException: System.Exception);
    TypeName: string;
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class TypeUnloadedException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class UInt16 {
    static MaxValue: number;
    static MinValue: number;
    CompareTo(value: any): number;
    CompareTo(value: number): number;
    Equals(obj: any): boolean;
    Equals(obj: number): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): number;
    static Parse(s: string, style: System.Globalization.NumberStyles): number;
    static Parse(s: string, provider: System.IFormatProvider): number;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): number;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): number;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class UInt32 {
    static MaxValue: number;
    static MinValue: number;
    CompareTo(value: any): number;
    CompareTo(value: number): number;
    Equals(obj: any): boolean;
    Equals(obj: number): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): number;
    static Parse(s: string, style: System.Globalization.NumberStyles): number;
    static Parse(s: string, provider: System.IFormatProvider): number;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): number;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): number;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class UInt64 {
    static MaxValue: number;
    static MinValue: number;
    CompareTo(value: any): number;
    CompareTo(value: number): number;
    Equals(obj: any): boolean;
    Equals(obj: number): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): number;
    static Parse(s: string, style: System.Globalization.NumberStyles): number;
    static Parse(s: string, provider: System.IFormatProvider): number;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): number;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): number;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class UnauthorizedAccessException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class UnhandledExceptionEventArgs {
    constructor(exception: any, isTerminating: boolean);
    ExceptionObject: any; // System.Object
    IsTerminating: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class UnhandledExceptionEventHandler {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(sender: any, e: System.UnhandledExceptionEventArgs): void;
    BeginInvoke(sender: any, e: System.UnhandledExceptionEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): void;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class ValueTuple<T1 = any, T2 = any, T3 = any, T4 = any, T5 = any, T6 = any, T7 = any, TRest = any> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, rest: TRest);
    Item1: T1;
    Item2: T2;
    Item3: T3;
    Item4: T4;
    Item5: T5;
    Item6: T6;
    Item7: T7;
    Rest: TRest;
    Equals(obj: any): boolean;
    Equals(other: System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>): boolean;
    CompareTo(other: System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>): number;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class Version {
    constructor(major: number, minor: number, build: number, revision: number);
    constructor(major: number, minor: number, build: number);
    constructor(major: number, minor: number);
    constructor(version: string);
    constructor();
    Major: number;
    Minor: number;
    Build: number;
    Revision: number;
    MajorRevision: number;
    MinorRevision: number;
    Clone(): any;
    CompareTo(version: any): number;
    CompareTo(value: System.Version): number;
    Equals(obj: any): boolean;
    Equals(obj: System.Version): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(fieldCount: number): string;
    static Parse(input: string): System.Version;
    static Parse(input: any): System.Version;
    GetType(): System.Type;
  }
  export class Void {
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export interface IServiceProvider {
    GetService(serviceType: System.Type): any;
  }
  export class ConsoleCancelEventHandler {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(sender: any, e: System.ConsoleCancelEventArgs): void;
    BeginInvoke(sender: any, e: System.ConsoleCancelEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): void;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class ConsoleCancelEventArgs {
    Cancel: boolean;
    SpecialKey: System.ConsoleSpecialKey;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export enum ConsoleColor {
    Black = 0,
    DarkBlue = 1,
    DarkGreen = 2,
    DarkCyan = 3,
    DarkRed = 4,
    DarkMagenta = 5,
    DarkYellow = 6,
    Gray = 7,
    DarkGray = 8,
    Blue = 9,
    Green = 10,
    Cyan = 11,
    Red = 12,
    Magenta = 13,
    Yellow = 14,
    White = 15,
  }
  export enum ConsoleKey {
    Backspace = 8,
    Tab = 9,
    Clear = 12,
    Enter = 13,
    Pause = 19,
    Escape = 27,
    Spacebar = 32,
    PageUp = 33,
    PageDown = 34,
    End = 35,
    Home = 36,
    LeftArrow = 37,
    UpArrow = 38,
    RightArrow = 39,
    DownArrow = 40,
    Select = 41,
    Print = 42,
    Execute = 43,
    PrintScreen = 44,
    Insert = 45,
    Delete = 46,
    Help = 47,
    D0 = 48,
    D1 = 49,
    D2 = 50,
    D3 = 51,
    D4 = 52,
    D5 = 53,
    D6 = 54,
    D7 = 55,
    D8 = 56,
    D9 = 57,
    A = 65,
    B = 66,
    C = 67,
    D = 68,
    E = 69,
    F = 70,
    G = 71,
    H = 72,
    I = 73,
    J = 74,
    K = 75,
    L = 76,
    M = 77,
    N = 78,
    O = 79,
    P = 80,
    Q = 81,
    R = 82,
    S = 83,
    T = 84,
    U = 85,
    V = 86,
    W = 87,
    X = 88,
    Y = 89,
    Z = 90,
    LeftWindows = 91,
    RightWindows = 92,
    Applications = 93,
    Sleep = 95,
    NumPad0 = 96,
    NumPad1 = 97,
    NumPad2 = 98,
    NumPad3 = 99,
    NumPad4 = 100,
    NumPad5 = 101,
    NumPad6 = 102,
    NumPad7 = 103,
    NumPad8 = 104,
    NumPad9 = 105,
    Multiply = 106,
    Add = 107,
    Separator = 108,
    Subtract = 109,
    Decimal = 110,
    Divide = 111,
    F1 = 112,
    F2 = 113,
    F3 = 114,
    F4 = 115,
    F5 = 116,
    F6 = 117,
    F7 = 118,
    F8 = 119,
    F9 = 120,
    F10 = 121,
    F11 = 122,
    F12 = 123,
    F13 = 124,
    F14 = 125,
    F15 = 126,
    F16 = 127,
    F17 = 128,
    F18 = 129,
    F19 = 130,
    F20 = 131,
    F21 = 132,
    F22 = 133,
    F23 = 134,
    F24 = 135,
    BrowserBack = 166,
    BrowserForward = 167,
    BrowserRefresh = 168,
    BrowserStop = 169,
    BrowserSearch = 170,
    BrowserFavorites = 171,
    BrowserHome = 172,
    VolumeMute = 173,
    VolumeDown = 174,
    VolumeUp = 175,
    MediaNext = 176,
    MediaPrevious = 177,
    MediaStop = 178,
    MediaPlay = 179,
    LaunchMail = 180,
    LaunchMediaSelect = 181,
    LaunchApp1 = 182,
    LaunchApp2 = 183,
    Oem1 = 186,
    OemPlus = 187,
    OemComma = 188,
    OemMinus = 189,
    OemPeriod = 190,
    Oem2 = 191,
    Oem3 = 192,
    Oem4 = 219,
    Oem5 = 220,
    Oem6 = 221,
    Oem7 = 222,
    Oem8 = 223,
    Oem102 = 226,
    Process = 229,
    Packet = 231,
    Attention = 246,
    CrSel = 247,
    ExSel = 248,
    EraseEndOfFile = 249,
    Play = 250,
    Zoom = 251,
    NoName = 252,
    Pa1 = 253,
    OemClear = 254,
  }
  export class ConsoleKeyInfo {
    constructor(keyChar: System.Char, key: System.ConsoleKey, shift: boolean, alt: boolean, control: boolean);
    KeyChar: System.Char;
    Key: System.ConsoleKey;
    Modifiers: System.ConsoleModifiers;
    Equals(value: any): boolean;
    Equals(obj: System.ConsoleKeyInfo): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export enum ConsoleModifiers {
    Alt = 1,
    Shift = 2,
    Control = 4,
  }
  export enum ConsoleSpecialKey {
    ControlC = 0,
    ControlBreak = 1,
  }
  export class SequencePosition {
    constructor(object: any, integer: number);
    GetObject(): any;
    GetInteger(): number;
    Equals(other: System.SequencePosition): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class AppDomainUnloadedException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ApplicationId {
    constructor(publicKeyToken: Byte[], name: string, version: System.Version, processorArchitecture: string, culture: string);
    Culture: string;
    Name: string;
    ProcessorArchitecture: string;
    Version: System.Version;
    PublicKeyToken: Byte[];
    Copy(): System.ApplicationId;
    ToString(): string;
    Equals(o: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class CannotUnloadAppDomainException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export enum LoaderOptimization {
    DisallowBindings = 4,
    DomainMask = 3,
    MultiDomain = 2,
    MultiDomainHost = 3,
    NotSpecified = 0,
    SingleDomain = 1,
  }
  export class OperatingSystem {
    constructor(platform: System.PlatformID, version: System.Version);
    Platform: System.PlatformID;
    ServicePack: string;
    Version: System.Version;
    VersionString: string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Clone(): any;
    ToString(): string;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class InsufficientMemoryException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class MissingFieldException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    constructor(className: string, fieldName: string);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class MissingMemberException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    constructor(className: string, memberName: string);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class OutOfMemoryException {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Array {
    LongLength: number;
    IsFixedSize: boolean;
    IsReadOnly: boolean;
    IsSynchronized: boolean;
    SyncRoot: any; // System.Object
    Length: number;
    Rank: number;
    static CreateInstance(elementType: System.Type, ...lengths: number[]): System.Array;
    CopyTo(array: System.Array, index: number): void;
    Clone(): any;
    static BinarySearch(array: System.Array, value: any): number;
    static Copy(sourceArray: System.Array, destinationArray: System.Array, length: number): void;
    static Copy(sourceArray: System.Array, sourceIndex: number, destinationArray: System.Array, destinationIndex: number, length: number): void;
    CopyTo(array: System.Array, index: number): void;
    GetLongLength(dimension: number): number;
    GetValue(index: number): any;
    GetValue(index1: number, index2: number): any;
    GetValue(index1: number, index2: number, index3: number): any;
    GetValue(...indices: number[]): any;
    static BinarySearch(array: System.Array, index: number, length: number, value: any): number;
    static BinarySearch(array: System.Array, value: any, comparer: System.Collections.IComparer): number;
    static BinarySearch(array: System.Array, index: number, length: number, value: any, comparer: System.Collections.IComparer): number;
    static IndexOf(array: System.Array, value: any): number;
    static IndexOf(array: System.Array, value: any, startIndex: number): number;
    static IndexOf(array: System.Array, value: any, startIndex: number, count: number): number;
    static LastIndexOf(array: System.Array, value: any): number;
    static LastIndexOf(array: System.Array, value: any, startIndex: number): number;
    static LastIndexOf(array: System.Array, value: any, startIndex: number, count: number): number;
    static Reverse(array: System.Array): void;
    static Reverse(array: System.Array, index: number, length: number): void;
    SetValue(value: any, index: number): void;
    SetValue(value: any, index1: number, index2: number): void;
    SetValue(value: any, index1: number, index2: number, index3: number): void;
    SetValue(value: any, ...indices: number[]): void;
    static Sort(array: System.Array): void;
    static Sort(array: System.Array, index: number, length: number): void;
    static Sort(array: System.Array, comparer: System.Collections.IComparer): void;
    static Sort(array: System.Array, index: number, length: number, comparer: System.Collections.IComparer): void;
    static Sort(keys: System.Array, items: System.Array): void;
    static Sort(keys: System.Array, items: System.Array, comparer: System.Collections.IComparer): void;
    static Sort(keys: System.Array, items: System.Array, index: number, length: number): void;
    static Sort(keys: System.Array, items: System.Array, index: number, length: number, comparer: System.Collections.IComparer): void;
    GetEnumerator(): System.Collections.IEnumerator;
    GetLength(dimension: number): number;
    GetLowerBound(dimension: number): number;
    GetValue(...indices: number[]): any;
    SetValue(value: any, ...indices: number[]): void;
    GetUpperBound(dimension: number): number;
    GetValue(index: number): any;
    GetValue(index1: number, index2: number): any;
    GetValue(index1: number, index2: number, index3: number): any;
    SetValue(value: any, index: number): void;
    SetValue(value: any, index1: number, index2: number): void;
    SetValue(value: any, index1: number, index2: number, index3: number): void;
    static CreateInstance(elementType: System.Type, length: number): System.Array;
    static CreateInstance(elementType: System.Type, length1: number, length2: number): System.Array;
    static CreateInstance(elementType: System.Type, length1: number, length2: number, length3: number): System.Array;
    static CreateInstance(elementType: System.Type, ...lengths: number[]): System.Array;
    static CreateInstance(elementType: System.Type, lengths: number[], lowerBounds: number[]): System.Array;
    static Clear(array: System.Array, index: number, length: number): void;
    static Copy(sourceArray: System.Array, destinationArray: System.Array, length: number): void;
    static Copy(sourceArray: System.Array, sourceIndex: number, destinationArray: System.Array, destinationIndex: number, length: number): void;
    static ConstrainedCopy(sourceArray: System.Array, sourceIndex: number, destinationArray: System.Array, destinationIndex: number, length: number): void;
    Initialize(): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class AppContext {
    static BaseDirectory: string;
    static TargetFrameworkName: string;
    static GetData(name: string): any;
    static SetSwitch(switchName: string, isEnabled: boolean): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class LocalDataStoreSlot {
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Activator {
    static CreateInstance(type: System.Type, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo): any;
    static CreateInstance(type: System.Type, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): any;
    static CreateInstance(type: System.Type, ...args: any[]): any;
    static CreateInstance(type: System.Type, args: any[], activationAttributes: any[]): any;
    static CreateInstance(type: System.Type): any;
    static CreateInstance(assemblyName: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    static CreateInstance(assemblyName: string, typeName: string, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    static CreateInstance(type: System.Type, nonPublic: boolean): any;
    static CreateInstanceFrom(assemblyFile: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    static CreateInstanceFrom(assemblyFile: string, typeName: string, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    static CreateInstance(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityInfo: System.Security.Policy.Evidence): System.Runtime.Remoting.ObjectHandle;
    static CreateInstance(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    static CreateInstanceFrom(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityInfo: System.Security.Policy.Evidence): System.Runtime.Remoting.ObjectHandle;
    static CreateInstanceFrom(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    static CreateInstance(domain: System.AppDomain, assemblyName: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    static CreateInstance(domain: System.AppDomain, assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityAttributes: System.Security.Policy.Evidence): System.Runtime.Remoting.ObjectHandle;
    static CreateInstance(domain: System.AppDomain, assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    static CreateInstanceFrom(domain: System.AppDomain, assemblyFile: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    static CreateInstanceFrom(domain: System.AppDomain, assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityAttributes: System.Security.Policy.Evidence): System.Runtime.Remoting.ObjectHandle;
    static CreateInstanceFrom(domain: System.AppDomain, assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    static CreateComInstanceFrom(assemblyName: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    static CreateComInstanceFrom(assemblyName: string, typeName: string, hashValue: Byte[], hashAlgorithm: any): System.Runtime.Remoting.ObjectHandle;
    static GetObject(type: System.Type, url: string): any;
    static GetObject(type: System.Type, url: string, state: any): any;
    static CreateInstance(activationContext: System.ActivationContext): System.Runtime.Remoting.ObjectHandle;
    static CreateInstance(activationContext: System.ActivationContext, activationCustomData: string[]): System.Runtime.Remoting.ObjectHandle;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Buffer {
    static ByteLength(array: System.Array): number;
    static GetByte(array: System.Array, index: number): Byte;
    static SetByte(array: System.Array, index: number, value: Byte): void;
    static BlockCopy(src: System.Array, srcOffset: number, dst: System.Array, dstOffset: number, count: number): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class ContextBoundObject {
    CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
    GetLifetimeService(): any;
    InitializeLifetimeService(): any;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class ContextMarshalException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Enum {
    static Parse(enumType: System.Type, value: string): any;
    static Parse(enumType: System.Type, value: string, ignoreCase: boolean): any;
    static GetUnderlyingType(enumType: System.Type): System.Type;
    static GetValues(enumType: System.Type): System.Array;
    static GetName(enumType: System.Type, value: any): string;
    static GetNames(enumType: System.Type): string[];
    static ToObject(enumType: System.Type, value: any): any;
    static IsDefined(enumType: System.Type, value: any): boolean;
    static Format(enumType: System.Type, value: any, format: string): string;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    CompareTo(target: any): number;
    ToString(format: string): string;
    ToString(provider: System.IFormatProvider): string;
    HasFlag(flag: System.Enum): boolean;
    GetTypeCode(): System.TypeCode;
    static ToObject(enumType: System.Type, value: System.SByte): any;
    static ToObject(enumType: System.Type, value: number): any;
    static ToObject(enumType: System.Type, value: number): any;
    static ToObject(enumType: System.Type, value: Byte): any;
    static ToObject(enumType: System.Type, value: number): any;
    static ToObject(enumType: System.Type, value: number): any;
    static ToObject(enumType: System.Type, value: number): any;
    static ToObject(enumType: System.Type, value: number): any;
    GetType(): System.Type;
  }
  export class Exception {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export enum GCCollectionMode {
    Default = 0,
    Forced = 1,
    Optimized = 2,
  }
  export enum GCNotificationStatus {
    Succeeded = 0,
    Failed = 1,
    Canceled = 2,
    Timeout = 3,
    NotApplicable = 4,
  }
  export class GC {
    static MaxGeneration: number;
    static GetAllocatedBytesForCurrentThread(): number;
    static AddMemoryPressure(bytesAllocated: number): void;
    static RemoveMemoryPressure(bytesAllocated: number): void;
    static GetGeneration(obj: any): number;
    static Collect(generation: number): void;
    static Collect(): void;
    static Collect(generation: number, mode: System.GCCollectionMode): void;
    static Collect(generation: number, mode: System.GCCollectionMode, blocking: boolean): void;
    static Collect(generation: number, mode: System.GCCollectionMode, blocking: boolean, compacting: boolean): void;
    static CollectionCount(generation: number): number;
    static KeepAlive(obj: any): void;
    static GetGeneration(wo: System.WeakReference): number;
    static WaitForPendingFinalizers(): void;
    static SuppressFinalize(obj: any): void;
    static ReRegisterForFinalize(obj: any): void;
    static GetTotalMemory(forceFullCollection: boolean): number;
    static RegisterForFullGCNotification(maxGenerationThreshold: number, largeObjectHeapThreshold: number): void;
    static CancelFullGCNotification(): void;
    static WaitForFullGCApproach(): System.GCNotificationStatus;
    static WaitForFullGCApproach(millisecondsTimeout: number): System.GCNotificationStatus;
    static WaitForFullGCComplete(): System.GCNotificationStatus;
    static WaitForFullGCComplete(millisecondsTimeout: number): System.GCNotificationStatus;
    static TryStartNoGCRegion(totalSize: number): boolean;
    static TryStartNoGCRegion(totalSize: number, lohSize: number): boolean;
    static TryStartNoGCRegion(totalSize: number, disallowFullBlockingGC: boolean): boolean;
    static TryStartNoGCRegion(totalSize: number, lohSize: number, disallowFullBlockingGC: boolean): boolean;
    static EndNoGCRegion(): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export interface _AppDomain {
    FriendlyName: string;
    BaseDirectory: string;
    RelativeSearchPath: string;
    ShadowCopyFiles: boolean;
    DynamicDirectory: string;
    Evidence: System.Security.Policy.Evidence;
    GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
    ToString(): string;
    Equals(other: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    InitializeLifetimeService(): any;
    GetLifetimeService(): any;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, evidence: System.Security.Policy.Evidence): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, evidence: System.Security.Policy.Evidence): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, evidence: System.Security.Policy.Evidence, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, evidence: System.Security.Policy.Evidence, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, evidence: System.Security.Policy.Evidence, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet, isSynchronized: boolean): System.Reflection.Emit.AssemblyBuilder;
    CreateInstance(assemblyName: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    CreateInstanceFrom(assemblyFile: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    CreateInstance(assemblyName: string, typeName: string, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    CreateInstanceFrom(assemblyFile: string, typeName: string, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    CreateInstance(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityAttributes: System.Security.Policy.Evidence): System.Runtime.Remoting.ObjectHandle;
    CreateInstanceFrom(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityAttributes: System.Security.Policy.Evidence): System.Runtime.Remoting.ObjectHandle;
    Load(assemblyRef: System.Reflection.AssemblyName): System.Reflection.Assembly;
    Load(assemblyString: string): System.Reflection.Assembly;
    Load(rawAssembly: Byte[]): System.Reflection.Assembly;
    Load(rawAssembly: Byte[], rawSymbolStore: Byte[]): System.Reflection.Assembly;
    Load(rawAssembly: Byte[], rawSymbolStore: Byte[], securityEvidence: System.Security.Policy.Evidence): System.Reflection.Assembly;
    Load(assemblyRef: System.Reflection.AssemblyName, assemblySecurity: System.Security.Policy.Evidence): System.Reflection.Assembly;
    Load(assemblyString: string, assemblySecurity: System.Security.Policy.Evidence): System.Reflection.Assembly;
    ExecuteAssembly(assemblyFile: string, assemblySecurity: System.Security.Policy.Evidence): number;
    ExecuteAssembly(assemblyFile: string): number;
    ExecuteAssembly(assemblyFile: string, assemblySecurity: System.Security.Policy.Evidence, args: string[]): number;
    GetAssemblies(): System.Reflection.Assembly[];
    AppendPrivatePath(path: string): void;
    ClearPrivatePath(): void;
    SetShadowCopyPath(s: string): void;
    ClearShadowCopyPath(): void;
    SetCachePath(s: string): void;
    SetData(name: string, data: any): void;
    GetData(name: string): any;
    DoCallBack(theDelegate: (() => void)): void;
    SetAppDomainPolicy(domainPolicy: System.Security.Policy.PolicyLevel): void;
    SetPrincipalPolicy(policy: System.Security.Principal.PrincipalPolicy): void;
    SetThreadPrincipal(principal: System.Security.Principal.IPrincipal): void;
  }
  export interface IAppDomainSetup {
    ApplicationBase: string;
    ApplicationName: string;
    CachePath: string;
    ConfigurationFile: string;
    DynamicBase: string;
    LicenseFile: string;
    PrivateBinPath: string;
    PrivateBinPathProbe: string;
    ShadowCopyDirectories: string;
    ShadowCopyFiles: string;
  }
  export class TypedReference {
    static MakeTypedReference(target: any, flds: System.Reflection.FieldInfo[]): System.TypedReference;
    GetHashCode(): number;
    Equals(o: any): boolean;
    static ToObject(value: System.TypedReference): any;
    static GetTargetType(value: System.TypedReference): System.Type;
    static TargetTypeToken(value: System.TypedReference): System.RuntimeTypeHandle;
    static SetTypedReference(target: System.TypedReference, value: any): void;
    ToString(): string;
    GetType(): System.Type;
  }
  export class TypeLoadException {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: System.Exception);
    Message: string;
    TypeName: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class AppDomain {
    SetupInformation: System.AppDomainSetup;
    ApplicationTrust: System.Security.Policy.ApplicationTrust;
    BaseDirectory: string;
    RelativeSearchPath: string;
    DynamicDirectory: string;
    ShadowCopyFiles: boolean;
    FriendlyName: string;
    Evidence: System.Security.Policy.Evidence;
    PermissionSet: System.Security.PermissionSet;
    static CurrentDomain: System.AppDomain;
    IsHomogenous: boolean;
    IsFullyTrusted: boolean;
    DomainManager: System.AppDomainManager;
    ActivationContext: System.ActivationContext;
    ApplicationIdentity: System.ApplicationIdentity;
    Id: number;
    static MonitoringIsEnabled: boolean;
    MonitoringSurvivedMemorySize: number;
    static MonitoringSurvivedProcessMemorySize: number;
    MonitoringTotalAllocatedMemorySize: number;
    MonitoringTotalProcessorTime: System.TimeSpan;
    AppendPrivatePath(path: string): void;
    ClearPrivatePath(): void;
    ClearShadowCopyPath(): void;
    CreateComInstanceFrom(assemblyName: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    CreateComInstanceFrom(assemblyFile: string, typeName: string, hashValue: Byte[], hashAlgorithm: any): System.Runtime.Remoting.ObjectHandle;
    CreateInstance(assemblyName: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    CreateInstance(assemblyName: string, typeName: string, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    CreateInstance(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityAttributes: System.Security.Policy.Evidence): System.Runtime.Remoting.ObjectHandle;
    CreateInstanceAndUnwrap(assemblyName: string, typeName: string): any;
    CreateInstanceAndUnwrap(assemblyName: string, typeName: string, activationAttributes: any[]): any;
    CreateInstanceAndUnwrap(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityAttributes: System.Security.Policy.Evidence): any;
    CreateInstance(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    CreateInstanceAndUnwrap(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): any;
    CreateInstanceFrom(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    CreateInstanceFromAndUnwrap(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): any;
    CreateInstanceFrom(assemblyFile: string, typeName: string): System.Runtime.Remoting.ObjectHandle;
    CreateInstanceFrom(assemblyFile: string, typeName: string, activationAttributes: any[]): System.Runtime.Remoting.ObjectHandle;
    CreateInstanceFrom(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityAttributes: System.Security.Policy.Evidence): System.Runtime.Remoting.ObjectHandle;
    CreateInstanceFromAndUnwrap(assemblyName: string, typeName: string): any;
    CreateInstanceFromAndUnwrap(assemblyName: string, typeName: string, activationAttributes: any[]): any;
    CreateInstanceFromAndUnwrap(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[], securityAttributes: System.Security.Policy.Evidence): any;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, evidence: System.Security.Policy.Evidence): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, evidence: System.Security.Policy.Evidence): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, evidence: System.Security.Policy.Evidence, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, evidence: System.Security.Policy.Evidence, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, evidence: System.Security.Policy.Evidence, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet, isSynchronized: boolean): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, evidence: System.Security.Policy.Evidence, requiredPermissions: System.Security.PermissionSet, optionalPermissions: System.Security.PermissionSet, refusedPermissions: System.Security.PermissionSet, isSynchronized: boolean, assemblyAttributes: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, assemblyAttributes: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, dir: string, isSynchronized: boolean, assemblyAttributes: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>): System.Reflection.Emit.AssemblyBuilder;
    DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, assemblyAttributes: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>, securityContextSource: System.Security.SecurityContextSource): System.Reflection.Emit.AssemblyBuilder;
    DoCallBack(callBackDelegate: (() => void)): void;
    ExecuteAssembly(assemblyFile: string): number;
    ExecuteAssembly(assemblyFile: string, assemblySecurity: System.Security.Policy.Evidence): number;
    ExecuteAssembly(assemblyFile: string, assemblySecurity: System.Security.Policy.Evidence, args: string[]): number;
    ExecuteAssembly(assemblyFile: string, assemblySecurity: System.Security.Policy.Evidence, args: string[], hashValue: Byte[], hashAlgorithm: any): number;
    ExecuteAssembly(assemblyFile: string, args: string[]): number;
    ExecuteAssembly(assemblyFile: string, args: string[], hashValue: Byte[], hashAlgorithm: any): number;
    GetAssemblies(): System.Reflection.Assembly[];
    GetData(name: string): any;
    GetType(): System.Type;
    InitializeLifetimeService(): any;
    Load(assemblyRef: System.Reflection.AssemblyName): System.Reflection.Assembly;
    Load(assemblyRef: System.Reflection.AssemblyName, assemblySecurity: System.Security.Policy.Evidence): System.Reflection.Assembly;
    Load(assemblyString: string): System.Reflection.Assembly;
    Load(assemblyString: string, assemblySecurity: System.Security.Policy.Evidence): System.Reflection.Assembly;
    Load(rawAssembly: Byte[]): System.Reflection.Assembly;
    Load(rawAssembly: Byte[], rawSymbolStore: Byte[]): System.Reflection.Assembly;
    Load(rawAssembly: Byte[], rawSymbolStore: Byte[], securityEvidence: System.Security.Policy.Evidence): System.Reflection.Assembly;
    SetAppDomainPolicy(domainPolicy: System.Security.Policy.PolicyLevel): void;
    SetCachePath(path: string): void;
    SetPrincipalPolicy(policy: System.Security.Principal.PrincipalPolicy): void;
    SetShadowCopyFiles(): void;
    SetShadowCopyPath(path: string): void;
    SetThreadPrincipal(principal: System.Security.Principal.IPrincipal): void;
    static CreateDomain(friendlyName: string): System.AppDomain;
    static CreateDomain(friendlyName: string, securityInfo: System.Security.Policy.Evidence): System.AppDomain;
    static CreateDomain(friendlyName: string, securityInfo: System.Security.Policy.Evidence, info: System.AppDomainSetup): System.AppDomain;
    static CreateDomain(friendlyName: string, securityInfo: System.Security.Policy.Evidence, appBasePath: string, appRelativeSearchPath: string, shadowCopyFiles: boolean): System.AppDomain;
    static CreateDomain(friendlyName: string, securityInfo: System.Security.Policy.Evidence, info: System.AppDomainSetup, grantSet: System.Security.PermissionSet, ...fullTrustAssemblies: System.Security.Policy.StrongName[]): System.AppDomain;
    IsFinalizingForUnload(): boolean;
    static Unload(domain: System.AppDomain): void;
    SetData(name: string, data: any): void;
    SetData(name: string, data: any, permission: System.Security.IPermission): void;
    SetDynamicBase(path: string): void;
    static GetCurrentThreadId(): number;
    ToString(): string;
    ApplyPolicy(assemblyName: string): string;
    static CreateDomain(friendlyName: string, securityInfo: System.Security.Policy.Evidence, appBasePath: string, appRelativeSearchPath: string, shadowCopyFiles: boolean, adInit: ((args: string[]) => void), adInitArgs: string[]): System.AppDomain;
    ExecuteAssemblyByName(assemblyName: string): number;
    ExecuteAssemblyByName(assemblyName: string, assemblySecurity: System.Security.Policy.Evidence): number;
    ExecuteAssemblyByName(assemblyName: string, assemblySecurity: System.Security.Policy.Evidence, ...args: string[]): number;
    ExecuteAssemblyByName(assemblyName: System.Reflection.AssemblyName, assemblySecurity: System.Security.Policy.Evidence, ...args: string[]): number;
    ExecuteAssemblyByName(assemblyName: string, ...args: string[]): number;
    ExecuteAssemblyByName(assemblyName: System.Reflection.AssemblyName, ...args: string[]): number;
    IsDefaultAppDomain(): boolean;
    ReflectionOnlyGetAssemblies(): System.Reflection.Assembly[];
    IsCompatibilitySwitchSet(value: string): boolean | undefined;
    CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
    GetLifetimeService(): any;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class Environment {
    static CommandLine: string;
    static CurrentDirectory: string;
    static CurrentManagedThreadId: number;
    static ExitCode: number;
    static HasShutdownStarted: boolean;
    static MachineName: string;
    static NewLine: string;
    static OSVersion: System.OperatingSystem;
    static StackTrace: string;
    static SystemDirectory: string;
    static TickCount: number;
    static UserDomainName: string;
    static UserInteractive: boolean;
    static UserName: string;
    static Version: System.Version;
    static WorkingSet: number;
    static Is64BitOperatingSystem: boolean;
    static SystemPageSize: number;
    static Is64BitProcess: boolean;
    static ProcessorCount: number;
    static Exit(exitCode: number): void;
    static ExpandEnvironmentVariables(name: string): string;
    static GetCommandLineArgs(): string[];
    static GetEnvironmentVariable(variable: string): string;
    static GetEnvironmentVariables(): System.Collections.IDictionary;
    static GetFolderPath(folder: System.Environment_SpecialFolder): string;
    static GetFolderPath(folder: System.Environment_SpecialFolder, option: System.Environment_SpecialFolderOption): string;
    static GetLogicalDrives(): string[];
    static GetEnvironmentVariable(variable: string, target: System.EnvironmentVariableTarget): string;
    static GetEnvironmentVariables(target: System.EnvironmentVariableTarget): System.Collections.IDictionary;
    static SetEnvironmentVariable(variable: string, value: string): void;
    static SetEnvironmentVariable(variable: string, value: string, target: System.EnvironmentVariableTarget): void;
    static FailFast(message: string): void;
    static FailFast(message: string, exception: System.Exception): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export enum Environment_SpecialFolder {
    MyDocuments = 5,
    Desktop = 0,
    MyComputer = 17,
    Programs = 2,
    Personal = 5,
    Favorites = 6,
    Startup = 7,
    Recent = 8,
    SendTo = 9,
    StartMenu = 11,
    MyMusic = 13,
    DesktopDirectory = 16,
    Templates = 21,
    ApplicationData = 26,
    LocalApplicationData = 28,
    InternetCache = 32,
    Cookies = 33,
    History = 34,
    CommonApplicationData = 35,
    System = 37,
    ProgramFiles = 38,
    MyPictures = 39,
    CommonProgramFiles = 43,
    MyVideos = 14,
    NetworkShortcuts = 19,
    Fonts = 20,
    CommonStartMenu = 22,
    CommonPrograms = 23,
    CommonStartup = 24,
    CommonDesktopDirectory = 25,
    PrinterShortcuts = 27,
    Windows = 36,
    UserProfile = 40,
    SystemX86 = 41,
    ProgramFilesX86 = 42,
    CommonProgramFilesX86 = 44,
    CommonTemplates = 45,
    CommonDocuments = 46,
    CommonAdminTools = 47,
    AdminTools = 48,
    CommonMusic = 53,
    CommonPictures = 54,
    CommonVideos = 55,
    Resources = 56,
    LocalizedResources = 57,
    CommonOemLinks = 58,
    CDBurning = 59,
  }
  export enum Environment_SpecialFolderOption {
    None = 0,
    DoNotVerify = 16384,
    Create = 32768,
  }
  export class ActivationContext {
    Form: System.ActivationContext_ContextForm;
    Identity: System.ApplicationIdentity;
    ApplicationManifestBytes: Byte[];
    DeploymentManifestBytes: Byte[];
    static CreatePartialActivationContext(identity: System.ApplicationIdentity): System.ActivationContext;
    static CreatePartialActivationContext(identity: System.ApplicationIdentity, manifestPaths: string[]): System.ActivationContext;
    Dispose(): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export enum ActivationContext_ContextForm {
    Loose = 0,
    StoreBounded = 1,
  }
  export class AppDomainInitializer {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(args: string[]): void;
    BeginInvoke(args: string[], callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): void;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class AppDomainManager {
    constructor();
    ApplicationActivator: System.Runtime.Hosting.ApplicationActivator;
    EntryAssembly: System.Reflection.Assembly;
    HostExecutionContextManager: System.Threading.HostExecutionContextManager;
    HostSecurityManager: System.Security.HostSecurityManager;
    InitializationFlags: System.AppDomainManagerInitializationOptions;
    CreateDomain(friendlyName: string, securityInfo: System.Security.Policy.Evidence, appDomainInfo: System.AppDomainSetup): System.AppDomain;
    InitializeNewDomain(appDomainInfo: System.AppDomainSetup): void;
    CheckSecuritySettings(state: System.Security.SecurityState): boolean;
    CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
    GetLifetimeService(): any;
    InitializeLifetimeService(): any;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class AppDomainSetup {
    constructor();
    constructor(activationArguments: System.Runtime.Hosting.ActivationArguments);
    constructor(activationContext: System.ActivationContext);
    ApplicationBase: string;
    ApplicationName: string;
    CachePath: string;
    ConfigurationFile: string;
    DisallowPublisherPolicy: boolean;
    DynamicBase: string;
    LicenseFile: string;
    LoaderOptimization: System.LoaderOptimization;
    AppDomainManagerAssembly: string;
    AppDomainManagerType: string;
    PartialTrustVisibleAssemblies: string[];
    PrivateBinPath: string;
    PrivateBinPathProbe: string;
    ShadowCopyDirectories: string;
    ShadowCopyFiles: string;
    DisallowBindingRedirects: boolean;
    DisallowCodeDownload: boolean;
    TargetFrameworkName: string;
    ActivationArguments: System.Runtime.Hosting.ActivationArguments;
    AppDomainInitializer: ((args: string[]) => void);
    AppDomainInitializerArguments: string[];
    ApplicationTrust: System.Security.Policy.ApplicationTrust;
    DisallowApplicationBaseProbing: boolean;
    SandboxInterop: boolean;
    GetConfigurationBytes(): Byte[];
    SetConfigurationBytes(value: Byte[]): void;
    SetCompatibilitySwitches(switches: System.Collections.Generic.IEnumerable<string>): void;
    SetNativeFunction(functionName: string, functionVersion: number, functionPointer: System.IntPtr): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class ApplicationIdentity {
    constructor(applicationIdentityFullName: string);
    CodeBase: string;
    FullName: string;
    ToString(): string;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export class ArgIterator {
    constructor(arglist: System.RuntimeArgumentHandle);
    End(): void;
    Equals(o: any): boolean;
    GetHashCode(): number;
    GetNextArg(): System.TypedReference;
    GetNextArg(rth: System.RuntimeTypeHandle): System.TypedReference;
    GetNextArgType(): System.RuntimeTypeHandle;
    GetRemainingCount(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class Console {
    static Error: System.IO.TextWriter;
    static Out: System.IO.TextWriter;
    static In: System.IO.TextReader;
    static InputEncoding: System.Text.Encoding;
    static OutputEncoding: System.Text.Encoding;
    static BackgroundColor: System.ConsoleColor;
    static BufferHeight: number;
    static BufferWidth: number;
    static CapsLock: boolean;
    static CursorLeft: number;
    static CursorTop: number;
    static CursorSize: number;
    static CursorVisible: boolean;
    static ForegroundColor: System.ConsoleColor;
    static KeyAvailable: boolean;
    static LargestWindowHeight: number;
    static LargestWindowWidth: number;
    static NumberLock: boolean;
    static Title: string;
    static TreatControlCAsInput: boolean;
    static WindowHeight: number;
    static WindowLeft: number;
    static WindowTop: number;
    static WindowWidth: number;
    static IsErrorRedirected: boolean;
    static IsOutputRedirected: boolean;
    static IsInputRedirected: boolean;
    static OpenStandardError(): System.IO.Stream;
    static OpenStandardError(bufferSize: number): System.IO.Stream;
    static OpenStandardInput(): System.IO.Stream;
    static OpenStandardInput(bufferSize: number): System.IO.Stream;
    static OpenStandardOutput(): System.IO.Stream;
    static OpenStandardOutput(bufferSize: number): System.IO.Stream;
    static SetError(newError: System.IO.TextWriter): void;
    static SetIn(newIn: System.IO.TextReader): void;
    static SetOut(newOut: System.IO.TextWriter): void;
    static Write(value: boolean): void;
    static Write(value: System.Char): void;
    static Write(buffer: System.Char[]): void;
    static Write(value: number): void;
    static Write(value: number): void;
    static Write(value: number): void;
    static Write(value: number): void;
    static Write(value: any): void;
    static Write(value: number): void;
    static Write(value: string): void;
    static Write(value: number): void;
    static Write(value: number): void;
    static Write(format: string, arg0: any): void;
    static Write(format: string, ...arg: any[]): void;
    static Write(buffer: System.Char[], index: number, count: number): void;
    static Write(format: string, arg0: any, arg1: any): void;
    static Write(format: string, arg0: any, arg1: any, arg2: any): void;
    static Write(format: string, arg0: any, arg1: any, arg2: any, arg3: any): void;
    static WriteLine(): void;
    static WriteLine(value: boolean): void;
    static WriteLine(value: System.Char): void;
    static WriteLine(buffer: System.Char[]): void;
    static WriteLine(value: number): void;
    static WriteLine(value: number): void;
    static WriteLine(value: number): void;
    static WriteLine(value: number): void;
    static WriteLine(value: any): void;
    static WriteLine(value: number): void;
    static WriteLine(value: string): void;
    static WriteLine(value: number): void;
    static WriteLine(value: number): void;
    static WriteLine(format: string, arg0: any): void;
    static WriteLine(format: string, ...arg: any[]): void;
    static WriteLine(buffer: System.Char[], index: number, count: number): void;
    static WriteLine(format: string, arg0: any, arg1: any): void;
    static WriteLine(format: string, arg0: any, arg1: any, arg2: any): void;
    static WriteLine(format: string, arg0: any, arg1: any, arg2: any, arg3: any): void;
    static Read(): number;
    static ReadLine(): string;
    static Beep(): void;
    static Beep(frequency: number, duration: number): void;
    static Clear(): void;
    static MoveBufferArea(sourceLeft: number, sourceTop: number, sourceWidth: number, sourceHeight: number, targetLeft: number, targetTop: number): void;
    static MoveBufferArea(sourceLeft: number, sourceTop: number, sourceWidth: number, sourceHeight: number, targetLeft: number, targetTop: number, sourceChar: System.Char, sourceForeColor: System.ConsoleColor, sourceBackColor: System.ConsoleColor): void;
    static ReadKey(): System.ConsoleKeyInfo;
    static ReadKey(intercept: boolean): System.ConsoleKeyInfo;
    static ResetColor(): void;
    static SetBufferSize(width: number, height: number): void;
    static SetCursorPosition(left: number, top: number): void;
    static SetWindowPosition(left: number, top: number): void;
    static SetWindowSize(width: number, height: number): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class CrossAppDomainDelegate {
    constructor(object: any, method: System.IntPtr);
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    Invoke(): void;
    BeginInvoke(callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
    EndInvoke(result: System.IAsyncResult): void;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Delegate {
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    static CreateDelegate(type: System.Type, firstArgument: any, method: System.Reflection.MethodInfo, throwOnBindFailure: boolean): System.Delegate;
    static CreateDelegate(type: System.Type, firstArgument: any, method: System.Reflection.MethodInfo): System.Delegate;
    static CreateDelegate(type: System.Type, method: System.Reflection.MethodInfo, throwOnBindFailure: boolean): System.Delegate;
    static CreateDelegate(type: System.Type, method: System.Reflection.MethodInfo): System.Delegate;
    static CreateDelegate(type: System.Type, target: any, method: string): System.Delegate;
    static CreateDelegate(type: System.Type, target: System.Type, method: string, ignoreCase: boolean, throwOnBindFailure: boolean): System.Delegate;
    static CreateDelegate(type: System.Type, target: System.Type, method: string): System.Delegate;
    static CreateDelegate(type: System.Type, target: System.Type, method: string, ignoreCase: boolean): System.Delegate;
    static CreateDelegate(type: System.Type, target: any, method: string, ignoreCase: boolean, throwOnBindFailure: boolean): System.Delegate;
    static CreateDelegate(type: System.Type, target: any, method: string, ignoreCase: boolean): System.Delegate;
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetInvocationList(): System.Delegate[];
    static Combine(a: System.Delegate, b: System.Delegate): System.Delegate;
    static Combine(...delegates: System.Delegate[]): System.Delegate;
    static Remove(source: System.Delegate, value: System.Delegate): System.Delegate;
    static RemoveAll(source: System.Delegate, value: System.Delegate): System.Delegate;
    GetType(): System.Type;
    ToString(): string;
  }
  export enum AppDomainManagerInitializationOptions {
    None = 0,
    RegisterWithHost = 1,
  }
  export enum EnvironmentVariableTarget {
    Process = 0,
    User = 1,
    Machine = 2,
  }
  export class IntPtr {
    constructor(value: number);
    constructor(value: number);
    static Size: number;
    static Zero: System.IntPtr;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToInt32(): number;
    ToInt64(): number;
    ToString(): string;
    ToString(format: string): string;
    static Add(pointer: System.IntPtr, offset: number): System.IntPtr;
    static Subtract(pointer: System.IntPtr, offset: number): System.IntPtr;
    GetType(): System.Type;
  }
  export class MarshalByRefObject {
    CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
    GetLifetimeService(): any;
    InitializeLifetimeService(): any;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class ModuleHandle {
    MDStreamVersion: number;
    static EmptyHandle: System.ModuleHandle;
    ResolveFieldHandle(fieldToken: number): System.RuntimeFieldHandle;
    ResolveMethodHandle(methodToken: number): System.RuntimeMethodHandle;
    ResolveTypeHandle(typeToken: number): System.RuntimeTypeHandle;
    ResolveTypeHandle(typeToken: number, typeInstantiationContext: System.RuntimeTypeHandle[], methodInstantiationContext: System.RuntimeTypeHandle[]): System.RuntimeTypeHandle;
    ResolveMethodHandle(methodToken: number, typeInstantiationContext: System.RuntimeTypeHandle[], methodInstantiationContext: System.RuntimeTypeHandle[]): System.RuntimeMethodHandle;
    ResolveFieldHandle(fieldToken: number, typeInstantiationContext: System.RuntimeTypeHandle[], methodInstantiationContext: System.RuntimeTypeHandle[]): System.RuntimeFieldHandle;
    GetRuntimeFieldHandleFromMetadataToken(fieldToken: number): System.RuntimeFieldHandle;
    GetRuntimeMethodHandleFromMetadataToken(methodToken: number): System.RuntimeMethodHandle;
    GetRuntimeTypeHandleFromMetadataToken(typeToken: number): System.RuntimeTypeHandle;
    Equals(obj: any): boolean;
    Equals(handle: System.ModuleHandle): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class MulticastDelegate {
    Method: System.Reflection.MethodInfo;
    Target: any; // System.Object
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetInvocationList(): System.Delegate[];
    DynamicInvoke(...args: any[]): any;
    Clone(): any;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Object {
    constructor();
    Equals(obj: any): boolean;
    static Equals(objA: any, objB: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
    static ReferenceEquals(objA: any, objB: any): boolean;
  }
  export enum PlatformID {
    Win32S = 0,
    Win32Windows = 1,
    Win32NT = 2,
    WinCE = 3,
    Unix = 4,
    Xbox = 5,
    MacOSX = 6,
  }
  export class RuntimeArgumentHandle {
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class RuntimeFieldHandle {
    Value: System.IntPtr;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    Equals(handle: System.RuntimeFieldHandle): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class RuntimeMethodHandle {
    Value: System.IntPtr;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetFunctionPointer(): System.IntPtr;
    Equals(obj: any): boolean;
    Equals(handle: System.RuntimeMethodHandle): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class RuntimeTypeHandle {
    Value: System.IntPtr;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    Equals(obj: any): boolean;
    Equals(handle: System.RuntimeTypeHandle): boolean;
    GetHashCode(): number;
    GetModuleHandle(): System.ModuleHandle;
    ToString(): string;
    GetType(): System.Type;
  }
  export class UIntPtr {
    constructor(value: number);
    constructor(value: number);
    static Size: number;
    static Zero: System.UIntPtr;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToUInt32(): number;
    ToUInt64(): number;
    ToString(): string;
    static Add(pointer: System.UIntPtr, offset: number): System.UIntPtr;
    static Subtract(pointer: System.UIntPtr, offset: number): System.UIntPtr;
    GetType(): System.Type;
  }
  export class ValueType {
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class WeakReference<T = any> {
    constructor(target: T);
    constructor(target: T, trackResurrection: boolean);
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    SetTarget(target: T): void;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Decimal {
    constructor(value: number);
    constructor(value: number);
    constructor(value: number);
    constructor(value: number);
    constructor(value: number);
    constructor(value: number);
    constructor(bits: number[]);
    constructor(lo: number, mid: number, hi: number, isNegative: boolean, scale: Byte);
    static Zero: number;
    static One: number;
    static MinusOne: number;
    static MaxValue: number;
    static MinValue: number;
    static FromOACurrency(cy: number): number;
    static ToOACurrency(value: number): number;
    static Add(d1: number, d2: number): number;
    static Ceiling(d: number): number;
    static Compare(d1: number, d2: number): number;
    CompareTo(value: any): number;
    CompareTo(value: number): number;
    static Divide(d1: number, d2: number): number;
    Equals(value: any): boolean;
    Equals(value: number): boolean;
    GetHashCode(): number;
    static Equals(d1: number, d2: number): boolean;
    static Floor(d: number): number;
    ToString(): string;
    ToString(format: string): string;
    ToString(provider: System.IFormatProvider): string;
    ToString(format: string, provider: System.IFormatProvider): string;
    static Parse(s: string): number;
    static Parse(s: string, style: System.Globalization.NumberStyles): number;
    static Parse(s: string, provider: System.IFormatProvider): number;
    static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider): number;
    static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider): number;
    static GetBits(d: number): number[];
    static Remainder(d1: number, d2: number): number;
    static Multiply(d1: number, d2: number): number;
    static Negate(d: number): number;
    static Round(d: number): number;
    static Round(d: number, decimals: number): number;
    static Round(d: number, mode: System.MidpointRounding): number;
    static Round(d: number, decimals: number, mode: System.MidpointRounding): number;
    static Subtract(d1: number, d2: number): number;
    static ToByte(value: number): Byte;
    static ToSByte(value: number): System.SByte;
    static ToInt16(value: number): number;
    static ToDouble(d: number): number;
    static ToInt32(d: number): number;
    static ToInt64(d: number): number;
    static ToUInt16(value: number): number;
    static ToUInt32(d: number): number;
    static ToUInt64(d: number): number;
    static ToSingle(d: number): number;
    static Truncate(d: number): number;
    GetTypeCode(): System.TypeCode;
    GetType(): System.Type;
  }
  export class UriBuilder {
    constructor();
    constructor(uri: string);
    constructor(uri: System.Uri);
    constructor(schemeName: string, hostName: string);
    constructor(scheme: string, host: string, portNumber: number);
    constructor(scheme: string, host: string, port: number, pathValue: string);
    constructor(scheme: string, host: string, port: number, path: string, extraValue: string);
    Fragment: string;
    Host: string;
    Password: string;
    Path: string;
    Port: number;
    Query: string;
    Scheme: string;
    Uri: System.Uri;
    UserName: string;
    Equals(rparam: any): boolean;
    GetHashCode(): number;
    ToString(): string;
    GetType(): System.Type;
  }
  export class StringNormalizationExtensions {
    static IsNormalized(strInput: string): boolean;
    static IsNormalized(strInput: string, normalizationForm: System.Text.NormalizationForm): boolean;
    static Normalize(strInput: string): string;
    static Normalize(strInput: string, normalizationForm: System.Text.NormalizationForm): string;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export enum GenericUriParserOptions {
    Default = 0,
    GenericAuthority = 1,
    AllowEmptyAuthority = 2,
    NoUserInfo = 4,
    NoPort = 8,
    NoQuery = 16,
    NoFragment = 32,
    DontConvertPathBackslashes = 64,
    DontCompressPath = 128,
    DontUnescapePathDotsAndSlashes = 256,
    Idn = 512,
    IriParsing = 1024,
  }
  export class GenericUriParser {
    constructor(options: System.GenericUriParserOptions);
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class Uri {
    constructor(uriString: string);
    constructor(uriString: string, dontEscape: boolean);
    constructor(baseUri: System.Uri, relativeUri: string, dontEscape: boolean);
    constructor(uriString: string, uriKind: System.UriKind);
    constructor(baseUri: System.Uri, relativeUri: string);
    constructor(baseUri: System.Uri, relativeUri: System.Uri);
    AbsolutePath: string;
    AbsoluteUri: string;
    LocalPath: string;
    Authority: string;
    HostNameType: System.UriHostNameType;
    IsDefaultPort: boolean;
    IsFile: boolean;
    IsLoopback: boolean;
    PathAndQuery: string;
    Segments: string[];
    IsUnc: boolean;
    Host: string;
    Port: number;
    Query: string;
    Fragment: string;
    Scheme: string;
    OriginalString: string;
    DnsSafeHost: string;
    IdnHost: string;
    IsAbsoluteUri: boolean;
    UserEscaped: boolean;
    UserInfo: string;
    static UriSchemeFile: string;
    static UriSchemeFtp: string;
    static UriSchemeGopher: string;
    static UriSchemeHttp: string;
    static UriSchemeHttps: string;
    static UriSchemeMailto: string;
    static UriSchemeNews: string;
    static UriSchemeNntp: string;
    static UriSchemeNetTcp: string;
    static UriSchemeNetPipe: string;
    static SchemeDelimiter: string;
    static CheckHostName(name: string): System.UriHostNameType;
    GetLeftPart(part: System.UriPartial): string;
    static HexEscape(character: System.Char): string;
    static IsHexEncoding(pattern: string, index: number): boolean;
    static CheckSchemeName(schemeName: string): boolean;
    static IsHexDigit(character: System.Char): boolean;
    static FromHex(digit: System.Char): number;
    GetHashCode(): number;
    ToString(): string;
    Equals(comparand: any): boolean;
    MakeRelativeUri(uri: System.Uri): System.Uri;
    MakeRelative(toUri: System.Uri): string;
    GetComponents(components: System.UriComponents, format: System.UriFormat): string;
    static Compare(uri1: System.Uri, uri2: System.Uri, partsToCompare: System.UriComponents, compareFormat: System.UriFormat, comparisonType: System.StringComparison): number;
    IsWellFormedOriginalString(): boolean;
    static IsWellFormedUriString(uriString: string, uriKind: System.UriKind): boolean;
    static UnescapeDataString(stringToUnescape: string): string;
    static EscapeUriString(stringToEscape: string): string;
    static EscapeDataString(stringToEscape: string): string;
    IsBaseOf(uri: System.Uri): boolean;
    GetType(): System.Type;
  }
  export class UriFormatException {
    constructor();
    constructor(textString: string);
    constructor(textString: string, e: System.Exception);
    Message: string;
    Data: System.Collections.IDictionary;
    InnerException: System.Exception;
    TargetSite: System.Reflection.MethodBase;
    StackTrace: string;
    HelpLink: string;
    Source: string;
    HResult: number;
    GetBaseException(): System.Exception;
    ToString(): string;
    GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
    GetType(): System.Type;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
  }
  export enum UriPartial {
    Scheme = 0,
    Authority = 1,
    Path = 2,
    Query = 3,
  }
  export enum UriKind {
    RelativeOrAbsolute = 0,
    Absolute = 1,
    Relative = 2,
  }
  export enum UriComponents {
    Scheme = 1,
    UserInfo = 2,
    Host = 4,
    Port = 8,
    Path = 16,
    Query = 32,
    Fragment = 64,
    StrongPort = 128,
    NormalizedHost = 256,
    KeepDelimiter = 1073741824,
    SerializationInfoString = -2147483648,
    AbsoluteUri = 127,
    HostAndPort = 132,
    StrongAuthority = 134,
    SchemeAndServer = 13,
    HttpRequestUrl = 61,
    PathAndQuery = 48,
  }
  export enum UriFormat {
    UriEscaped = 1,
    Unescaped = 2,
    SafeUnescaped = 3,
  }
  export enum UriIdnScope {
    None = 0,
    AllExceptIntranet = 1,
    All = 2,
  }
  export enum UriHostNameType {
    Unknown = 0,
    Basic = 1,
    Dns = 2,
    IPv4 = 3,
    IPv6 = 4,
  }
  export class HttpStyleUriParser {
    constructor();
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class FtpStyleUriParser {
    constructor();
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class FileStyleUriParser {
    constructor();
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class NewsStyleUriParser {
    constructor();
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class GopherStyleUriParser {
    constructor();
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class LdapStyleUriParser {
    constructor();
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class NetPipeStyleUriParser {
    constructor();
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class NetTcpStyleUriParser {
    constructor();
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class UriParser {
    static Register(uriParser: System.UriParser, schemeName: string, defaultPort: number): void;
    static IsKnownScheme(schemeName: string): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export class UriTypeConverter {
    constructor();
    CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
    CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
    ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
    ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
    IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
    CanConvertFrom(sourceType: System.Type): boolean;
    CanConvertTo(destinationType: System.Type): boolean;
    ConvertFrom(value: any): any;
    ConvertFromInvariantString(text: string): any;
    ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
    ConvertFromString(text: string): any;
    ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
    ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
    ConvertTo(value: any, destinationType: System.Type): any;
    ConvertToInvariantString(value: any): string;
    ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
    ConvertToString(value: any): string;
    ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
    ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
    CreateInstance(propertyValues: System.Collections.IDictionary): any;
    CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
    GetCreateInstanceSupported(): boolean;
    GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
    GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
    GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
    GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
    GetPropertiesSupported(): boolean;
    GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
    GetStandardValues(): System.Collections.ICollection;
    GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
    GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
    IsValid(value: any): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetType(): System.Type;
    ToString(): string;
  }
  export namespace Buffers {
    export class SpanAction<T = any, TArg = any> {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(span: System.Span<T>, arg: TArg): void;
      BeginInvoke(span: System.Span<T>, arg: TArg, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ReadOnlySpanAction<T = any, TArg = any> {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(span: System.ReadOnlySpan<T>, arg: TArg): void;
      BeginInvoke(span: System.ReadOnlySpan<T>, arg: TArg, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ArrayPool<T = any> {
      static Shared: any; // System.Buffers.ArrayPool`1[T]
      static Create(): any;
      static Create(maxArrayLength: number, maxArraysPerBucket: number): any;
      Rent(minimumLength: number): T[];
      Return(array: T[], clearArray?: boolean): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IMemoryOwner<T = any> {
      Memory: System.Memory<T>;
    }
    export interface IPinnable {
      Pin(elementIndex: number): System.Buffers.MemoryHandle;
      Unpin(): void;
    }
    export class MemoryHandle {
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class MemoryManager<T = any> {
      Memory: System.Memory<T>;
      GetSpan(): System.Span<T>;
      Pin(elementIndex?: number): System.Buffers.MemoryHandle;
      Unpin(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BuffersExtensions {
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IBufferWriter<T = any> {
      Advance(count: number): void;
      GetMemory(sizeHint?: number): System.Memory<T>;
      GetSpan(sizeHint?: number): System.Span<T>;
    }
    export class MemoryPool<T = any> {
      static Shared: any; // System.Buffers.MemoryPool`1[T]
      MaxBufferSize: number;
      Rent(minBufferSize?: number): System.Buffers.IMemoryOwner<T>;
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum OperationStatus {
      Done = 0,
      DestinationTooSmall = 1,
      NeedMoreData = 2,
      InvalidData = 3,
    }
    export class ReadOnlySequence<T = any> {
      constructor(startSegment: System.Buffers.ReadOnlySequenceSegment<T>, startIndex: number, endSegment: System.Buffers.ReadOnlySequenceSegment<T>, endIndex: number);
      constructor(array: T[]);
      constructor(array: T[], start: number, length: number);
      constructor(memory: System.ReadOnlyMemory<T>);
      Length: number;
      IsEmpty: boolean;
      IsSingleSegment: boolean;
      First: System.ReadOnlyMemory<T>;
      FirstSpan: System.ReadOnlySpan<T>;
      Start: System.SequencePosition;
      End: System.SequencePosition;
      static Empty: any; // System.Buffers.ReadOnlySequence`1[T]
      Slice(start: number, length: number): System.Buffers.ReadOnlySequence<T>;
      Slice(start: number, end: System.SequencePosition): System.Buffers.ReadOnlySequence<T>;
      Slice(start: System.SequencePosition, length: number): System.Buffers.ReadOnlySequence<T>;
      Slice(start: number, length: number): System.Buffers.ReadOnlySequence<T>;
      Slice(start: number, end: System.SequencePosition): System.Buffers.ReadOnlySequence<T>;
      Slice(start: System.SequencePosition, length: number): System.Buffers.ReadOnlySequence<T>;
      Slice(start: System.SequencePosition, end: System.SequencePosition): System.Buffers.ReadOnlySequence<T>;
      Slice(start: System.SequencePosition): System.Buffers.ReadOnlySequence<T>;
      Slice(start: number): System.Buffers.ReadOnlySequence<T>;
      ToString(): string;
      GetEnumerator(): System.Buffers.ReadOnlySequence<T>;
      GetPosition(offset: number): System.SequencePosition;
      GetPosition(offset: number, origin: System.SequencePosition): System.SequencePosition;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ReadOnlySequenceSegment<T = any> {
      Memory: System.ReadOnlyMemory<T>;
      Next: System.Buffers.ReadOnlySequenceSegment<T>;
      RunningIndex: number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StandardFormat {
      constructor(symbol: System.Char, precision?: Byte);
      Symbol: System.Char;
      Precision: Byte;
      HasPrecision: boolean;
      IsDefault: boolean;
      static NoPrecision: Byte;
      static MaxPrecision: Byte;
      static Parse(format: any): System.Buffers.StandardFormat;
      static Parse(format: string): System.Buffers.StandardFormat;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      Equals(other: System.Buffers.StandardFormat): boolean;
      ToString(): string;
      GetType(): System.Type;
    }
    export class ArrayBufferWriter<T = any> {
      constructor();
      constructor(initialCapacity: number);
      WrittenMemory: System.ReadOnlyMemory<T>;
      WrittenSpan: System.ReadOnlySpan<T>;
      WrittenCount: number;
      Capacity: number;
      FreeCapacity: number;
      Clear(): void;
      Advance(count: number): void;
      GetMemory(sizeHint?: number): System.Memory<T>;
      GetSpan(sizeHint?: number): System.Span<T>;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SequenceReader<T = any> {
      constructor(sequence: System.Buffers.ReadOnlySequence<T>);
      End: boolean;
      Sequence: System.Buffers.ReadOnlySequence<T>;
      Position: System.SequencePosition;
      CurrentSpan: System.ReadOnlySpan<T>;
      CurrentSpanIndex: number;
      UnreadSpan: System.ReadOnlySpan<T>;
      Consumed: number;
      Remaining: number;
      Length: number;
      TryAdvanceTo(delimiter: T, advancePastDelimiter?: boolean): boolean;
      TryAdvanceToAny(delimiters: System.ReadOnlySpan<T>, advancePastDelimiter?: boolean): boolean;
      AdvancePast(value: T): number;
      AdvancePastAny(values: System.ReadOnlySpan<T>): number;
      AdvancePastAny(value0: T, value1: T, value2: T, value3: T): number;
      AdvancePastAny(value0: T, value1: T, value2: T): number;
      AdvancePastAny(value0: T, value1: T): number;
      IsNext(next: T, advancePast?: boolean): boolean;
      IsNext(next: System.ReadOnlySpan<T>, advancePast?: boolean): boolean;
      Rewind(count: number): void;
      Advance(count: number): void;
      TryCopyTo(destination: System.Span<T>): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class SequenceReaderExtensions {
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export namespace Binary {
      export class BinaryPrimitives {
        static ReverseEndianness(value: System.SByte): System.SByte;
        static ReverseEndianness(value: number): number;
        static ReverseEndianness(value: number): number;
        static ReverseEndianness(value: number): number;
        static ReverseEndianness(value: Byte): Byte;
        static ReverseEndianness(value: number): number;
        static ReverseEndianness(value: number): number;
        static ReverseEndianness(value: number): number;
        static ReadInt16BigEndian(source: any): number;
        static ReadInt32BigEndian(source: any): number;
        static ReadInt64BigEndian(source: any): number;
        static ReadUInt16BigEndian(source: any): number;
        static ReadUInt32BigEndian(source: any): number;
        static ReadUInt64BigEndian(source: any): number;
        static ReadInt16LittleEndian(source: any): number;
        static ReadInt32LittleEndian(source: any): number;
        static ReadInt64LittleEndian(source: any): number;
        static ReadUInt16LittleEndian(source: any): number;
        static ReadUInt32LittleEndian(source: any): number;
        static ReadUInt64LittleEndian(source: any): number;
        static WriteInt16BigEndian(destination: any, value: number): void;
        static WriteInt32BigEndian(destination: any, value: number): void;
        static WriteInt64BigEndian(destination: any, value: number): void;
        static WriteUInt16BigEndian(destination: any, value: number): void;
        static WriteUInt32BigEndian(destination: any, value: number): void;
        static WriteUInt64BigEndian(destination: any, value: number): void;
        static TryWriteInt16BigEndian(destination: any, value: number): boolean;
        static TryWriteInt32BigEndian(destination: any, value: number): boolean;
        static TryWriteInt64BigEndian(destination: any, value: number): boolean;
        static TryWriteUInt16BigEndian(destination: any, value: number): boolean;
        static TryWriteUInt32BigEndian(destination: any, value: number): boolean;
        static TryWriteUInt64BigEndian(destination: any, value: number): boolean;
        static WriteInt16LittleEndian(destination: any, value: number): void;
        static WriteInt32LittleEndian(destination: any, value: number): void;
        static WriteInt64LittleEndian(destination: any, value: number): void;
        static WriteUInt16LittleEndian(destination: any, value: number): void;
        static WriteUInt32LittleEndian(destination: any, value: number): void;
        static WriteUInt64LittleEndian(destination: any, value: number): void;
        static TryWriteInt16LittleEndian(destination: any, value: number): boolean;
        static TryWriteInt32LittleEndian(destination: any, value: number): boolean;
        static TryWriteInt64LittleEndian(destination: any, value: number): boolean;
        static TryWriteUInt16LittleEndian(destination: any, value: number): boolean;
        static TryWriteUInt32LittleEndian(destination: any, value: number): boolean;
        static TryWriteUInt64LittleEndian(destination: any, value: number): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace Text {
      export class Base64 {
        static GetMaxDecodedFromUtf8Length(length: number): number;
        static GetMaxEncodedToUtf8Length(length: number): number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Utf8Formatter {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Utf8Parser {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
  }
  export namespace CodeDom {
    export class CodeObject {
      constructor();
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum CodeTypeReferenceOptions {
      GlobalReference = 1,
      GenericTypeParameter = 2,
    }
    export class CodeTypeReference {
      constructor();
      constructor(type: System.Type);
      constructor(type: System.Type, codeTypeReferenceOption: System.CodeDom.CodeTypeReferenceOptions);
      constructor(typeName: string, codeTypeReferenceOption: System.CodeDom.CodeTypeReferenceOptions);
      constructor(typeName: string);
      constructor(typeName: string, ...typeArguments: System.CodeDom.CodeTypeReference[]);
      constructor(typeParameter: System.CodeDom.CodeTypeParameter);
      constructor(baseType: string, rank: number);
      constructor(arrayType: System.CodeDom.CodeTypeReference, rank: number);
      ArrayElementType: System.CodeDom.CodeTypeReference;
      ArrayRank: number;
      BaseType: string;
      Options: System.CodeDom.CodeTypeReferenceOptions;
      TypeArguments: System.CodeDom.CodeTypeReferenceCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeReferenceCollection {
      constructor();
      constructor(value: System.CodeDom.CodeTypeReferenceCollection);
      constructor(value: System.CodeDom.CodeTypeReference[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeTypeReference): number;
      Add(value: string): void;
      Add(value: System.Type): void;
      AddRange(value: System.CodeDom.CodeTypeReference[]): void;
      AddRange(value: System.CodeDom.CodeTypeReferenceCollection): void;
      Contains(value: System.CodeDom.CodeTypeReference): boolean;
      CopyTo(array: System.CodeDom.CodeTypeReference[], index: number): void;
      IndexOf(value: System.CodeDom.CodeTypeReference): number;
      Insert(index: number, value: System.CodeDom.CodeTypeReference): void;
      Remove(value: System.CodeDom.CodeTypeReference): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeArgumentReferenceExpression {
      constructor();
      constructor(parameterName: string);
      ParameterName: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeArrayCreateExpression {
      constructor();
      constructor(createType: System.CodeDom.CodeTypeReference, ...initializers: System.CodeDom.CodeExpression[]);
      constructor(createType: string, ...initializers: System.CodeDom.CodeExpression[]);
      constructor(createType: System.Type, ...initializers: System.CodeDom.CodeExpression[]);
      constructor(createType: System.CodeDom.CodeTypeReference, size: number);
      constructor(createType: string, size: number);
      constructor(createType: System.Type, size: number);
      constructor(createType: System.CodeDom.CodeTypeReference, size: System.CodeDom.CodeExpression);
      constructor(createType: string, size: System.CodeDom.CodeExpression);
      constructor(createType: System.Type, size: System.CodeDom.CodeExpression);
      CreateType: System.CodeDom.CodeTypeReference;
      Initializers: System.CodeDom.CodeExpressionCollection;
      Size: number;
      SizeExpression: System.CodeDom.CodeExpression;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeArrayIndexerExpression {
      constructor();
      constructor(targetObject: System.CodeDom.CodeExpression, ...indices: System.CodeDom.CodeExpression[]);
      TargetObject: System.CodeDom.CodeExpression;
      Indices: System.CodeDom.CodeExpressionCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeAssignStatement {
      constructor();
      constructor(left: System.CodeDom.CodeExpression, right: System.CodeDom.CodeExpression);
      Left: System.CodeDom.CodeExpression;
      Right: System.CodeDom.CodeExpression;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeAttachEventStatement {
      constructor();
      constructor(eventRef: System.CodeDom.CodeEventReferenceExpression, listener: System.CodeDom.CodeExpression);
      constructor(targetObject: System.CodeDom.CodeExpression, eventName: string, listener: System.CodeDom.CodeExpression);
      Event: System.CodeDom.CodeEventReferenceExpression;
      Listener: System.CodeDom.CodeExpression;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeAttributeArgument {
      constructor();
      constructor(value: System.CodeDom.CodeExpression);
      constructor(name: string, value: System.CodeDom.CodeExpression);
      Name: string;
      Value: System.CodeDom.CodeExpression;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeAttributeArgumentCollection {
      constructor();
      constructor(value: System.CodeDom.CodeAttributeArgumentCollection);
      constructor(value: System.CodeDom.CodeAttributeArgument[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeAttributeArgument): number;
      AddRange(value: System.CodeDom.CodeAttributeArgument[]): void;
      AddRange(value: System.CodeDom.CodeAttributeArgumentCollection): void;
      Contains(value: System.CodeDom.CodeAttributeArgument): boolean;
      CopyTo(array: System.CodeDom.CodeAttributeArgument[], index: number): void;
      IndexOf(value: System.CodeDom.CodeAttributeArgument): number;
      Insert(index: number, value: System.CodeDom.CodeAttributeArgument): void;
      Remove(value: System.CodeDom.CodeAttributeArgument): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeAttributeDeclaration {
      constructor();
      constructor(name: string);
      constructor(name: string, ...argumentsCS: System.CodeDom.CodeAttributeArgument[]);
      constructor(attributeType: System.CodeDom.CodeTypeReference);
      constructor(attributeType: System.CodeDom.CodeTypeReference, ...argumentsCS: System.CodeDom.CodeAttributeArgument[]);
      Name: string;
      Arguments: System.CodeDom.CodeAttributeArgumentCollection;
      AttributeType: System.CodeDom.CodeTypeReference;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeAttributeDeclarationCollection {
      constructor();
      constructor(value: System.CodeDom.CodeAttributeDeclarationCollection);
      constructor(value: System.CodeDom.CodeAttributeDeclaration[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeAttributeDeclaration): number;
      AddRange(value: System.CodeDom.CodeAttributeDeclaration[]): void;
      AddRange(value: System.CodeDom.CodeAttributeDeclarationCollection): void;
      Contains(value: System.CodeDom.CodeAttributeDeclaration): boolean;
      CopyTo(array: System.CodeDom.CodeAttributeDeclaration[], index: number): void;
      IndexOf(value: System.CodeDom.CodeAttributeDeclaration): number;
      Insert(index: number, value: System.CodeDom.CodeAttributeDeclaration): void;
      Remove(value: System.CodeDom.CodeAttributeDeclaration): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeBaseReferenceExpression {
      constructor();
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeBinaryOperatorExpression {
      constructor();
      constructor(left: System.CodeDom.CodeExpression, op: System.CodeDom.CodeBinaryOperatorType, right: System.CodeDom.CodeExpression);
      Right: System.CodeDom.CodeExpression;
      Left: System.CodeDom.CodeExpression;
      Operator: System.CodeDom.CodeBinaryOperatorType;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum CodeBinaryOperatorType {
      Add = 0,
      Subtract = 1,
      Multiply = 2,
      Divide = 3,
      Modulus = 4,
      Assign = 5,
      IdentityInequality = 6,
      IdentityEquality = 7,
      ValueEquality = 8,
      BitwiseOr = 9,
      BitwiseAnd = 10,
      BooleanOr = 11,
      BooleanAnd = 12,
      LessThan = 13,
      LessThanOrEqual = 14,
      GreaterThan = 15,
      GreaterThanOrEqual = 16,
    }
    export class CodeCastExpression {
      constructor();
      constructor(targetType: System.CodeDom.CodeTypeReference, expression: System.CodeDom.CodeExpression);
      constructor(targetType: string, expression: System.CodeDom.CodeExpression);
      constructor(targetType: System.Type, expression: System.CodeDom.CodeExpression);
      TargetType: System.CodeDom.CodeTypeReference;
      Expression: System.CodeDom.CodeExpression;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeCatchClause {
      constructor();
      constructor(localName: string);
      constructor(localName: string, catchExceptionType: System.CodeDom.CodeTypeReference);
      constructor(localName: string, catchExceptionType: System.CodeDom.CodeTypeReference, ...statements: System.CodeDom.CodeStatement[]);
      LocalName: string;
      CatchExceptionType: System.CodeDom.CodeTypeReference;
      Statements: System.CodeDom.CodeStatementCollection;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeCatchClauseCollection {
      constructor();
      constructor(value: System.CodeDom.CodeCatchClauseCollection);
      constructor(value: System.CodeDom.CodeCatchClause[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeCatchClause): number;
      AddRange(value: System.CodeDom.CodeCatchClause[]): void;
      AddRange(value: System.CodeDom.CodeCatchClauseCollection): void;
      Contains(value: System.CodeDom.CodeCatchClause): boolean;
      CopyTo(array: System.CodeDom.CodeCatchClause[], index: number): void;
      IndexOf(value: System.CodeDom.CodeCatchClause): number;
      Insert(index: number, value: System.CodeDom.CodeCatchClause): void;
      Remove(value: System.CodeDom.CodeCatchClause): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeChecksumPragma {
      constructor();
      constructor(fileName: string, checksumAlgorithmId: System.Guid, checksumData: Byte[]);
      FileName: string;
      ChecksumAlgorithmId: System.Guid;
      ChecksumData: Byte[];
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeComment {
      constructor();
      constructor(text: string);
      constructor(text: string, docComment: boolean);
      DocComment: boolean;
      Text: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeCommentStatement {
      constructor();
      constructor(comment: System.CodeDom.CodeComment);
      constructor(text: string);
      constructor(text: string, docComment: boolean);
      Comment: System.CodeDom.CodeComment;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeCommentStatementCollection {
      constructor();
      constructor(value: System.CodeDom.CodeCommentStatementCollection);
      constructor(value: System.CodeDom.CodeCommentStatement[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeCommentStatement): number;
      AddRange(value: System.CodeDom.CodeCommentStatement[]): void;
      AddRange(value: System.CodeDom.CodeCommentStatementCollection): void;
      Contains(value: System.CodeDom.CodeCommentStatement): boolean;
      CopyTo(array: System.CodeDom.CodeCommentStatement[], index: number): void;
      IndexOf(value: System.CodeDom.CodeCommentStatement): number;
      Insert(index: number, value: System.CodeDom.CodeCommentStatement): void;
      Remove(value: System.CodeDom.CodeCommentStatement): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeCompileUnit {
      constructor();
      Namespaces: System.CodeDom.CodeNamespaceCollection;
      ReferencedAssemblies: System.Collections.Specialized.StringCollection;
      AssemblyCustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeConditionStatement {
      constructor();
      constructor(condition: System.CodeDom.CodeExpression, ...trueStatements: System.CodeDom.CodeStatement[]);
      constructor(condition: System.CodeDom.CodeExpression, trueStatements: System.CodeDom.CodeStatement[], falseStatements: System.CodeDom.CodeStatement[]);
      Condition: System.CodeDom.CodeExpression;
      TrueStatements: System.CodeDom.CodeStatementCollection;
      FalseStatements: System.CodeDom.CodeStatementCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeConstructor {
      constructor();
      BaseConstructorArgs: System.CodeDom.CodeExpressionCollection;
      ChainedConstructorArgs: System.CodeDom.CodeExpressionCollection;
      ReturnType: System.CodeDom.CodeTypeReference;
      Statements: System.CodeDom.CodeStatementCollection;
      Parameters: System.CodeDom.CodeParameterDeclarationExpressionCollection;
      PrivateImplementationType: System.CodeDom.CodeTypeReference;
      ImplementationTypes: System.CodeDom.CodeTypeReferenceCollection;
      ReturnTypeCustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      TypeParameters: System.CodeDom.CodeTypeParameterCollection;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeDefaultValueExpression {
      constructor();
      constructor(type: System.CodeDom.CodeTypeReference);
      Type: System.CodeDom.CodeTypeReference;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeDelegateCreateExpression {
      constructor();
      constructor(delegateType: System.CodeDom.CodeTypeReference, targetObject: System.CodeDom.CodeExpression, methodName: string);
      DelegateType: System.CodeDom.CodeTypeReference;
      TargetObject: System.CodeDom.CodeExpression;
      MethodName: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeDelegateInvokeExpression {
      constructor();
      constructor(targetObject: System.CodeDom.CodeExpression);
      constructor(targetObject: System.CodeDom.CodeExpression, ...parameters: System.CodeDom.CodeExpression[]);
      TargetObject: System.CodeDom.CodeExpression;
      Parameters: System.CodeDom.CodeExpressionCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeDirectionExpression {
      constructor();
      constructor(direction: System.CodeDom.FieldDirection, expression: System.CodeDom.CodeExpression);
      Expression: System.CodeDom.CodeExpression;
      Direction: System.CodeDom.FieldDirection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeDirective {
      constructor();
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeDirectiveCollection {
      constructor();
      constructor(value: System.CodeDom.CodeDirectiveCollection);
      constructor(value: System.CodeDom.CodeDirective[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeDirective): number;
      AddRange(value: System.CodeDom.CodeDirective[]): void;
      AddRange(value: System.CodeDom.CodeDirectiveCollection): void;
      Contains(value: System.CodeDom.CodeDirective): boolean;
      CopyTo(array: System.CodeDom.CodeDirective[], index: number): void;
      IndexOf(value: System.CodeDom.CodeDirective): number;
      Insert(index: number, value: System.CodeDom.CodeDirective): void;
      Remove(value: System.CodeDom.CodeDirective): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeEntryPointMethod {
      constructor();
      ReturnType: System.CodeDom.CodeTypeReference;
      Statements: System.CodeDom.CodeStatementCollection;
      Parameters: System.CodeDom.CodeParameterDeclarationExpressionCollection;
      PrivateImplementationType: System.CodeDom.CodeTypeReference;
      ImplementationTypes: System.CodeDom.CodeTypeReferenceCollection;
      ReturnTypeCustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      TypeParameters: System.CodeDom.CodeTypeParameterCollection;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeEventReferenceExpression {
      constructor();
      constructor(targetObject: System.CodeDom.CodeExpression, eventName: string);
      TargetObject: System.CodeDom.CodeExpression;
      EventName: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeExpression {
      constructor();
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeExpressionCollection {
      constructor();
      constructor(value: System.CodeDom.CodeExpressionCollection);
      constructor(value: System.CodeDom.CodeExpression[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeExpression): number;
      AddRange(value: System.CodeDom.CodeExpression[]): void;
      AddRange(value: System.CodeDom.CodeExpressionCollection): void;
      Contains(value: System.CodeDom.CodeExpression): boolean;
      CopyTo(array: System.CodeDom.CodeExpression[], index: number): void;
      IndexOf(value: System.CodeDom.CodeExpression): number;
      Insert(index: number, value: System.CodeDom.CodeExpression): void;
      Remove(value: System.CodeDom.CodeExpression): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeExpressionStatement {
      constructor();
      constructor(expression: System.CodeDom.CodeExpression);
      Expression: System.CodeDom.CodeExpression;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeFieldReferenceExpression {
      constructor();
      constructor(targetObject: System.CodeDom.CodeExpression, fieldName: string);
      TargetObject: System.CodeDom.CodeExpression;
      FieldName: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeGotoStatement {
      constructor();
      constructor(label: string);
      Label: string;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeIndexerExpression {
      constructor();
      constructor(targetObject: System.CodeDom.CodeExpression, ...indices: System.CodeDom.CodeExpression[]);
      TargetObject: System.CodeDom.CodeExpression;
      Indices: System.CodeDom.CodeExpressionCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeIterationStatement {
      constructor();
      constructor(initStatement: System.CodeDom.CodeStatement, testExpression: System.CodeDom.CodeExpression, incrementStatement: System.CodeDom.CodeStatement, ...statements: System.CodeDom.CodeStatement[]);
      InitStatement: System.CodeDom.CodeStatement;
      TestExpression: System.CodeDom.CodeExpression;
      IncrementStatement: System.CodeDom.CodeStatement;
      Statements: System.CodeDom.CodeStatementCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeLabeledStatement {
      constructor();
      constructor(label: string);
      constructor(label: string, statement: System.CodeDom.CodeStatement);
      Label: string;
      Statement: System.CodeDom.CodeStatement;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeLinePragma {
      constructor();
      constructor(fileName: string, lineNumber: number);
      FileName: string;
      LineNumber: number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeMemberEvent {
      constructor();
      Type: System.CodeDom.CodeTypeReference;
      PrivateImplementationType: System.CodeDom.CodeTypeReference;
      ImplementationTypes: System.CodeDom.CodeTypeReferenceCollection;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeMemberField {
      constructor();
      constructor(type: System.CodeDom.CodeTypeReference, name: string);
      constructor(type: string, name: string);
      constructor(type: System.Type, name: string);
      Type: System.CodeDom.CodeTypeReference;
      InitExpression: System.CodeDom.CodeExpression;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeMemberMethod {
      constructor();
      ReturnType: System.CodeDom.CodeTypeReference;
      Statements: System.CodeDom.CodeStatementCollection;
      Parameters: System.CodeDom.CodeParameterDeclarationExpressionCollection;
      PrivateImplementationType: System.CodeDom.CodeTypeReference;
      ImplementationTypes: System.CodeDom.CodeTypeReferenceCollection;
      ReturnTypeCustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      TypeParameters: System.CodeDom.CodeTypeParameterCollection;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeMemberProperty {
      constructor();
      PrivateImplementationType: System.CodeDom.CodeTypeReference;
      ImplementationTypes: System.CodeDom.CodeTypeReferenceCollection;
      Type: System.CodeDom.CodeTypeReference;
      HasGet: boolean;
      HasSet: boolean;
      GetStatements: System.CodeDom.CodeStatementCollection;
      SetStatements: System.CodeDom.CodeStatementCollection;
      Parameters: System.CodeDom.CodeParameterDeclarationExpressionCollection;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeMethodInvokeExpression {
      constructor();
      constructor(method: System.CodeDom.CodeMethodReferenceExpression, ...parameters: System.CodeDom.CodeExpression[]);
      constructor(targetObject: System.CodeDom.CodeExpression, methodName: string, ...parameters: System.CodeDom.CodeExpression[]);
      Method: System.CodeDom.CodeMethodReferenceExpression;
      Parameters: System.CodeDom.CodeExpressionCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeMethodReturnStatement {
      constructor();
      constructor(expression: System.CodeDom.CodeExpression);
      Expression: System.CodeDom.CodeExpression;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeNamespace {
      constructor();
      constructor(name: string);
      Types: System.CodeDom.CodeTypeDeclarationCollection;
      Imports: System.CodeDom.CodeNamespaceImportCollection;
      Name: string;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeNamespaceCollection {
      constructor();
      constructor(value: System.CodeDom.CodeNamespaceCollection);
      constructor(value: System.CodeDom.CodeNamespace[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeNamespace): number;
      AddRange(value: System.CodeDom.CodeNamespace[]): void;
      AddRange(value: System.CodeDom.CodeNamespaceCollection): void;
      Contains(value: System.CodeDom.CodeNamespace): boolean;
      CopyTo(array: System.CodeDom.CodeNamespace[], index: number): void;
      IndexOf(value: System.CodeDom.CodeNamespace): number;
      Insert(index: number, value: System.CodeDom.CodeNamespace): void;
      Remove(value: System.CodeDom.CodeNamespace): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeNamespaceImport {
      constructor();
      constructor(nameSpace: string);
      LinePragma: System.CodeDom.CodeLinePragma;
      Namespace: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeNamespaceImportCollection {
      constructor();
      Count: number;
      Add(value: System.CodeDom.CodeNamespaceImport): void;
      AddRange(value: System.CodeDom.CodeNamespaceImport[]): void;
      Clear(): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeObjectCreateExpression {
      constructor();
      constructor(createType: System.CodeDom.CodeTypeReference, ...parameters: System.CodeDom.CodeExpression[]);
      constructor(createType: string, ...parameters: System.CodeDom.CodeExpression[]);
      constructor(createType: System.Type, ...parameters: System.CodeDom.CodeExpression[]);
      CreateType: System.CodeDom.CodeTypeReference;
      Parameters: System.CodeDom.CodeExpressionCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeParameterDeclarationExpression {
      constructor();
      constructor(type: System.CodeDom.CodeTypeReference, name: string);
      constructor(type: string, name: string);
      constructor(type: System.Type, name: string);
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      Direction: System.CodeDom.FieldDirection;
      Type: System.CodeDom.CodeTypeReference;
      Name: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeParameterDeclarationExpressionCollection {
      constructor();
      constructor(value: System.CodeDom.CodeParameterDeclarationExpressionCollection);
      constructor(value: System.CodeDom.CodeParameterDeclarationExpression[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeParameterDeclarationExpression): number;
      AddRange(value: System.CodeDom.CodeParameterDeclarationExpression[]): void;
      AddRange(value: System.CodeDom.CodeParameterDeclarationExpressionCollection): void;
      Contains(value: System.CodeDom.CodeParameterDeclarationExpression): boolean;
      CopyTo(array: System.CodeDom.CodeParameterDeclarationExpression[], index: number): void;
      IndexOf(value: System.CodeDom.CodeParameterDeclarationExpression): number;
      Insert(index: number, value: System.CodeDom.CodeParameterDeclarationExpression): void;
      Remove(value: System.CodeDom.CodeParameterDeclarationExpression): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodePrimitiveExpression {
      constructor();
      constructor(value: any);
      Value: any; // System.Object
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodePropertyReferenceExpression {
      constructor();
      constructor(targetObject: System.CodeDom.CodeExpression, propertyName: string);
      TargetObject: System.CodeDom.CodeExpression;
      PropertyName: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodePropertySetValueReferenceExpression {
      constructor();
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeRegionDirective {
      constructor();
      constructor(regionMode: System.CodeDom.CodeRegionMode, regionText: string);
      RegionText: string;
      RegionMode: System.CodeDom.CodeRegionMode;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum CodeRegionMode {
      None = 0,
      Start = 1,
      End = 2,
    }
    export class CodeRemoveEventStatement {
      constructor();
      constructor(eventRef: System.CodeDom.CodeEventReferenceExpression, listener: System.CodeDom.CodeExpression);
      constructor(targetObject: System.CodeDom.CodeExpression, eventName: string, listener: System.CodeDom.CodeExpression);
      Event: System.CodeDom.CodeEventReferenceExpression;
      Listener: System.CodeDom.CodeExpression;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeSnippetCompileUnit {
      constructor();
      constructor(value: string);
      Value: string;
      LinePragma: System.CodeDom.CodeLinePragma;
      Namespaces: System.CodeDom.CodeNamespaceCollection;
      ReferencedAssemblies: System.Collections.Specialized.StringCollection;
      AssemblyCustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeSnippetExpression {
      constructor();
      constructor(value: string);
      Value: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeSnippetStatement {
      constructor();
      constructor(value: string);
      Value: string;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeSnippetTypeMember {
      constructor();
      constructor(text: string);
      Text: string;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeStatement {
      constructor();
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeStatementCollection {
      constructor();
      constructor(value: System.CodeDom.CodeStatementCollection);
      constructor(value: System.CodeDom.CodeStatement[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeStatement): number;
      Add(value: System.CodeDom.CodeExpression): number;
      AddRange(value: System.CodeDom.CodeStatement[]): void;
      AddRange(value: System.CodeDom.CodeStatementCollection): void;
      Contains(value: System.CodeDom.CodeStatement): boolean;
      CopyTo(array: System.CodeDom.CodeStatement[], index: number): void;
      IndexOf(value: System.CodeDom.CodeStatement): number;
      Insert(index: number, value: System.CodeDom.CodeStatement): void;
      Remove(value: System.CodeDom.CodeStatement): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeThisReferenceExpression {
      constructor();
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeThrowExceptionStatement {
      constructor();
      constructor(toThrow: System.CodeDom.CodeExpression);
      ToThrow: System.CodeDom.CodeExpression;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTryCatchFinallyStatement {
      constructor();
      constructor(tryStatements: System.CodeDom.CodeStatement[], catchClauses: System.CodeDom.CodeCatchClause[]);
      constructor(tryStatements: System.CodeDom.CodeStatement[], catchClauses: System.CodeDom.CodeCatchClause[], finallyStatements: System.CodeDom.CodeStatement[]);
      TryStatements: System.CodeDom.CodeStatementCollection;
      CatchClauses: System.CodeDom.CodeCatchClauseCollection;
      FinallyStatements: System.CodeDom.CodeStatementCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeConstructor {
      constructor();
      ReturnType: System.CodeDom.CodeTypeReference;
      Statements: System.CodeDom.CodeStatementCollection;
      Parameters: System.CodeDom.CodeParameterDeclarationExpressionCollection;
      PrivateImplementationType: System.CodeDom.CodeTypeReference;
      ImplementationTypes: System.CodeDom.CodeTypeReferenceCollection;
      ReturnTypeCustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      TypeParameters: System.CodeDom.CodeTypeParameterCollection;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeDeclaration {
      constructor();
      constructor(name: string);
      TypeAttributes: System.Reflection.TypeAttributes;
      BaseTypes: System.CodeDom.CodeTypeReferenceCollection;
      IsClass: boolean;
      IsStruct: boolean;
      IsEnum: boolean;
      IsInterface: boolean;
      IsPartial: boolean;
      Members: System.CodeDom.CodeTypeMemberCollection;
      TypeParameters: System.CodeDom.CodeTypeParameterCollection;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeDeclarationCollection {
      constructor();
      constructor(value: System.CodeDom.CodeTypeDeclarationCollection);
      constructor(value: System.CodeDom.CodeTypeDeclaration[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeTypeDeclaration): number;
      AddRange(value: System.CodeDom.CodeTypeDeclaration[]): void;
      AddRange(value: System.CodeDom.CodeTypeDeclarationCollection): void;
      Contains(value: System.CodeDom.CodeTypeDeclaration): boolean;
      CopyTo(array: System.CodeDom.CodeTypeDeclaration[], index: number): void;
      IndexOf(value: System.CodeDom.CodeTypeDeclaration): number;
      Insert(index: number, value: System.CodeDom.CodeTypeDeclaration): void;
      Remove(value: System.CodeDom.CodeTypeDeclaration): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeDelegate {
      constructor();
      constructor(name: string);
      ReturnType: System.CodeDom.CodeTypeReference;
      Parameters: System.CodeDom.CodeParameterDeclarationExpressionCollection;
      TypeAttributes: System.Reflection.TypeAttributes;
      BaseTypes: System.CodeDom.CodeTypeReferenceCollection;
      IsClass: boolean;
      IsStruct: boolean;
      IsEnum: boolean;
      IsInterface: boolean;
      IsPartial: boolean;
      Members: System.CodeDom.CodeTypeMemberCollection;
      TypeParameters: System.CodeDom.CodeTypeParameterCollection;
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeMember {
      constructor();
      Name: string;
      Attributes: System.CodeDom.MemberAttributes;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      LinePragma: System.CodeDom.CodeLinePragma;
      Comments: System.CodeDom.CodeCommentStatementCollection;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeMemberCollection {
      constructor();
      constructor(value: System.CodeDom.CodeTypeMemberCollection);
      constructor(value: System.CodeDom.CodeTypeMember[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeTypeMember): number;
      AddRange(value: System.CodeDom.CodeTypeMember[]): void;
      AddRange(value: System.CodeDom.CodeTypeMemberCollection): void;
      Contains(value: System.CodeDom.CodeTypeMember): boolean;
      CopyTo(array: System.CodeDom.CodeTypeMember[], index: number): void;
      IndexOf(value: System.CodeDom.CodeTypeMember): number;
      Insert(index: number, value: System.CodeDom.CodeTypeMember): void;
      Remove(value: System.CodeDom.CodeTypeMember): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeOfExpression {
      constructor();
      constructor(type: System.CodeDom.CodeTypeReference);
      constructor(type: string);
      constructor(type: System.Type);
      Type: System.CodeDom.CodeTypeReference;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeParameter {
      constructor();
      constructor(name: string);
      Name: string;
      Constraints: System.CodeDom.CodeTypeReferenceCollection;
      CustomAttributes: System.CodeDom.CodeAttributeDeclarationCollection;
      HasConstructorConstraint: boolean;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeParameterCollection {
      constructor();
      constructor(value: System.CodeDom.CodeTypeParameterCollection);
      constructor(value: System.CodeDom.CodeTypeParameter[]);
      Capacity: number;
      Count: number;
      Add(value: System.CodeDom.CodeTypeParameter): number;
      Add(value: string): void;
      AddRange(value: System.CodeDom.CodeTypeParameter[]): void;
      AddRange(value: System.CodeDom.CodeTypeParameterCollection): void;
      Contains(value: System.CodeDom.CodeTypeParameter): boolean;
      CopyTo(array: System.CodeDom.CodeTypeParameter[], index: number): void;
      IndexOf(value: System.CodeDom.CodeTypeParameter): number;
      Insert(index: number, value: System.CodeDom.CodeTypeParameter): void;
      Remove(value: System.CodeDom.CodeTypeParameter): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeTypeReferenceExpression {
      constructor();
      constructor(type: System.CodeDom.CodeTypeReference);
      constructor(type: string);
      constructor(type: System.Type);
      Type: System.CodeDom.CodeTypeReference;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeVariableDeclarationStatement {
      constructor();
      constructor(type: System.CodeDom.CodeTypeReference, name: string);
      constructor(type: string, name: string);
      constructor(type: System.Type, name: string);
      constructor(type: System.CodeDom.CodeTypeReference, name: string, initExpression: System.CodeDom.CodeExpression);
      constructor(type: string, name: string, initExpression: System.CodeDom.CodeExpression);
      constructor(type: System.Type, name: string, initExpression: System.CodeDom.CodeExpression);
      InitExpression: System.CodeDom.CodeExpression;
      Name: string;
      Type: System.CodeDom.CodeTypeReference;
      LinePragma: System.CodeDom.CodeLinePragma;
      StartDirectives: System.CodeDom.CodeDirectiveCollection;
      EndDirectives: System.CodeDom.CodeDirectiveCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeVariableReferenceExpression {
      constructor();
      constructor(variableName: string);
      VariableName: string;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum FieldDirection {
      In = 0,
      Out = 1,
      Ref = 2,
    }
    export enum MemberAttributes {
      Abstract = 1,
      Final = 2,
      Static = 3,
      Override = 4,
      Const = 5,
      New = 16,
      Overloaded = 256,
      Assembly = 4096,
      FamilyAndAssembly = 8192,
      Family = 12288,
      FamilyOrAssembly = 16384,
      Private = 20480,
      Public = 24576,
      AccessMask = 61440,
      ScopeMask = 15,
      VTableMask = 240,
    }
    export class CodeMethodReferenceExpression {
      constructor();
      constructor(targetObject: System.CodeDom.CodeExpression, methodName: string);
      constructor(targetObject: System.CodeDom.CodeExpression, methodName: string, ...typeParameters: System.CodeDom.CodeTypeReference[]);
      TargetObject: System.CodeDom.CodeExpression;
      MethodName: string;
      TypeArguments: System.CodeDom.CodeTypeReferenceCollection;
      UserData: System.Collections.IDictionary;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export namespace Compiler {
      export class TempFileCollection {
        constructor();
        constructor(tempDir: string);
        constructor(tempDir: string, keepFiles: boolean);
        Count: number;
        TempDir: string;
        BasePath: string;
        KeepFiles: boolean;
        AddExtension(fileExtension: string): string;
        AddExtension(fileExtension: string, keepFile: boolean): string;
        AddFile(fileName: string, keepFile: boolean): void;
        GetEnumerator(): System.Collections.IEnumerator;
        CopyTo(fileNames: string[], start: number): void;
        Delete(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CodeCompiler {
        GenerateCodeFromMember(member: System.CodeDom.CodeTypeMember, writer: System.IO.TextWriter, options: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CodeDomProvider {
        FileExtension: string;
        LanguageOptions: System.CodeDom.Compiler.LanguageOptions;
        Site: System.ComponentModel.ISite;
        Container: System.ComponentModel.IContainer;
        static CreateProvider(language: string, providerOptions: any): System.CodeDom.Compiler.CodeDomProvider;
        static CreateProvider(language: string): System.CodeDom.Compiler.CodeDomProvider;
        static GetLanguageFromExtension(extension: string): string;
        static IsDefinedLanguage(language: string): boolean;
        static IsDefinedExtension(extension: string): boolean;
        static GetCompilerInfo(language: string): System.CodeDom.Compiler.CompilerInfo;
        static GetAllCompilerInfo(): System.CodeDom.Compiler.CompilerInfo[];
        CreateGenerator(): System.CodeDom.Compiler.ICodeGenerator;
        CreateGenerator(output: System.IO.TextWriter): System.CodeDom.Compiler.ICodeGenerator;
        CreateGenerator(fileName: string): System.CodeDom.Compiler.ICodeGenerator;
        CreateCompiler(): System.CodeDom.Compiler.ICodeCompiler;
        CreateParser(): System.CodeDom.Compiler.ICodeParser;
        GetConverter(type: System.Type): System.ComponentModel.TypeConverter;
        CompileAssemblyFromDom(options: System.CodeDom.Compiler.CompilerParameters, ...compilationUnits: System.CodeDom.CodeCompileUnit[]): System.CodeDom.Compiler.CompilerResults;
        CompileAssemblyFromFile(options: System.CodeDom.Compiler.CompilerParameters, ...fileNames: string[]): System.CodeDom.Compiler.CompilerResults;
        CompileAssemblyFromSource(options: System.CodeDom.Compiler.CompilerParameters, ...sources: string[]): System.CodeDom.Compiler.CompilerResults;
        IsValidIdentifier(value: string): boolean;
        CreateEscapedIdentifier(value: string): string;
        CreateValidIdentifier(value: string): string;
        GetTypeOutput(type: System.CodeDom.CodeTypeReference): string;
        Supports(generatorSupport: System.CodeDom.Compiler.GeneratorSupport): boolean;
        GenerateCodeFromExpression(expression: System.CodeDom.CodeExpression, writer: System.IO.TextWriter, options: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        GenerateCodeFromStatement(statement: System.CodeDom.CodeStatement, writer: System.IO.TextWriter, options: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        GenerateCodeFromNamespace(codeNamespace: System.CodeDom.CodeNamespace, writer: System.IO.TextWriter, options: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        GenerateCodeFromCompileUnit(compileUnit: System.CodeDom.CodeCompileUnit, writer: System.IO.TextWriter, options: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        GenerateCodeFromType(codeType: System.CodeDom.CodeTypeDeclaration, writer: System.IO.TextWriter, options: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        GenerateCodeFromMember(member: System.CodeDom.CodeTypeMember, writer: System.IO.TextWriter, options: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        Parse(codeStream: System.IO.TextReader): System.CodeDom.CodeCompileUnit;
        Dispose(): void;
        ToString(): string;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class CodeGenerator {
        GenerateCodeFromMember(member: System.CodeDom.CodeTypeMember, writer: System.IO.TextWriter, options: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        static IsValidLanguageIndependentIdentifier(value: string): boolean;
        static ValidateIdentifiers(e: System.CodeDom.CodeObject): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CodeGeneratorOptions {
        constructor();
        IndentString: string;
        BracingStyle: string;
        ElseOnClosing: boolean;
        BlankLinesBetweenMembers: boolean;
        VerbatimOrder: boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CodeParser {
        Parse(codeStream: System.IO.TextReader): System.CodeDom.CodeCompileUnit;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CompilerError {
        constructor();
        constructor(fileName: string, line: number, column: number, errorNumber: string, errorText: string);
        Line: number;
        Column: number;
        ErrorNumber: string;
        ErrorText: string;
        IsWarning: boolean;
        FileName: string;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class CompilerErrorCollection {
        constructor();
        constructor(value: System.CodeDom.Compiler.CompilerErrorCollection);
        constructor(value: System.CodeDom.Compiler.CompilerError[]);
        HasErrors: boolean;
        HasWarnings: boolean;
        Capacity: number;
        Count: number;
        Add(value: System.CodeDom.Compiler.CompilerError): number;
        AddRange(value: System.CodeDom.Compiler.CompilerError[]): void;
        AddRange(value: System.CodeDom.Compiler.CompilerErrorCollection): void;
        Contains(value: System.CodeDom.Compiler.CompilerError): boolean;
        CopyTo(array: System.CodeDom.Compiler.CompilerError[], index: number): void;
        IndexOf(value: System.CodeDom.Compiler.CompilerError): number;
        Insert(index: number, value: System.CodeDom.Compiler.CompilerError): void;
        Remove(value: System.CodeDom.Compiler.CompilerError): void;
        Clear(): void;
        RemoveAt(index: number): void;
        GetEnumerator(): System.Collections.IEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CompilerInfo {
        CodeDomProviderType: System.Type;
        IsCodeDomProviderTypeValid: boolean;
        GetLanguages(): string[];
        GetExtensions(): string[];
        CreateProvider(): System.CodeDom.Compiler.CodeDomProvider;
        CreateProvider(providerOptions: Record<string, string>): System.CodeDom.Compiler.CodeDomProvider;
        CreateDefaultCompilerParameters(): System.CodeDom.Compiler.CompilerParameters;
        GetHashCode(): number;
        Equals(o: any): boolean;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CompilerParameters {
        constructor();
        constructor(assemblyNames: string[]);
        constructor(assemblyNames: string[], outputName: string);
        constructor(assemblyNames: string[], outputName: string, includeDebugInformation: boolean);
        Evidence: System.Security.Policy.Evidence;
        CoreAssemblyFileName: string;
        GenerateExecutable: boolean;
        GenerateInMemory: boolean;
        ReferencedAssemblies: System.Collections.Specialized.StringCollection;
        MainClass: string;
        OutputAssembly: string;
        TempFiles: System.CodeDom.Compiler.TempFileCollection;
        IncludeDebugInformation: boolean;
        TreatWarningsAsErrors: boolean;
        WarningLevel: number;
        CompilerOptions: string;
        Win32Resource: string;
        EmbeddedResources: System.Collections.Specialized.StringCollection;
        LinkedResources: System.Collections.Specialized.StringCollection;
        UserToken: System.IntPtr;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CompilerResults {
        constructor(tempFiles: System.CodeDom.Compiler.TempFileCollection);
        Evidence: System.Security.Policy.Evidence;
        TempFiles: System.CodeDom.Compiler.TempFileCollection;
        CompiledAssembly: System.Reflection.Assembly;
        Errors: System.CodeDom.Compiler.CompilerErrorCollection;
        Output: System.Collections.Specialized.StringCollection;
        PathToAssembly: string;
        NativeCompilerReturnValue: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum GeneratorSupport {
        ArraysOfArrays = 1,
        EntryPointMethod = 2,
        GotoStatements = 4,
        MultidimensionalArrays = 8,
        StaticConstructors = 16,
        TryCatchStatements = 32,
        ReturnTypeAttributes = 64,
        DeclareValueTypes = 128,
        DeclareEnums = 256,
        DeclareDelegates = 512,
        DeclareInterfaces = 1024,
        DeclareEvents = 2048,
        AssemblyAttributes = 4096,
        ParameterAttributes = 8192,
        ReferenceParameters = 16384,
        ChainedConstructorArguments = 32768,
        NestedTypes = 65536,
        MultipleInterfaceMembers = 131072,
        PublicStaticMembers = 262144,
        ComplexExpressions = 524288,
        Win32Resources = 1048576,
        Resources = 2097152,
        PartialTypes = 4194304,
        GenericTypeReference = 8388608,
        GenericTypeDeclaration = 16777216,
        DeclareIndexerProperties = 33554432,
      }
      export interface ICodeCompiler {
        CompileAssemblyFromDom(options: System.CodeDom.Compiler.CompilerParameters, compilationUnit: System.CodeDom.CodeCompileUnit): System.CodeDom.Compiler.CompilerResults;
        CompileAssemblyFromFile(options: System.CodeDom.Compiler.CompilerParameters, fileName: string): System.CodeDom.Compiler.CompilerResults;
        CompileAssemblyFromSource(options: System.CodeDom.Compiler.CompilerParameters, source: string): System.CodeDom.Compiler.CompilerResults;
        CompileAssemblyFromDomBatch(options: System.CodeDom.Compiler.CompilerParameters, compilationUnits: System.CodeDom.CodeCompileUnit[]): System.CodeDom.Compiler.CompilerResults;
        CompileAssemblyFromFileBatch(options: System.CodeDom.Compiler.CompilerParameters, fileNames: string[]): System.CodeDom.Compiler.CompilerResults;
        CompileAssemblyFromSourceBatch(options: System.CodeDom.Compiler.CompilerParameters, sources: string[]): System.CodeDom.Compiler.CompilerResults;
      }
      export interface ICodeGenerator {
        IsValidIdentifier(value: string): boolean;
        ValidateIdentifier(value: string): void;
        CreateEscapedIdentifier(value: string): string;
        CreateValidIdentifier(value: string): string;
        GetTypeOutput(type: System.CodeDom.CodeTypeReference): string;
        Supports(supports: System.CodeDom.Compiler.GeneratorSupport): boolean;
        GenerateCodeFromExpression(e: System.CodeDom.CodeExpression, w: System.IO.TextWriter, o: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        GenerateCodeFromStatement(e: System.CodeDom.CodeStatement, w: System.IO.TextWriter, o: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        GenerateCodeFromNamespace(e: System.CodeDom.CodeNamespace, w: System.IO.TextWriter, o: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        GenerateCodeFromCompileUnit(e: System.CodeDom.CodeCompileUnit, w: System.IO.TextWriter, o: System.CodeDom.Compiler.CodeGeneratorOptions): void;
        GenerateCodeFromType(e: System.CodeDom.CodeTypeDeclaration, w: System.IO.TextWriter, o: System.CodeDom.Compiler.CodeGeneratorOptions): void;
      }
      export interface ICodeParser {
        Parse(codeStream: System.IO.TextReader): System.CodeDom.CodeCompileUnit;
      }
      export enum LanguageOptions {
        None = 0,
        CaseInsensitive = 1,
      }
      export class IndentedTextWriter {
        constructor(writer: System.IO.TextWriter);
        constructor(writer: System.IO.TextWriter, tabString: string);
        Encoding: System.Text.Encoding;
        NewLine: string;
        Indent: number;
        InnerWriter: System.IO.TextWriter;
        FormatProvider: System.IFormatProvider;
        static DefaultTabString: string;
        Close(): void;
        Flush(): void;
        Write(s: string): void;
        Write(value: boolean): void;
        Write(value: System.Char): void;
        Write(buffer: System.Char[]): void;
        Write(buffer: System.Char[], index: number, count: number): void;
        Write(value: number): void;
        Write(value: number): void;
        Write(value: number): void;
        Write(value: number): void;
        Write(value: any): void;
        Write(format: string, arg0: any): void;
        Write(format: string, arg0: any, arg1: any): void;
        Write(format: string, ...arg: any[]): void;
        WriteLineNoTabs(s: string): void;
        WriteLine(s: string): void;
        WriteLine(): void;
        WriteLine(value: boolean): void;
        WriteLine(value: System.Char): void;
        WriteLine(buffer: System.Char[]): void;
        WriteLine(buffer: System.Char[], index: number, count: number): void;
        WriteLine(value: number): void;
        WriteLine(value: number): void;
        WriteLine(value: number): void;
        WriteLine(value: number): void;
        WriteLine(value: any): void;
        WriteLine(format: string, arg0: any): void;
        WriteLine(format: string, arg0: any, arg1: any): void;
        WriteLine(format: string, ...arg: any[]): void;
        WriteLine(value: number): void;
        Dispose(): void;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        Write(buffer: System.ReadOnlySpan<System.Char>): void;
        Write(value: number): void;
        Write(value: number): void;
        Write(value: number): void;
        Write(format: string, arg0: any, arg1: any, arg2: any): void;
        WriteLine(buffer: System.ReadOnlySpan<System.Char>): void;
        WriteLine(value: number): void;
        WriteLine(value: number): void;
        WriteLine(format: string, arg0: any, arg1: any, arg2: any): void;
        WriteAsync(value: System.Char): System.Threading.Tasks.Task;
        WriteAsync(value: string): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.Char[]): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteLineAsync(value: System.Char): System.Threading.Tasks.Task;
        WriteLineAsync(value: string): System.Threading.Tasks.Task;
        WriteLineAsync(buffer: System.Char[]): System.Threading.Tasks.Task;
        WriteLineAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task;
        WriteLineAsync(buffer: System.ReadOnlyMemory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteLineAsync(): System.Threading.Tasks.Task;
        FlushAsync(): System.Threading.Tasks.Task;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Executor {
        static ExecWait(cmd: string, tempFiles: System.CodeDom.Compiler.TempFileCollection): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
  }
  export namespace Collections {
    export class Comparer {
      constructor(culture: System.Globalization.CultureInfo);
      static Default: System.Collections.Comparer;
      static DefaultInvariant: System.Collections.Comparer;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Compare(a: any, b: any): number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DictionaryEntry {
      constructor(key: any, value: any);
      Key: any; // System.Object
      Value: any; // System.Object
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export interface ICollection {
      Count: number;
      SyncRoot: any; // System.Object
      IsSynchronized: boolean;
      CopyTo(array: System.Array, index: number): void;
    }
    export interface IComparer {
      Compare(x: any, y: any): number;
    }
    export interface IDictionary {
      Keys: System.Collections.ICollection;
      Values: System.Collections.ICollection;
      IsReadOnly: boolean;
      IsFixedSize: boolean;
      Contains(key: any): boolean;
      Add(key: any, value: any): void;
      Clear(): void;
      GetEnumerator(): System.Collections.IDictionaryEnumerator;
      Remove(key: any): void;
    }
    export interface IDictionaryEnumerator {
      Key: any; // System.Object
      Value: any; // System.Object
      Entry: System.Collections.DictionaryEntry;
    }
    export interface IEnumerable {
      GetEnumerator(): System.Collections.IEnumerator;
    }
    export interface IEnumerator {
      Current: any; // System.Object
      MoveNext(): boolean;
      Reset(): void;
    }
    export interface IEqualityComparer {
      Equals(x: any, y: any): boolean;
      GetHashCode(obj: any): number;
    }
    export interface IList {
      IsReadOnly: boolean;
      IsFixedSize: boolean;
      Add(value: any): number;
      Contains(value: any): boolean;
      Clear(): void;
      IndexOf(value: any): number;
      Insert(index: number, value: any): void;
      Remove(value: any): void;
      RemoveAt(index: number): void;
    }
    export interface IStructuralComparable {
      CompareTo(other: any, comparer: System.Collections.IComparer): number;
    }
    export interface IStructuralEquatable {
      Equals(other: any, comparer: System.Collections.IEqualityComparer): boolean;
      GetHashCode(comparer: System.Collections.IEqualityComparer): number;
    }
    export class CaseInsensitiveComparer {
      constructor();
      constructor(culture: System.Globalization.CultureInfo);
      static Default: System.Collections.CaseInsensitiveComparer;
      static DefaultInvariant: System.Collections.CaseInsensitiveComparer;
      Compare(a: any, b: any): number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CaseInsensitiveHashCodeProvider {
      constructor();
      constructor(culture: System.Globalization.CultureInfo);
      static Default: System.Collections.CaseInsensitiveHashCodeProvider;
      static DefaultInvariant: System.Collections.CaseInsensitiveHashCodeProvider;
      GetHashCode(obj: any): number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CollectionBase {
      Capacity: number;
      Count: number;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DictionaryBase {
      Count: number;
      CopyTo(array: System.Array, index: number): void;
      Clear(): void;
      GetEnumerator(): System.Collections.IDictionaryEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Queue {
      constructor();
      constructor(capacity: number);
      constructor(capacity: number, growFactor: number);
      constructor(col: System.Collections.ICollection);
      Count: number;
      IsSynchronized: boolean;
      SyncRoot: any; // System.Object
      Clone(): any;
      Clear(): void;
      CopyTo(array: System.Array, index: number): void;
      Enqueue(obj: any): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Dequeue(): any;
      Peek(): any;
      static Synchronized(queue: System.Collections.Queue): System.Collections.Queue;
      Contains(obj: any): boolean;
      ToArray(): any[];
      TrimToSize(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ReadOnlyCollectionBase {
      Count: number;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SortedList {
      constructor();
      constructor(initialCapacity: number);
      constructor(comparer: System.Collections.IComparer);
      constructor(comparer: System.Collections.IComparer, capacity: number);
      constructor(d: System.Collections.IDictionary);
      constructor(d: System.Collections.IDictionary, comparer: System.Collections.IComparer);
      Capacity: number;
      Count: number;
      Keys: System.Collections.ICollection;
      Values: System.Collections.ICollection;
      IsReadOnly: boolean;
      IsFixedSize: boolean;
      IsSynchronized: boolean;
      SyncRoot: any; // System.Object
      Add(key: any, value: any): void;
      Clear(): void;
      Clone(): any;
      Contains(key: any): boolean;
      ContainsKey(key: any): boolean;
      ContainsValue(value: any): boolean;
      CopyTo(array: System.Array, arrayIndex: number): void;
      GetByIndex(index: number): any;
      GetEnumerator(): System.Collections.IDictionaryEnumerator;
      GetKey(index: number): any;
      GetKeyList(): System.Collections.IList;
      GetValueList(): System.Collections.IList;
      IndexOfKey(key: any): number;
      IndexOfValue(value: any): number;
      RemoveAt(index: number): void;
      Remove(key: any): void;
      SetByIndex(index: number, value: any): void;
      static Synchronized(list: System.Collections.SortedList): System.Collections.SortedList;
      TrimToSize(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Stack {
      constructor();
      constructor(initialCapacity: number);
      constructor(col: System.Collections.ICollection);
      Count: number;
      IsSynchronized: boolean;
      SyncRoot: any; // System.Object
      Clear(): void;
      Clone(): any;
      Contains(obj: any): boolean;
      CopyTo(array: System.Array, index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Peek(): any;
      Pop(): any;
      Push(obj: any): void;
      static Synchronized(stack: System.Collections.Stack): System.Collections.Stack;
      ToArray(): any[];
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BitArray {
      constructor(length: number);
      constructor(length: number, defaultValue: boolean);
      constructor(bytes: Byte[]);
      constructor(values: boolean[]);
      constructor(values: number[]);
      constructor(bits: System.Collections.BitArray);
      Length: number;
      Count: number;
      SyncRoot: any; // System.Object
      IsSynchronized: boolean;
      IsReadOnly: boolean;
      Get(index: number): boolean;
      Set(index: number, value: boolean): void;
      SetAll(value: boolean): void;
      And(value: System.Collections.BitArray): System.Collections.BitArray;
      Or(value: System.Collections.BitArray): System.Collections.BitArray;
      Xor(value: System.Collections.BitArray): System.Collections.BitArray;
      Not(): System.Collections.BitArray;
      RightShift(count: number): System.Collections.BitArray;
      LeftShift(count: number): System.Collections.BitArray;
      CopyTo(array: System.Array, index: number): void;
      Clone(): any;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StructuralComparisons {
      static StructuralComparer: System.Collections.IComparer;
      static StructuralEqualityComparer: System.Collections.IEqualityComparer;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ArrayList {
      constructor();
      constructor(capacity: number);
      constructor(c: System.Collections.ICollection);
      Capacity: number;
      Count: number;
      IsFixedSize: boolean;
      IsReadOnly: boolean;
      IsSynchronized: boolean;
      SyncRoot: any; // System.Object
      static Adapter(list: System.Collections.IList): System.Collections.ArrayList;
      Add(value: any): number;
      AddRange(c: System.Collections.ICollection): void;
      BinarySearch(index: number, count: number, value: any, comparer: System.Collections.IComparer): number;
      BinarySearch(value: any): number;
      BinarySearch(value: any, comparer: System.Collections.IComparer): number;
      Clear(): void;
      Clone(): any;
      Contains(item: any): boolean;
      CopyTo(array: System.Array): void;
      CopyTo(array: System.Array, arrayIndex: number): void;
      CopyTo(index: number, array: System.Array, arrayIndex: number, count: number): void;
      static FixedSize(list: System.Collections.IList): System.Collections.IList;
      static FixedSize(list: System.Collections.ArrayList): System.Collections.ArrayList;
      GetEnumerator(): System.Collections.IEnumerator;
      GetEnumerator(index: number, count: number): System.Collections.IEnumerator;
      IndexOf(value: any): number;
      IndexOf(value: any, startIndex: number): number;
      IndexOf(value: any, startIndex: number, count: number): number;
      Insert(index: number, value: any): void;
      InsertRange(index: number, c: System.Collections.ICollection): void;
      LastIndexOf(value: any): number;
      LastIndexOf(value: any, startIndex: number): number;
      LastIndexOf(value: any, startIndex: number, count: number): number;
      static ReadOnly(list: System.Collections.IList): System.Collections.IList;
      static ReadOnly(list: System.Collections.ArrayList): System.Collections.ArrayList;
      Remove(obj: any): void;
      RemoveAt(index: number): void;
      RemoveRange(index: number, count: number): void;
      static Repeat(value: any, count: number): System.Collections.ArrayList;
      Reverse(): void;
      Reverse(index: number, count: number): void;
      SetRange(index: number, c: System.Collections.ICollection): void;
      GetRange(index: number, count: number): System.Collections.ArrayList;
      Sort(): void;
      Sort(comparer: System.Collections.IComparer): void;
      Sort(index: number, count: number, comparer: System.Collections.IComparer): void;
      static Synchronized(list: System.Collections.IList): System.Collections.IList;
      static Synchronized(list: System.Collections.ArrayList): System.Collections.ArrayList;
      ToArray(): any[];
      ToArray(type: System.Type): System.Array;
      TrimToSize(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Hashtable {
      constructor();
      constructor(capacity: number);
      constructor(capacity: number, loadFactor: number);
      constructor(capacity: number, loadFactor: number, equalityComparer: System.Collections.IEqualityComparer);
      constructor(hcp: System.Collections.IHashCodeProvider, comparer: System.Collections.IComparer);
      constructor(equalityComparer: System.Collections.IEqualityComparer);
      constructor(capacity: number, hcp: System.Collections.IHashCodeProvider, comparer: System.Collections.IComparer);
      constructor(capacity: number, equalityComparer: System.Collections.IEqualityComparer);
      constructor(d: System.Collections.IDictionary);
      constructor(d: System.Collections.IDictionary, loadFactor: number);
      constructor(d: System.Collections.IDictionary, hcp: System.Collections.IHashCodeProvider, comparer: System.Collections.IComparer);
      constructor(d: System.Collections.IDictionary, equalityComparer: System.Collections.IEqualityComparer);
      constructor(capacity: number, loadFactor: number, hcp: System.Collections.IHashCodeProvider, comparer: System.Collections.IComparer);
      constructor(d: System.Collections.IDictionary, loadFactor: number, hcp: System.Collections.IHashCodeProvider, comparer: System.Collections.IComparer);
      constructor(d: System.Collections.IDictionary, loadFactor: number, equalityComparer: System.Collections.IEqualityComparer);
      IsReadOnly: boolean;
      IsFixedSize: boolean;
      IsSynchronized: boolean;
      Keys: System.Collections.ICollection;
      Values: System.Collections.ICollection;
      SyncRoot: any; // System.Object
      Count: number;
      Add(key: any, value: any): void;
      Clear(): void;
      Clone(): any;
      Contains(key: any): boolean;
      ContainsKey(key: any): boolean;
      ContainsValue(value: any): boolean;
      CopyTo(array: System.Array, arrayIndex: number): void;
      GetEnumerator(): System.Collections.IDictionaryEnumerator;
      Remove(key: any): void;
      static Synchronized(table: System.Collections.Hashtable): System.Collections.Hashtable;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      OnDeserialization(sender: any): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IHashCodeProvider {
      GetHashCode(obj: any): number;
    }
    export namespace Concurrent {
      export class ConcurrentQueue<T = any> {
        constructor();
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        IsEmpty: boolean;
        Count: number;
        ToArray(): T[];
        CopyTo(array: T[], index: number): void;
        GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
        Enqueue(item: T): void;
        Clear(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ConcurrentDictionary<TKey = any, TValue = any> {
        constructor();
        constructor(concurrencyLevel: number, capacity: number);
        constructor(collection: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>);
        constructor(comparer: System.Collections.Generic.IEqualityComparer<TKey>);
        constructor(collection: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, comparer: System.Collections.Generic.IEqualityComparer<TKey>);
        constructor(concurrencyLevel: number, collection: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, comparer: System.Collections.Generic.IEqualityComparer<TKey>);
        constructor(concurrencyLevel: number, capacity: number, comparer: System.Collections.Generic.IEqualityComparer<TKey>);
        Count: number;
        IsEmpty: boolean;
        Keys: System.Collections.Generic.ICollection<TKey>;
        Values: System.Collections.Generic.ICollection<TValue>;
        TryAdd(key: TKey, value: TValue): boolean;
        ContainsKey(key: TKey): boolean;
        TryUpdate(key: TKey, newValue: TValue, comparisonValue: TValue): boolean;
        Clear(): void;
        ToArray(): System.Collections.Generic.KeyValuePair<TKey, TValue>[];
        GetEnumerator(): System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>;
        GetOrAdd(key: TKey, valueFactory: ((arg: TKey) => TValue)): TValue;
        GetOrAdd(key: TKey, value: TValue): TValue;
        AddOrUpdate(key: TKey, addValueFactory: ((arg: TKey) => TValue), updateValueFactory: ((arg1: TKey, arg2: TValue) => TValue)): TValue;
        AddOrUpdate(key: TKey, addValue: TValue, updateValueFactory: ((arg1: TKey, arg2: TValue) => TValue)): TValue;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ConcurrentStack<T = any> {
        constructor();
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        IsEmpty: boolean;
        Count: number;
        Clear(): void;
        CopyTo(array: T[], index: number): void;
        Push(item: T): void;
        PushRange(items: T[]): void;
        PushRange(items: T[], startIndex: number, count: number): void;
        TryPopRange(items: T[]): number;
        TryPopRange(items: T[], startIndex: number, count: number): number;
        ToArray(): T[];
        GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface IProducerConsumerCollection<T = any> {
        CopyTo(array: T[], index: number): void;
        TryAdd(item: T): boolean;
        ToArray(): T[];
      }
      export class OrderablePartitioner<TSource = any> {
        KeysOrderedInEachPartition: boolean;
        KeysOrderedAcrossPartitions: boolean;
        KeysNormalized: boolean;
        SupportsDynamicPartitions: boolean;
        GetOrderablePartitions(partitionCount: number): System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<number, TSource>>[];
        GetOrderableDynamicPartitions(): System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<number, TSource>>;
        GetPartitions(partitionCount: number): System.Collections.Generic.IEnumerator<TSource>[];
        GetDynamicPartitions(): System.Collections.Generic.IEnumerable<TSource>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Partitioner<TSource = any> {
        SupportsDynamicPartitions: boolean;
        GetPartitions(partitionCount: number): System.Collections.Generic.IEnumerator<TSource>[];
        GetDynamicPartitions(): System.Collections.Generic.IEnumerable<TSource>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum EnumerablePartitionerOptions {
        None = 0,
        NoBuffering = 1,
      }
      export class BlockingCollection<T = any> {
        constructor();
        constructor(boundedCapacity: number);
        constructor(collection: System.Collections.Concurrent.IProducerConsumerCollection<T>, boundedCapacity: number);
        constructor(collection: System.Collections.Concurrent.IProducerConsumerCollection<T>);
        BoundedCapacity: number;
        IsAddingCompleted: boolean;
        IsCompleted: boolean;
        Count: number;
        Add(item: T): void;
        Add(item: T, cancellationToken: System.Threading.CancellationToken): void;
        TryAdd(item: T): boolean;
        TryAdd(item: T, timeout: System.TimeSpan): boolean;
        TryAdd(item: T, millisecondsTimeout: number): boolean;
        TryAdd(item: T, millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken): boolean;
        Take(): T;
        Take(cancellationToken: System.Threading.CancellationToken): T;
        static AddToAny(collections: any[], item: any): number;
        static AddToAny(collections: any[], item: any, cancellationToken: System.Threading.CancellationToken): number;
        static TryAddToAny(collections: any[], item: any): number;
        static TryAddToAny(collections: any[], item: any, timeout: System.TimeSpan): number;
        static TryAddToAny(collections: any[], item: any, millisecondsTimeout: number): number;
        static TryAddToAny(collections: any[], item: any, millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken): number;
        CompleteAdding(): void;
        Dispose(): void;
        ToArray(): T[];
        CopyTo(array: T[], index: number): void;
        GetConsumingEnumerable(): System.Collections.Generic.IEnumerable<T>;
        GetConsumingEnumerable(cancellationToken: System.Threading.CancellationToken): System.Collections.Generic.IEnumerable<T>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ConcurrentBag<T = any> {
        constructor();
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        Count: number;
        IsEmpty: boolean;
        Add(item: T): void;
        CopyTo(array: T[], index: number): void;
        ToArray(): T[];
        Clear(): void;
        GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace Generic {
      export class Dictionary<TKey = any, TValue = any> {
        constructor();
        constructor(capacity: number);
        constructor(comparer: System.Collections.Generic.IEqualityComparer<TKey>);
        constructor(capacity: number, comparer: System.Collections.Generic.IEqualityComparer<TKey>);
        constructor(dictionary: System.Collections.Generic.IDictionary<TKey, TValue>);
        constructor(dictionary: System.Collections.Generic.IDictionary<TKey, TValue>, comparer: System.Collections.Generic.IEqualityComparer<TKey>);
        constructor(collection: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>);
        constructor(collection: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, comparer: System.Collections.Generic.IEqualityComparer<TKey>);
        Comparer: System.Collections.Generic.IEqualityComparer<TKey>;
        Count: number;
        Keys: System.Collections.Generic.Dictionary<TKey, TValue>;
        Values: System.Collections.Generic.Dictionary<TKey, TValue>;
        Add(key: TKey, value: TValue): void;
        Clear(): void;
        ContainsKey(key: TKey): boolean;
        ContainsValue(value: TValue): boolean;
        GetEnumerator(): System.Collections.Generic.Dictionary<TKey, TValue>;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        OnDeserialization(sender: any): void;
        Remove(key: TKey): boolean;
        TryAdd(key: TKey, value: TValue): boolean;
        EnsureCapacity(capacity: number): number;
        TrimExcess(): void;
        TrimExcess(capacity: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface IAsyncEnumerable<T = any> {
        GetAsyncEnumerator(cancellationToken?: System.Threading.CancellationToken): System.Collections.Generic.IAsyncEnumerator<T>;
      }
      export interface IAsyncEnumerator<T = any> {
        Current: T;
        MoveNextAsync(): System.Threading.Tasks.ValueTask<boolean>;
      }
      export interface ICollection<T = any> {
        Count: number;
        IsReadOnly: boolean;
        Add(item: T): void;
        Clear(): void;
        Contains(item: T): boolean;
        CopyTo(array: T[], arrayIndex: number): void;
        Remove(item: T): boolean;
      }
      export interface IComparer<T = any> {
        Compare(x: T, y: T): number;
      }
      export interface IDictionary<TKey = any, TValue = any> {
        Keys: System.Collections.Generic.ICollection<TKey>;
        Values: System.Collections.Generic.ICollection<TValue>;
        ContainsKey(key: TKey): boolean;
        Add(key: TKey, value: TValue): void;
        Remove(key: TKey): boolean;
      }
      export interface IEnumerable<T = any> {
        GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
      }
      export interface IEnumerator<T = any> {
        Current: T;
      }
      export interface IEqualityComparer<T = any> {
        Equals(x: T, y: T): boolean;
        GetHashCode(obj: T): number;
      }
      export interface IList<T = any> {
        IndexOf(item: T): number;
        Insert(index: number, item: T): void;
        RemoveAt(index: number): void;
      }
      export interface IReadOnlyCollection<T = any> {
        Count: number;
      }
      export interface IReadOnlyDictionary<TKey = any, TValue = any> {
        Keys: System.Collections.Generic.IEnumerable<TKey>;
        Values: System.Collections.Generic.IEnumerable<TValue>;
        ContainsKey(key: TKey): boolean;
      }
      export interface IReadOnlyList<T = any> {
      }
      export class KeyNotFoundException {
        constructor();
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class KeyValuePair<TKey = any, TValue = any> {
        constructor(key: TKey, value: TValue);
        Key: TKey;
        Value: TValue;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class List<T = any> {
        constructor();
        constructor(capacity: number);
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        Capacity: number;
        Count: number;
        Add(item: T): void;
        AddRange(collection: System.Collections.Generic.IEnumerable<T>): void;
        AsReadOnly(): T[];
        BinarySearch(index: number, count: number, item: T, comparer: System.Collections.Generic.IComparer<T>): number;
        BinarySearch(item: T): number;
        BinarySearch(item: T, comparer: System.Collections.Generic.IComparer<T>): number;
        Clear(): void;
        Contains(item: T): boolean;
        CopyTo(array: T[]): void;
        CopyTo(index: number, array: T[], arrayIndex: number, count: number): void;
        CopyTo(array: T[], arrayIndex: number): void;
        Exists(match: ((obj: T) => boolean)): boolean;
        Find(match: ((obj: T) => boolean)): T;
        FindAll(match: ((obj: T) => boolean)): T[];
        FindIndex(match: ((obj: T) => boolean)): number;
        FindIndex(startIndex: number, match: ((obj: T) => boolean)): number;
        FindIndex(startIndex: number, count: number, match: ((obj: T) => boolean)): number;
        FindLast(match: ((obj: T) => boolean)): T;
        FindLastIndex(match: ((obj: T) => boolean)): number;
        FindLastIndex(startIndex: number, match: ((obj: T) => boolean)): number;
        FindLastIndex(startIndex: number, count: number, match: ((obj: T) => boolean)): number;
        ForEach(action: ((obj: T) => void)): void;
        GetEnumerator(): System.Collections.Generic.List<T>;
        GetRange(index: number, count: number): T[];
        IndexOf(item: T): number;
        IndexOf(item: T, index: number): number;
        IndexOf(item: T, index: number, count: number): number;
        Insert(index: number, item: T): void;
        InsertRange(index: number, collection: System.Collections.Generic.IEnumerable<T>): void;
        LastIndexOf(item: T): number;
        LastIndexOf(item: T, index: number): number;
        LastIndexOf(item: T, index: number, count: number): number;
        Remove(item: T): boolean;
        RemoveAll(match: ((obj: T) => boolean)): number;
        RemoveAt(index: number): void;
        RemoveRange(index: number, count: number): void;
        Reverse(): void;
        Reverse(index: number, count: number): void;
        Sort(): void;
        Sort(comparer: System.Collections.Generic.IComparer<T>): void;
        Sort(index: number, count: number, comparer: System.Collections.Generic.IComparer<T>): void;
        Sort(comparison: ((x: T, y: T) => number)): void;
        ToArray(): T[];
        TrimExcess(): void;
        TrueForAll(match: ((obj: T) => boolean)): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CollectionExtensions {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Queue<T = any> {
        constructor();
        constructor(capacity: number);
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        Count: number;
        Clear(): void;
        CopyTo(array: T[], arrayIndex: number): void;
        Enqueue(item: T): void;
        GetEnumerator(): System.Collections.Generic.Queue<T>;
        Dequeue(): T;
        Peek(): T;
        Contains(item: T): boolean;
        ToArray(): T[];
        TrimExcess(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Stack<T = any> {
        constructor();
        constructor(capacity: number);
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        Count: number;
        Clear(): void;
        Contains(item: T): boolean;
        CopyTo(array: T[], arrayIndex: number): void;
        GetEnumerator(): System.Collections.Generic.Stack<T>;
        TrimExcess(): void;
        Peek(): T;
        Pop(): T;
        Push(item: T): void;
        ToArray(): T[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Comparer<T = any> {
        static Default: any; // System.Collections.Generic.Comparer`1[T]
        static Create(comparison: ((x: any, y: any) => number)): any;
        Compare(x: T, y: T): number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class EqualityComparer<T = any> {
        static Default: any; // System.Collections.Generic.EqualityComparer`1[T]
        Equals(x: T, y: T): boolean;
        GetHashCode(obj: T): number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HashSet<T = any> {
        constructor();
        constructor(comparer: System.Collections.Generic.IEqualityComparer<T>);
        constructor(capacity: number);
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        constructor(collection: System.Collections.Generic.IEnumerable<T>, comparer: System.Collections.Generic.IEqualityComparer<T>);
        constructor(capacity: number, comparer: System.Collections.Generic.IEqualityComparer<T>);
        Count: number;
        Comparer: System.Collections.Generic.IEqualityComparer<T>;
        Clear(): void;
        Contains(item: T): boolean;
        CopyTo(array: T[], arrayIndex: number): void;
        Remove(item: T): boolean;
        GetEnumerator(): System.Collections.Generic.HashSet<T>;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        OnDeserialization(sender: any): void;
        Add(item: T): boolean;
        UnionWith(other: System.Collections.Generic.IEnumerable<T>): void;
        IntersectWith(other: System.Collections.Generic.IEnumerable<T>): void;
        ExceptWith(other: System.Collections.Generic.IEnumerable<T>): void;
        SymmetricExceptWith(other: System.Collections.Generic.IEnumerable<T>): void;
        IsSubsetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        IsProperSubsetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        IsSupersetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        IsProperSupersetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        Overlaps(other: System.Collections.Generic.IEnumerable<T>): boolean;
        SetEquals(other: System.Collections.Generic.IEnumerable<T>): boolean;
        CopyTo(array: T[]): void;
        CopyTo(array: T[], arrayIndex: number, count: number): void;
        RemoveWhere(match: ((obj: T) => boolean)): number;
        EnsureCapacity(capacity: number): number;
        TrimExcess(): void;
        static CreateSetComparer(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class LinkedList<T = any> {
        constructor();
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        Count: number;
        First: System.Collections.Generic.LinkedListNode<T>;
        Last: System.Collections.Generic.LinkedListNode<T>;
        AddAfter(node: System.Collections.Generic.LinkedListNode<T>, value: T): System.Collections.Generic.LinkedListNode<T>;
        AddAfter(node: System.Collections.Generic.LinkedListNode<T>, newNode: System.Collections.Generic.LinkedListNode<T>): void;
        AddBefore(node: System.Collections.Generic.LinkedListNode<T>, value: T): System.Collections.Generic.LinkedListNode<T>;
        AddBefore(node: System.Collections.Generic.LinkedListNode<T>, newNode: System.Collections.Generic.LinkedListNode<T>): void;
        AddFirst(value: T): System.Collections.Generic.LinkedListNode<T>;
        AddFirst(node: System.Collections.Generic.LinkedListNode<T>): void;
        AddLast(value: T): System.Collections.Generic.LinkedListNode<T>;
        AddLast(node: System.Collections.Generic.LinkedListNode<T>): void;
        Clear(): void;
        Contains(value: T): boolean;
        CopyTo(array: T[], index: number): void;
        Find(value: T): System.Collections.Generic.LinkedListNode<T>;
        FindLast(value: T): System.Collections.Generic.LinkedListNode<T>;
        GetEnumerator(): System.Collections.Generic.LinkedList<T>;
        Remove(value: T): boolean;
        Remove(node: System.Collections.Generic.LinkedListNode<T>): void;
        RemoveFirst(): void;
        RemoveLast(): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        OnDeserialization(sender: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class LinkedListNode<T = any> {
        constructor(value: T);
        List: System.Collections.Generic.LinkedList<T>;
        Next: System.Collections.Generic.LinkedListNode<T>;
        Previous: System.Collections.Generic.LinkedListNode<T>;
        Value: T;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SortedDictionary<TKey = any, TValue = any> {
        constructor();
        constructor(dictionary: System.Collections.Generic.IDictionary<TKey, TValue>);
        constructor(dictionary: System.Collections.Generic.IDictionary<TKey, TValue>, comparer: System.Collections.Generic.IComparer<TKey>);
        constructor(comparer: System.Collections.Generic.IComparer<TKey>);
        Count: number;
        Comparer: System.Collections.Generic.IComparer<TKey>;
        Keys: System.Collections.Generic.SortedDictionary<TKey, TValue>;
        Values: System.Collections.Generic.SortedDictionary<TKey, TValue>;
        Add(key: TKey, value: TValue): void;
        Clear(): void;
        ContainsKey(key: TKey): boolean;
        ContainsValue(value: TValue): boolean;
        CopyTo(array: System.Collections.Generic.KeyValuePair<TKey, TValue>[], index: number): void;
        GetEnumerator(): System.Collections.Generic.SortedDictionary<TKey, TValue>;
        Remove(key: TKey): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SortedList<TKey = any, TValue = any> {
        constructor();
        constructor(capacity: number);
        constructor(comparer: System.Collections.Generic.IComparer<TKey>);
        constructor(capacity: number, comparer: System.Collections.Generic.IComparer<TKey>);
        constructor(dictionary: System.Collections.Generic.IDictionary<TKey, TValue>);
        constructor(dictionary: System.Collections.Generic.IDictionary<TKey, TValue>, comparer: System.Collections.Generic.IComparer<TKey>);
        Capacity: number;
        Comparer: System.Collections.Generic.IComparer<TKey>;
        Count: number;
        Keys: TKey[];
        Values: TValue[];
        Add(key: TKey, value: TValue): void;
        Clear(): void;
        ContainsKey(key: TKey): boolean;
        ContainsValue(value: TValue): boolean;
        GetEnumerator(): System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>;
        IndexOfKey(key: TKey): number;
        IndexOfValue(value: TValue): number;
        RemoveAt(index: number): void;
        Remove(key: TKey): boolean;
        TrimExcess(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SortedSet<T = any> {
        constructor();
        constructor(comparer: System.Collections.Generic.IComparer<T>);
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        constructor(collection: System.Collections.Generic.IEnumerable<T>, comparer: System.Collections.Generic.IComparer<T>);
        Count: number;
        Comparer: System.Collections.Generic.IComparer<T>;
        Min: T;
        Max: T;
        Add(item: T): boolean;
        Remove(item: T): boolean;
        Clear(): void;
        Contains(item: T): boolean;
        CopyTo(array: T[]): void;
        CopyTo(array: T[], index: number): void;
        CopyTo(array: T[], index: number, count: number): void;
        GetEnumerator(): System.Collections.Generic.SortedSet<T>;
        static CreateSetComparer(): any;
        static CreateSetComparer(memberEqualityComparer: any): any;
        UnionWith(other: System.Collections.Generic.IEnumerable<T>): void;
        IntersectWith(other: System.Collections.Generic.IEnumerable<T>): void;
        ExceptWith(other: System.Collections.Generic.IEnumerable<T>): void;
        SymmetricExceptWith(other: System.Collections.Generic.IEnumerable<T>): void;
        IsSubsetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        IsProperSubsetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        IsSupersetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        IsProperSupersetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        SetEquals(other: System.Collections.Generic.IEnumerable<T>): boolean;
        Overlaps(other: System.Collections.Generic.IEnumerable<T>): boolean;
        RemoveWhere(match: ((obj: T) => boolean)): number;
        Reverse(): System.Collections.Generic.IEnumerable<T>;
        GetViewBetween(lowerValue: T, upperValue: T): System.Collections.Generic.SortedSet<T>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface ISet<T = any> {
        Add(item: T): boolean;
        UnionWith(other: System.Collections.Generic.IEnumerable<T>): void;
        IntersectWith(other: System.Collections.Generic.IEnumerable<T>): void;
        ExceptWith(other: System.Collections.Generic.IEnumerable<T>): void;
        SymmetricExceptWith(other: System.Collections.Generic.IEnumerable<T>): void;
        IsSubsetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        IsSupersetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        IsProperSupersetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        IsProperSubsetOf(other: System.Collections.Generic.IEnumerable<T>): boolean;
        Overlaps(other: System.Collections.Generic.IEnumerable<T>): boolean;
        SetEquals(other: System.Collections.Generic.IEnumerable<T>): boolean;
      }
    }
    export namespace ObjectModel {
      export class Collection<T = any> {
        constructor();
        constructor(list: T[]);
        Count: number;
        Add(item: T): void;
        Clear(): void;
        CopyTo(array: T[], index: number): void;
        Contains(item: T): boolean;
        GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
        IndexOf(item: T): number;
        Insert(index: number, item: T): void;
        Remove(item: T): boolean;
        RemoveAt(index: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ReadOnlyCollection<T = any> {
        constructor(list: T[]);
        Count: number;
        Contains(value: T): boolean;
        CopyTo(array: T[], index: number): void;
        GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
        IndexOf(value: T): number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class KeyedCollection<TKey = any, TItem = any> {
        Comparer: System.Collections.Generic.IEqualityComparer<TKey>;
        Count: number;
        Contains(key: TKey): boolean;
        Remove(key: TKey): boolean;
        Add(item: TItem): void;
        Clear(): void;
        CopyTo(array: TItem[], index: number): void;
        Contains(item: TItem): boolean;
        GetEnumerator(): System.Collections.Generic.IEnumerator<TItem>;
        IndexOf(item: TItem): number;
        Insert(index: number, item: TItem): void;
        Remove(item: TItem): boolean;
        RemoveAt(index: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ReadOnlyDictionary<TKey = any, TValue = any> {
        constructor(dictionary: System.Collections.Generic.IDictionary<TKey, TValue>);
        Keys: System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>;
        Values: System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>;
        Count: number;
        ContainsKey(key: TKey): boolean;
        GetEnumerator(): System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ObservableCollection<T = any> {
        constructor();
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        constructor(list: T[]);
        Count: number;
        Move(oldIndex: number, newIndex: number): void;
        Add(item: T): void;
        Clear(): void;
        CopyTo(array: T[], index: number): void;
        Contains(item: T): boolean;
        GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
        IndexOf(item: T): number;
        Insert(index: number, item: T): void;
        Remove(item: T): boolean;
        RemoveAt(index: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ReadOnlyObservableCollection<T = any> {
        constructor(list: T[]);
        Count: number;
        Contains(value: T): boolean;
        CopyTo(array: T[], index: number): void;
        GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
        IndexOf(value: T): number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace Specialized {
      export class CollectionsUtil {
        constructor();
        static CreateCaseInsensitiveHashtable(): System.Collections.Hashtable;
        static CreateCaseInsensitiveHashtable(capacity: number): System.Collections.Hashtable;
        static CreateCaseInsensitiveHashtable(d: System.Collections.IDictionary): System.Collections.Hashtable;
        static CreateCaseInsensitiveSortedList(): System.Collections.SortedList;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class BitVector32 {
        constructor(data: number);
        constructor(value: System.Collections.Specialized.BitVector32);
        Data: number;
        static CreateMask(): number;
        static CreateMask(previous: number): number;
        static CreateSection(maxValue: number): System.Collections.Specialized.BitVector32_Section;
        static CreateSection(maxValue: number, previous: System.Collections.Specialized.BitVector32_Section): System.Collections.Specialized.BitVector32_Section;
        Equals(o: any): boolean;
        GetHashCode(): number;
        static ToString(value: System.Collections.Specialized.BitVector32): string;
        ToString(): string;
        GetType(): System.Type;
      }
      export class BitVector32_Section {
        Mask: number;
        Offset: number;
        Equals(o: any): boolean;
        Equals(obj: System.Collections.Specialized.BitVector32_Section): boolean;
        GetHashCode(): number;
        static ToString(value: System.Collections.Specialized.BitVector32_Section): string;
        ToString(): string;
        GetType(): System.Type;
      }
      export class HybridDictionary {
        constructor();
        constructor(initialSize: number);
        constructor(caseInsensitive: boolean);
        constructor(initialSize: number, caseInsensitive: boolean);
        Count: number;
        Keys: System.Collections.ICollection;
        IsReadOnly: boolean;
        IsFixedSize: boolean;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        Values: System.Collections.ICollection;
        Add(key: any, value: any): void;
        Clear(): void;
        Contains(key: any): boolean;
        CopyTo(array: System.Array, index: number): void;
        GetEnumerator(): System.Collections.IDictionaryEnumerator;
        Remove(key: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface IOrderedDictionary {
        GetEnumerator(): System.Collections.IDictionaryEnumerator;
        Insert(index: number, key: any, value: any): void;
        RemoveAt(index: number): void;
      }
      export class ListDictionary {
        constructor();
        constructor(comparer: System.Collections.IComparer);
        Count: number;
        Keys: System.Collections.ICollection;
        IsReadOnly: boolean;
        IsFixedSize: boolean;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        Values: System.Collections.ICollection;
        Add(key: any, value: any): void;
        Clear(): void;
        Contains(key: any): boolean;
        CopyTo(array: System.Array, index: number): void;
        GetEnumerator(): System.Collections.IDictionaryEnumerator;
        Remove(key: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ListDictionary_DictionaryNode {
        constructor();
        key: any; // System.Object
        value: any; // System.Object
        next: System.Collections.Specialized.ListDictionary_DictionaryNode;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class NameValueCollection {
        constructor();
        constructor(col: System.Collections.Specialized.NameValueCollection);
        constructor(hashProvider: System.Collections.IHashCodeProvider, comparer: System.Collections.IComparer);
        constructor(capacity: number);
        constructor(equalityComparer: System.Collections.IEqualityComparer);
        constructor(capacity: number, equalityComparer: System.Collections.IEqualityComparer);
        constructor(capacity: number, col: System.Collections.Specialized.NameValueCollection);
        constructor(capacity: number, hashProvider: System.Collections.IHashCodeProvider, comparer: System.Collections.IComparer);
        AllKeys: string[];
        Count: number;
        Keys: System.Collections.Specialized.NameObjectCollectionBase_KeysCollection;
        Add(c: System.Collections.Specialized.NameValueCollection): void;
        Clear(): void;
        CopyTo(dest: System.Array, index: number): void;
        HasKeys(): boolean;
        Add(name: string, value: string): void;
        Get(name: string): string;
        GetValues(name: string): string[];
        Set(name: string, value: string): void;
        Remove(name: string): void;
        Get(index: number): string;
        GetValues(index: number): string[];
        GetKey(index: number): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        OnDeserialization(sender: any): void;
        GetEnumerator(): System.Collections.IEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class OrderedDictionary {
        constructor();
        constructor(capacity: number);
        constructor(comparer: System.Collections.IEqualityComparer);
        constructor(capacity: number, comparer: System.Collections.IEqualityComparer);
        Count: number;
        IsReadOnly: boolean;
        Keys: System.Collections.ICollection;
        Values: System.Collections.ICollection;
        Add(key: any, value: any): void;
        Clear(): void;
        AsReadOnly(): System.Collections.Specialized.OrderedDictionary;
        Contains(key: any): boolean;
        CopyTo(array: System.Array, index: number): void;
        Insert(index: number, key: any, value: any): void;
        RemoveAt(index: number): void;
        Remove(key: any): void;
        GetEnumerator(): System.Collections.IDictionaryEnumerator;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class StringCollection {
        constructor();
        Count: number;
        IsReadOnly: boolean;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        Add(value: string): number;
        AddRange(value: string[]): void;
        Clear(): void;
        Contains(value: string): boolean;
        CopyTo(array: string[], index: number): void;
        GetEnumerator(): System.Collections.Specialized.StringEnumerator;
        IndexOf(value: string): number;
        Insert(index: number, value: string): void;
        Remove(value: string): void;
        RemoveAt(index: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class StringEnumerator {
        Current: string;
        MoveNext(): boolean;
        Reset(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class StringDictionary {
        constructor();
        Count: number;
        IsSynchronized: boolean;
        Keys: System.Collections.ICollection;
        SyncRoot: any; // System.Object
        Values: System.Collections.ICollection;
        Add(key: string, value: string): void;
        Clear(): void;
        ContainsKey(key: string): boolean;
        ContainsValue(value: string): boolean;
        CopyTo(array: System.Array, index: number): void;
        GetEnumerator(): System.Collections.IEnumerator;
        Remove(key: string): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface INotifyCollectionChanged {
      }
      export enum NotifyCollectionChangedAction {
        Add = 0,
        Remove = 1,
        Replace = 2,
        Move = 3,
        Reset = 4,
      }
      export class NotifyCollectionChangedEventArgs {
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, changedItem: any);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, changedItem: any, index: number);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, changedItems: System.Collections.IList);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, changedItems: System.Collections.IList, startingIndex: number);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, newItem: any, oldItem: any);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, newItem: any, oldItem: any, index: number);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, newItems: System.Collections.IList, oldItems: System.Collections.IList);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, newItems: System.Collections.IList, oldItems: System.Collections.IList, startingIndex: number);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, changedItem: any, index: number, oldIndex: number);
        constructor(action: System.Collections.Specialized.NotifyCollectionChangedAction, changedItems: System.Collections.IList, index: number, oldIndex: number);
        Action: System.Collections.Specialized.NotifyCollectionChangedAction;
        NewItems: System.Collections.IList;
        OldItems: System.Collections.IList;
        NewStartingIndex: number;
        OldStartingIndex: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class NotifyCollectionChangedEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.Collections.Specialized.NotifyCollectionChangedEventArgs): void;
        BeginInvoke(sender: any, e: System.Collections.Specialized.NotifyCollectionChangedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class NameObjectCollectionBase {
        Count: number;
        Keys: System.Collections.Specialized.NameObjectCollectionBase_KeysCollection;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        OnDeserialization(sender: any): void;
        GetEnumerator(): System.Collections.IEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class NameObjectCollectionBase_KeysCollection {
        Count: number;
        Get(index: number): string;
        GetEnumerator(): System.Collections.IEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
  }
  export namespace ComponentModel {
    export enum EditorBrowsableState {
      Always = 0,
      Never = 1,
      Advanced = 2,
    }
    export class AsyncOperation {
      UserSuppliedState: any; // System.Object
      SynchronizationContext: System.Threading.SynchronizationContext;
      Post(d: ((state: any) => void), arg: any): void;
      PostOperationCompleted(d: ((state: any) => void), arg: any): void;
      OperationCompleted(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AsyncOperationManager {
      static SynchronizationContext: System.Threading.SynchronizationContext;
      static CreateOperation(userSuppliedState: any): System.ComponentModel.AsyncOperation;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BackgroundWorker {
      constructor();
      CancellationPending: boolean;
      IsBusy: boolean;
      WorkerReportsProgress: boolean;
      WorkerSupportsCancellation: boolean;
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      CancelAsync(): void;
      ReportProgress(percentProgress: number): void;
      ReportProgress(percentProgress: number, userState: any): void;
      RunWorkerAsync(): void;
      RunWorkerAsync(argument: any): void;
      Dispose(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ComponentCollection {
      constructor(components: System.ComponentModel.IComponent[]);
      Count: number;
      CopyTo(array: System.ComponentModel.IComponent[], index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum DesignerSerializationVisibility {
      Hidden = 0,
      Visible = 1,
      Content = 2,
    }
    export class EventHandlerList {
      constructor();
      AddHandler(key: any, value: System.Delegate): void;
      AddHandlers(listToAddFrom: System.ComponentModel.EventHandlerList): void;
      Dispose(): void;
      RemoveHandler(key: any, value: System.Delegate): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IContainer {
      Components: System.ComponentModel.ComponentCollection;
      Add(component: System.ComponentModel.IComponent): void;
      Add(component: System.ComponentModel.IComponent, name: string): void;
      Remove(component: System.ComponentModel.IComponent): void;
    }
    export interface ISite {
      Component: System.ComponentModel.IComponent;
      Container: System.ComponentModel.IContainer;
      DesignMode: boolean;
      Name: string;
    }
    export interface ISupportInitialize {
      BeginInit(): void;
      EndInit(): void;
    }
    export interface ISynchronizeInvoke {
      InvokeRequired: boolean;
      BeginInvoke(method: System.Delegate, args: any[]): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): any;
      Invoke(method: System.Delegate, args: any[]): any;
    }
    export class InvalidEnumArgumentException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      constructor(argumentName: string, invalidValue: number, enumClass: System.Type);
      Message: string;
      ParamName: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class AddingNewEventArgs {
      constructor();
      constructor(newObject: any);
      NewObject: any; // System.Object
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AddingNewEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.AddingNewEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.AddingNewEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ArrayConverter {
      constructor();
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AttributeCollection {
      constructor(...attributes: any[]);
      Count: number;
      static Empty: System.ComponentModel.AttributeCollection;
      static FromExisting(existing: System.ComponentModel.AttributeCollection, ...newAttributes: any[]): System.ComponentModel.AttributeCollection;
      Contains(attribute: any): boolean;
      Contains(attributes: any[]): boolean;
      GetEnumerator(): System.Collections.IEnumerator;
      Matches(attribute: any): boolean;
      Matches(attributes: any[]): boolean;
      CopyTo(array: System.Array, index: number): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ComponentEditor {
      EditComponent(component: any): boolean;
      EditComponent(context: System.ComponentModel.ITypeDescriptorContext, component: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BaseNumberConverter {
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum BindableSupport {
      No = 0,
      Yes = 1,
      Default = 2,
    }
    export enum BindingDirection {
      OneWay = 0,
      TwoWay = 1,
    }
    export class BindingList<T = any> {
      constructor();
      constructor(list: T[]);
      RaiseListChangedEvents: boolean;
      AllowNew: boolean;
      AllowEdit: boolean;
      AllowRemove: boolean;
      Count: number;
      ResetBindings(): void;
      ResetItem(position: number): void;
      CancelNew(itemIndex: number): void;
      EndNew(itemIndex: number): void;
      AddNew(): T;
      Add(item: T): void;
      Clear(): void;
      CopyTo(array: T[], index: number): void;
      Contains(item: T): boolean;
      GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
      IndexOf(item: T): number;
      Insert(index: number, item: T): void;
      Remove(item: T): boolean;
      RemoveAt(index: number): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BooleanConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesSupported(): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ByteConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CancelEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.CancelEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.CancelEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CharConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum CollectionChangeAction {
      Add = 1,
      Remove = 2,
      Refresh = 3,
    }
    export class CollectionChangeEventArgs {
      constructor(action: System.ComponentModel.CollectionChangeAction, element: any);
      Action: System.ComponentModel.CollectionChangeAction;
      Element: any; // System.Object
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CollectionChangeEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.CollectionChangeEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.CollectionChangeEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ComponentResourceManager {
      constructor();
      constructor(t: System.Type);
      BaseName: string;
      IgnoreCase: boolean;
      ResourceSetType: System.Type;
      ApplyResources(value: any, objectName: string): void;
      ApplyResources(value: any, objectName: string, culture: System.Globalization.CultureInfo): void;
      ReleaseAllResources(): void;
      GetResourceSet(culture: System.Globalization.CultureInfo, createIfNotExists: boolean, tryParents: boolean): System.Resources.ResourceSet;
      GetString(name: string): string;
      GetString(name: string, culture: System.Globalization.CultureInfo): string;
      GetObject(name: string): any;
      GetObject(name: string, culture: System.Globalization.CultureInfo): any;
      GetStream(name: string): System.IO.UnmanagedMemoryStream;
      GetStream(name: string, culture: System.Globalization.CultureInfo): System.IO.UnmanagedMemoryStream;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ContainerFilterService {
      FilterComponents(components: System.ComponentModel.ComponentCollection): System.ComponentModel.ComponentCollection;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CultureInfoConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesSupported(): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CustomTypeDescriptor {
      GetAttributes(): System.ComponentModel.AttributeCollection;
      GetClassName(): string;
      GetComponentName(): string;
      GetConverter(): System.ComponentModel.TypeConverter;
      GetDefaultEvent(): System.ComponentModel.EventDescriptor;
      GetDefaultProperty(): System.ComponentModel.PropertyDescriptor;
      GetEditor(editorBaseType: System.Type): any;
      GetEvents(): System.ComponentModel.EventDescriptorCollection;
      GetEvents(attributes: any[]): System.ComponentModel.EventDescriptorCollection;
      GetProperties(): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertyOwner(pd: System.ComponentModel.PropertyDescriptor): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum DataObjectMethodType {
      Fill = 0,
      Select = 1,
      Update = 2,
      Insert = 3,
      Delete = 4,
    }
    export class DateTimeConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DecimalConverter {
      constructor();
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum InheritanceLevel {
      Inherited = 1,
      InheritedReadOnly = 2,
      NotInherited = 3,
    }
    export enum PropertyTabScope {
      Static = 0,
      Global = 1,
      Document = 2,
      Component = 3,
    }
    export class DoubleConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EventDescriptor {
      ComponentType: System.Type;
      EventType: System.Type;
      IsMulticast: boolean;
      Attributes: System.ComponentModel.AttributeCollection;
      Category: string;
      Description: string;
      IsBrowsable: boolean;
      Name: string;
      DesignTimeOnly: boolean;
      DisplayName: string;
      AddEventHandler(component: any, value: System.Delegate): void;
      RemoveEventHandler(component: any, value: System.Delegate): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EventDescriptorCollection {
      constructor(events: System.ComponentModel.EventDescriptor[]);
      constructor(events: System.ComponentModel.EventDescriptor[], readOnly: boolean);
      Count: number;
      static Empty: System.ComponentModel.EventDescriptorCollection;
      Add(value: System.ComponentModel.EventDescriptor): number;
      Clear(): void;
      Contains(value: System.ComponentModel.EventDescriptor): boolean;
      Find(name: string, ignoreCase: boolean): System.ComponentModel.EventDescriptor;
      IndexOf(value: System.ComponentModel.EventDescriptor): number;
      Insert(index: number, value: System.ComponentModel.EventDescriptor): void;
      Remove(value: System.ComponentModel.EventDescriptor): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Sort(): System.ComponentModel.EventDescriptorCollection;
      Sort(names: string[]): System.ComponentModel.EventDescriptorCollection;
      Sort(names: string[], comparer: System.Collections.IComparer): System.ComponentModel.EventDescriptorCollection;
      Sort(comparer: System.Collections.IComparer): System.ComponentModel.EventDescriptorCollection;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ExpandableObjectConverter {
      constructor();
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class GuidConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class HandledEventArgs {
      constructor();
      constructor(defaultHandledValue: boolean);
      Handled: boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class HandledEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.HandledEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.HandledEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IBindingList {
      AllowNew: boolean;
      AllowEdit: boolean;
      AllowRemove: boolean;
      SupportsChangeNotification: boolean;
      SupportsSearching: boolean;
      SupportsSorting: boolean;
      IsSorted: boolean;
      SortProperty: System.ComponentModel.PropertyDescriptor;
      SortDirection: System.ComponentModel.ListSortDirection;
      AddNew(): any;
      AddIndex(property: System.ComponentModel.PropertyDescriptor): void;
      ApplySort(property: System.ComponentModel.PropertyDescriptor, direction: System.ComponentModel.ListSortDirection): void;
      Find(property: System.ComponentModel.PropertyDescriptor, key: any): number;
      RemoveIndex(property: System.ComponentModel.PropertyDescriptor): void;
      RemoveSort(): void;
    }
    export interface IBindingListView {
      Filter: string;
      SortDescriptions: System.ComponentModel.ListSortDescriptionCollection;
      SupportsAdvancedSorting: boolean;
      SupportsFiltering: boolean;
      ApplySort(sorts: System.ComponentModel.ListSortDescriptionCollection): void;
      RemoveFilter(): void;
    }
    export interface ICancelAddNew {
      CancelNew(itemIndex: number): void;
      EndNew(itemIndex: number): void;
    }
    export interface IComNativeDescriptorHandler {
      GetAttributes(component: any): System.ComponentModel.AttributeCollection;
      GetClassName(component: any): string;
      GetConverter(component: any): System.ComponentModel.TypeConverter;
      GetDefaultEvent(component: any): System.ComponentModel.EventDescriptor;
      GetDefaultProperty(component: any): System.ComponentModel.PropertyDescriptor;
      GetEditor(component: any, baseEditorType: System.Type): any;
      GetName(component: any): string;
      GetEvents(component: any): System.ComponentModel.EventDescriptorCollection;
      GetEvents(component: any, attributes: any[]): System.ComponentModel.EventDescriptorCollection;
      GetProperties(component: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
    }
    export interface ICustomTypeDescriptor {
      GetAttributes(): System.ComponentModel.AttributeCollection;
      GetClassName(): string;
      GetComponentName(): string;
      GetConverter(): System.ComponentModel.TypeConverter;
      GetDefaultEvent(): System.ComponentModel.EventDescriptor;
      GetDefaultProperty(): System.ComponentModel.PropertyDescriptor;
      GetEditor(editorBaseType: System.Type): any;
      GetEvents(): System.ComponentModel.EventDescriptorCollection;
      GetEvents(attributes: any[]): System.ComponentModel.EventDescriptorCollection;
      GetProperties(): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertyOwner(pd: System.ComponentModel.PropertyDescriptor): any;
    }
    export interface IDataErrorInfo {
      Error: string;
    }
    export interface IExtenderProvider {
      CanExtend(extendee: any): boolean;
    }
    export interface IIntellisenseBuilder {
      Name: string;
    }
    export interface IListSource {
      ContainsListCollection: boolean;
      GetList(): System.Collections.IList;
    }
    export interface INestedContainer {
      Owner: System.ComponentModel.IComponent;
    }
    export interface INestedSite {
      FullName: string;
    }
    export interface IRaiseItemChangedEvents {
      RaisesItemChangedEvents: boolean;
    }
    export interface ISupportInitializeNotification {
      IsInitialized: boolean;
    }
    export interface ITypeDescriptorContext {
      Container: System.ComponentModel.IContainer;
      Instance: any; // System.Object
      PropertyDescriptor: System.ComponentModel.PropertyDescriptor;
      OnComponentChanging(): boolean;
      OnComponentChanged(): void;
    }
    export interface ITypedList {
      GetListName(listAccessors: System.ComponentModel.PropertyDescriptor[]): string;
      GetItemProperties(listAccessors: System.ComponentModel.PropertyDescriptor[]): System.ComponentModel.PropertyDescriptorCollection;
    }
    export class InstanceCreationEditor {
      Text: string;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, instanceType: System.Type): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Int16Converter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Int32Converter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Int64Converter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class InvalidAsynchronousStateException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      ParamName: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class LicFileLicenseProvider {
      constructor();
      GetLicense(context: System.ComponentModel.LicenseContext, type: System.Type, instance: any, allowExceptions: boolean): System.ComponentModel.License;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class License {
      LicenseKey: string;
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class LicenseContext {
      constructor();
      UsageMode: System.ComponentModel.LicenseUsageMode;
      GetSavedLicenseKey(type: System.Type, resourceAssembly: System.Reflection.Assembly): string;
      GetService(type: System.Type): any;
      SetSavedLicenseKey(type: System.Type, key: string): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class LicenseManager {
      static CurrentContext: System.ComponentModel.LicenseContext;
      static UsageMode: System.ComponentModel.LicenseUsageMode;
      static CreateWithContext(type: System.Type, creationContext: System.ComponentModel.LicenseContext): any;
      static CreateWithContext(type: System.Type, creationContext: System.ComponentModel.LicenseContext, args: any[]): any;
      static IsLicensed(type: System.Type): boolean;
      static IsValid(type: System.Type): boolean;
      static LockContext(contextUser: any): void;
      static UnlockContext(contextUser: any): void;
      static Validate(type: System.Type): void;
      static Validate(type: System.Type, instance: any): System.ComponentModel.License;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class LicenseProvider {
      GetLicense(context: System.ComponentModel.LicenseContext, type: System.Type, instance: any, allowExceptions: boolean): System.ComponentModel.License;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum LicenseUsageMode {
      Runtime = 0,
      Designtime = 1,
    }
    export class ListChangedEventArgs {
      constructor(listChangedType: System.ComponentModel.ListChangedType, newIndex: number);
      constructor(listChangedType: System.ComponentModel.ListChangedType, newIndex: number, propDesc: System.ComponentModel.PropertyDescriptor);
      constructor(listChangedType: System.ComponentModel.ListChangedType, propDesc: System.ComponentModel.PropertyDescriptor);
      constructor(listChangedType: System.ComponentModel.ListChangedType, newIndex: number, oldIndex: number);
      ListChangedType: System.ComponentModel.ListChangedType;
      NewIndex: number;
      OldIndex: number;
      PropertyDescriptor: System.ComponentModel.PropertyDescriptor;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ListChangedEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.ListChangedEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.ListChangedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum ListChangedType {
      Reset = 0,
      ItemAdded = 1,
      ItemDeleted = 2,
      ItemMoved = 3,
      ItemChanged = 4,
      PropertyDescriptorAdded = 5,
      PropertyDescriptorDeleted = 6,
      PropertyDescriptorChanged = 7,
    }
    export class ListSortDescription {
      constructor(property: System.ComponentModel.PropertyDescriptor, direction: System.ComponentModel.ListSortDirection);
      PropertyDescriptor: System.ComponentModel.PropertyDescriptor;
      SortDirection: System.ComponentModel.ListSortDirection;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ListSortDescriptionCollection {
      constructor();
      constructor(sorts: System.ComponentModel.ListSortDescription[]);
      Count: number;
      Contains(value: any): boolean;
      IndexOf(value: any): number;
      CopyTo(array: System.Array, index: number): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum ListSortDirection {
      Ascending = 0,
      Descending = 1,
    }
    export class MarshalByValueComponent {
      constructor();
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      DesignMode: boolean;
      Dispose(): void;
      GetService(service: System.Type): any;
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class MaskedTextProvider {
      constructor(mask: string);
      constructor(mask: string, restrictToAscii: boolean);
      constructor(mask: string, culture: System.Globalization.CultureInfo);
      constructor(mask: string, culture: System.Globalization.CultureInfo, restrictToAscii: boolean);
      constructor(mask: string, passwordChar: System.Char, allowPromptAsInput: boolean);
      constructor(mask: string, culture: System.Globalization.CultureInfo, passwordChar: System.Char, allowPromptAsInput: boolean);
      constructor(mask: string, culture: System.Globalization.CultureInfo, allowPromptAsInput: boolean, promptChar: System.Char, passwordChar: System.Char, restrictToAscii: boolean);
      AllowPromptAsInput: boolean;
      AssignedEditPositionCount: number;
      AvailableEditPositionCount: number;
      Culture: System.Globalization.CultureInfo;
      static DefaultPasswordChar: System.Char;
      EditPositionCount: number;
      EditPositions: System.Collections.IEnumerator;
      IncludeLiterals: boolean;
      IncludePrompt: boolean;
      AsciiOnly: boolean;
      IsPassword: boolean;
      static InvalidIndex: number;
      LastAssignedPosition: number;
      Length: number;
      Mask: string;
      MaskCompleted: boolean;
      MaskFull: boolean;
      PasswordChar: System.Char;
      PromptChar: System.Char;
      ResetOnPrompt: boolean;
      ResetOnSpace: boolean;
      SkipLiterals: boolean;
      Clone(): any;
      Add(input: System.Char): boolean;
      Add(input: string): boolean;
      Clear(): void;
      FindAssignedEditPositionFrom(position: number, direction: boolean): number;
      FindAssignedEditPositionInRange(startPosition: number, endPosition: number, direction: boolean): number;
      FindEditPositionFrom(position: number, direction: boolean): number;
      FindEditPositionInRange(startPosition: number, endPosition: number, direction: boolean): number;
      FindNonEditPositionFrom(position: number, direction: boolean): number;
      FindNonEditPositionInRange(startPosition: number, endPosition: number, direction: boolean): number;
      FindUnassignedEditPositionFrom(position: number, direction: boolean): number;
      FindUnassignedEditPositionInRange(startPosition: number, endPosition: number, direction: boolean): number;
      static GetOperationResultFromHint(hint: System.ComponentModel.MaskedTextResultHint): boolean;
      InsertAt(input: System.Char, position: number): boolean;
      InsertAt(input: string, position: number): boolean;
      IsAvailablePosition(position: number): boolean;
      IsEditPosition(position: number): boolean;
      static IsValidInputChar(c: System.Char): boolean;
      static IsValidMaskChar(c: System.Char): boolean;
      static IsValidPasswordChar(c: System.Char): boolean;
      Remove(): boolean;
      RemoveAt(position: number): boolean;
      RemoveAt(startPosition: number, endPosition: number): boolean;
      Replace(input: System.Char, position: number): boolean;
      Replace(input: string, position: number): boolean;
      Set(input: string): boolean;
      ToDisplayString(): string;
      ToString(): string;
      ToString(ignorePasswordChar: boolean): string;
      ToString(startPosition: number, length: number): string;
      ToString(ignorePasswordChar: boolean, startPosition: number, length: number): string;
      ToString(includePrompt: boolean, includeLiterals: boolean): string;
      ToString(includePrompt: boolean, includeLiterals: boolean, startPosition: number, length: number): string;
      ToString(ignorePasswordChar: boolean, includePrompt: boolean, includeLiterals: boolean, startPosition: number, length: number): string;
      VerifyEscapeChar(input: System.Char, position: number): boolean;
      VerifyString(input: string): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum MaskedTextResultHint {
      Unknown = 0,
      CharacterEscaped = 1,
      NoEffect = 2,
      SideEffect = 3,
      Success = 4,
      AsciiCharacterExpected = -1,
      AlphanumericCharacterExpected = -2,
      DigitExpected = -3,
      LetterExpected = -4,
      SignedDigitExpected = -5,
      InvalidInput = -51,
      PromptCharNotAllowed = -52,
      UnavailableEditPosition = -53,
      NonEditPosition = -54,
      PositionOutOfRange = -55,
    }
    export class MultilineStringConverter {
      constructor();
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class NestedContainer {
      constructor(owner: System.ComponentModel.IComponent);
      Owner: System.ComponentModel.IComponent;
      Components: System.ComponentModel.ComponentCollection;
      Add(component: System.ComponentModel.IComponent): void;
      Add(component: System.ComponentModel.IComponent, name: string): void;
      Dispose(): void;
      Remove(component: System.ComponentModel.IComponent): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class NullableConverter {
      constructor(type: System.Type);
      NullableType: System.Type;
      UnderlyingType: System.Type;
      UnderlyingTypeConverter: System.ComponentModel.TypeConverter;
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesSupported(): boolean;
      IsValid(value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PropertyDescriptor {
      ComponentType: System.Type;
      Converter: System.ComponentModel.TypeConverter;
      IsLocalizable: boolean;
      IsReadOnly: boolean;
      SerializationVisibility: System.ComponentModel.DesignerSerializationVisibility;
      PropertyType: System.Type;
      SupportsChangeEvents: boolean;
      Attributes: System.ComponentModel.AttributeCollection;
      Category: string;
      Description: string;
      IsBrowsable: boolean;
      Name: string;
      DesignTimeOnly: boolean;
      DisplayName: string;
      AddValueChanged(component: any, handler: ((sender: any, e: System.EventArgs) => void)): void;
      CanResetValue(component: any): boolean;
      Equals(obj: any): boolean;
      GetChildProperties(): System.ComponentModel.PropertyDescriptorCollection;
      GetChildProperties(filter: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetChildProperties(instance: any): System.ComponentModel.PropertyDescriptorCollection;
      GetChildProperties(instance: any, filter: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetEditor(editorBaseType: System.Type): any;
      GetHashCode(): number;
      GetValue(component: any): any;
      RemoveValueChanged(component: any, handler: ((sender: any, e: System.EventArgs) => void)): void;
      ResetValue(component: any): void;
      SetValue(component: any, value: any): void;
      ShouldSerializeValue(component: any): boolean;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PropertyDescriptorCollection {
      constructor(properties: System.ComponentModel.PropertyDescriptor[]);
      constructor(properties: System.ComponentModel.PropertyDescriptor[], readOnly: boolean);
      Count: number;
      static Empty: System.ComponentModel.PropertyDescriptorCollection;
      Add(value: System.ComponentModel.PropertyDescriptor): number;
      Clear(): void;
      Contains(value: System.ComponentModel.PropertyDescriptor): boolean;
      CopyTo(array: System.Array, index: number): void;
      Find(name: string, ignoreCase: boolean): System.ComponentModel.PropertyDescriptor;
      IndexOf(value: System.ComponentModel.PropertyDescriptor): number;
      Insert(index: number, value: System.ComponentModel.PropertyDescriptor): void;
      Remove(value: System.ComponentModel.PropertyDescriptor): void;
      RemoveAt(index: number): void;
      Sort(): System.ComponentModel.PropertyDescriptorCollection;
      Sort(names: string[]): System.ComponentModel.PropertyDescriptorCollection;
      Sort(names: string[], comparer: System.Collections.IComparer): System.ComponentModel.PropertyDescriptorCollection;
      Sort(comparer: System.Collections.IComparer): System.ComponentModel.PropertyDescriptorCollection;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ReferenceConverter {
      constructor(type: System.Type);
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesSupported(): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RefreshEventArgs {
      constructor(componentChanged: any);
      constructor(typeChanged: System.Type);
      ComponentChanged: any; // System.Object
      TypeChanged: System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RefreshEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(e: System.ComponentModel.RefreshEventArgs): void;
      BeginInvoke(e: System.ComponentModel.RefreshEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SByteConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SingleConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StringConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SyntaxCheck {
      static CheckMachineName(value: string): boolean;
      static CheckPath(value: string): boolean;
      static CheckRootedPath(value: string): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TimeSpanConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum ToolboxItemFilterType {
      Allow = 0,
      Custom = 1,
      Prevent = 2,
      Require = 3,
    }
    export class TypeDescriptionProvider {
      CreateInstance(provider: System.IServiceProvider, objectType: System.Type, argTypes: System.Type[], args: any[]): any;
      GetCache(instance: any): System.Collections.IDictionary;
      GetExtendedTypeDescriptor(instance: any): System.ComponentModel.ICustomTypeDescriptor;
      GetFullComponentName(component: any): string;
      GetReflectionType(objectType: System.Type): System.Type;
      GetReflectionType(instance: any): System.Type;
      GetReflectionType(objectType: System.Type, instance: any): System.Type;
      GetRuntimeType(reflectionType: System.Type): System.Type;
      GetTypeDescriptor(objectType: System.Type): System.ComponentModel.ICustomTypeDescriptor;
      GetTypeDescriptor(instance: any): System.ComponentModel.ICustomTypeDescriptor;
      GetTypeDescriptor(objectType: System.Type, instance: any): System.ComponentModel.ICustomTypeDescriptor;
      IsSupportedType(type: System.Type): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TypeListConverter {
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesSupported(): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class UInt16Converter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class UInt32Converter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class UInt64Converter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class WarningException {
      constructor();
      constructor(message: string);
      constructor(message: string, helpUrl: string);
      constructor(message: string, innerException: System.Exception);
      constructor(message: string, helpUrl: string, helpTopic: string);
      HelpUrl: string;
      HelpTopic: string;
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class CancelEventArgs {
      constructor();
      constructor(cancel: boolean);
      Cancel: boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IChangeTracking {
      IsChanged: boolean;
      AcceptChanges(): void;
    }
    export interface IEditableObject {
      BeginEdit(): void;
      EndEdit(): void;
      CancelEdit(): void;
    }
    export interface IRevertibleChangeTracking {
      RejectChanges(): void;
    }
    export class DataErrorsChangedEventArgs {
      constructor(propertyName: string);
      PropertyName: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface INotifyDataErrorInfo {
      HasErrors: boolean;
      GetErrors(propertyName: string): System.Collections.IEnumerable;
    }
    export interface INotifyPropertyChanged {
    }
    export interface INotifyPropertyChanging {
    }
    export class PropertyChangedEventArgs {
      constructor(propertyName: string);
      PropertyName: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PropertyChangedEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.PropertyChangedEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.PropertyChangedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PropertyChangingEventArgs {
      constructor(propertyName: string);
      PropertyName: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PropertyChangingEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.PropertyChangingEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.PropertyChangingEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AsyncCompletedEventArgs {
      constructor();
      constructor(error: System.Exception, cancelled: boolean, userState: any);
      Cancelled: boolean;
      Error: System.Exception;
      UserState: any; // System.Object
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AsyncCompletedEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.AsyncCompletedEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.AsyncCompletedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CollectionConverter {
      constructor();
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Component {
      constructor();
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      Dispose(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ComponentConverter {
      constructor(type: System.Type);
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesSupported(): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Container {
      constructor();
      Components: System.ComponentModel.ComponentCollection;
      Add(component: System.ComponentModel.IComponent): void;
      Add(component: System.ComponentModel.IComponent, name: string): void;
      Dispose(): void;
      Remove(component: System.ComponentModel.IComponent): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DateTimeOffsetConverter {
      constructor();
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DoWorkEventArgs {
      constructor(argument: any);
      Argument: any; // System.Object
      Result: any; // System.Object
      Cancel: boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DoWorkEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.DoWorkEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.DoWorkEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EnumConverter {
      constructor(type: System.Type);
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesSupported(): boolean;
      IsValid(value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IComponent {
      Site: System.ComponentModel.ISite;
    }
    export class LicenseException {
      constructor(type: System.Type);
      constructor(type: System.Type, instance: any);
      constructor(type: System.Type, instance: any, message: string);
      constructor(type: System.Type, instance: any, message: string, innerException: System.Exception);
      LicensedType: System.Type;
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class MemberDescriptor {
      Attributes: System.ComponentModel.AttributeCollection;
      Category: string;
      Description: string;
      IsBrowsable: boolean;
      Name: string;
      DesignTimeOnly: boolean;
      DisplayName: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ProgressChangedEventArgs {
      constructor(progressPercentage: number, userState: any);
      ProgressPercentage: number;
      UserState: any; // System.Object
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ProgressChangedEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.ProgressChangedEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.ProgressChangedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RunWorkerCompletedEventArgs {
      constructor(result: any, error: System.Exception, cancelled: boolean);
      Result: any; // System.Object
      UserState: any; // System.Object
      Cancelled: boolean;
      Error: System.Exception;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RunWorkerCompletedEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ComponentModel.RunWorkerCompletedEventArgs): void;
      BeginInvoke(sender: any, e: System.ComponentModel.RunWorkerCompletedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TypeConverter {
      constructor();
      CanConvertFrom(sourceType: System.Type): boolean;
      CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
      CanConvertTo(destinationType: System.Type): boolean;
      CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
      ConvertFrom(value: any): any;
      ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
      ConvertFromInvariantString(text: string): any;
      ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
      ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
      ConvertTo(value: any, destinationType: System.Type): any;
      ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
      ConvertToInvariantString(value: any): string;
      ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
      ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
      CreateInstance(propertyValues: System.Collections.IDictionary): any;
      CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
      GetCreateInstanceSupported(): boolean;
      GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
      GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      GetPropertiesSupported(): boolean;
      GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValues(): System.Collections.ICollection;
      GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
      GetStandardValuesExclusive(): boolean;
      GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      GetStandardValuesSupported(): boolean;
      GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
      IsValid(value: any): boolean;
      IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TypeConverter_StandardValuesCollection {
      constructor(values: System.Collections.ICollection);
      Count: number;
      CopyTo(array: System.Array, index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TypeDescriptor {
      static ComNativeDescriptorHandler: System.ComponentModel.IComNativeDescriptorHandler;
      static ComObjectType: System.Type;
      static InterfaceType: System.Type;
      static AddAttributes(type: System.Type, ...attributes: any[]): System.ComponentModel.TypeDescriptionProvider;
      static AddAttributes(instance: any, ...attributes: any[]): System.ComponentModel.TypeDescriptionProvider;
      static AddEditorTable(editorBaseType: System.Type, table: System.Collections.Hashtable): void;
      static AddProvider(provider: System.ComponentModel.TypeDescriptionProvider, type: System.Type): void;
      static AddProvider(provider: System.ComponentModel.TypeDescriptionProvider, instance: any): void;
      static AddProviderTransparent(provider: System.ComponentModel.TypeDescriptionProvider, type: System.Type): void;
      static AddProviderTransparent(provider: System.ComponentModel.TypeDescriptionProvider, instance: any): void;
      static CreateAssociation(primary: any, secondary: any): void;
      static CreateDesigner(component: System.ComponentModel.IComponent, designerBaseType: System.Type): System.ComponentModel.Design.IDesigner;
      static CreateEvent(componentType: System.Type, name: string, type: System.Type, ...attributes: any[]): System.ComponentModel.EventDescriptor;
      static CreateEvent(componentType: System.Type, oldEventDescriptor: System.ComponentModel.EventDescriptor, ...attributes: any[]): System.ComponentModel.EventDescriptor;
      static CreateInstance(provider: System.IServiceProvider, objectType: System.Type, argTypes: System.Type[], args: any[]): any;
      static CreateProperty(componentType: System.Type, name: string, type: System.Type, ...attributes: any[]): System.ComponentModel.PropertyDescriptor;
      static CreateProperty(componentType: System.Type, oldPropertyDescriptor: System.ComponentModel.PropertyDescriptor, ...attributes: any[]): System.ComponentModel.PropertyDescriptor;
      static GetAssociation(type: System.Type, primary: any): any;
      static GetAttributes(componentType: System.Type): System.ComponentModel.AttributeCollection;
      static GetAttributes(component: any): System.ComponentModel.AttributeCollection;
      static GetAttributes(component: any, noCustomTypeDesc: boolean): System.ComponentModel.AttributeCollection;
      static GetClassName(component: any): string;
      static GetClassName(component: any, noCustomTypeDesc: boolean): string;
      static GetClassName(componentType: System.Type): string;
      static GetComponentName(component: any): string;
      static GetComponentName(component: any, noCustomTypeDesc: boolean): string;
      static GetConverter(component: any): System.ComponentModel.TypeConverter;
      static GetConverter(component: any, noCustomTypeDesc: boolean): System.ComponentModel.TypeConverter;
      static GetConverter(type: System.Type): System.ComponentModel.TypeConverter;
      static GetDefaultEvent(componentType: System.Type): System.ComponentModel.EventDescriptor;
      static GetDefaultEvent(component: any): System.ComponentModel.EventDescriptor;
      static GetDefaultEvent(component: any, noCustomTypeDesc: boolean): System.ComponentModel.EventDescriptor;
      static GetDefaultProperty(componentType: System.Type): System.ComponentModel.PropertyDescriptor;
      static GetDefaultProperty(component: any): System.ComponentModel.PropertyDescriptor;
      static GetDefaultProperty(component: any, noCustomTypeDesc: boolean): System.ComponentModel.PropertyDescriptor;
      static GetEditor(component: any, editorBaseType: System.Type): any;
      static GetEditor(component: any, editorBaseType: System.Type, noCustomTypeDesc: boolean): any;
      static GetEditor(type: System.Type, editorBaseType: System.Type): any;
      static GetEvents(componentType: System.Type): System.ComponentModel.EventDescriptorCollection;
      static GetEvents(componentType: System.Type, attributes: any[]): System.ComponentModel.EventDescriptorCollection;
      static GetEvents(component: any): System.ComponentModel.EventDescriptorCollection;
      static GetEvents(component: any, noCustomTypeDesc: boolean): System.ComponentModel.EventDescriptorCollection;
      static GetEvents(component: any, attributes: any[]): System.ComponentModel.EventDescriptorCollection;
      static GetEvents(component: any, attributes: any[], noCustomTypeDesc: boolean): System.ComponentModel.EventDescriptorCollection;
      static GetFullComponentName(component: any): string;
      static GetProperties(componentType: System.Type): System.ComponentModel.PropertyDescriptorCollection;
      static GetProperties(componentType: System.Type, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      static GetProperties(component: any): System.ComponentModel.PropertyDescriptorCollection;
      static GetProperties(component: any, noCustomTypeDesc: boolean): System.ComponentModel.PropertyDescriptorCollection;
      static GetProperties(component: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
      static GetProperties(component: any, attributes: any[], noCustomTypeDesc: boolean): System.ComponentModel.PropertyDescriptorCollection;
      static GetProvider(type: System.Type): System.ComponentModel.TypeDescriptionProvider;
      static GetProvider(instance: any): System.ComponentModel.TypeDescriptionProvider;
      static GetReflectionType(type: System.Type): System.Type;
      static GetReflectionType(instance: any): System.Type;
      static Refresh(component: any): void;
      static Refresh(type: System.Type): void;
      static Refresh(module: System.Reflection.Module): void;
      static Refresh(assembly: System.Reflection.Assembly): void;
      static RemoveAssociation(primary: any, secondary: any): void;
      static RemoveAssociations(primary: any): void;
      static RemoveProvider(provider: System.ComponentModel.TypeDescriptionProvider, type: System.Type): void;
      static RemoveProvider(provider: System.ComponentModel.TypeDescriptionProvider, instance: any): void;
      static RemoveProviderTransparent(provider: System.ComponentModel.TypeDescriptionProvider, type: System.Type): void;
      static RemoveProviderTransparent(provider: System.ComponentModel.TypeDescriptionProvider, instance: any): void;
      static SortDescriptorArray(infos: System.Collections.IList): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Win32Exception {
      constructor();
      constructor(error: number);
      constructor(error: number, message: string);
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      NativeErrorCode: number;
      ErrorCode: number;
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      ToString(): string;
      GetBaseException(): System.Exception;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum RefreshProperties {
      None = 0,
      All = 1,
      Repaint = 2,
    }
    export namespace Design {
      export class ActiveDesignerEventArgs {
        constructor(oldDesigner: System.ComponentModel.Design.IDesignerHost, newDesigner: System.ComponentModel.Design.IDesignerHost);
        OldDesigner: System.ComponentModel.Design.IDesignerHost;
        NewDesigner: System.ComponentModel.Design.IDesignerHost;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ActiveDesignerEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.ComponentModel.Design.ActiveDesignerEventArgs): void;
        BeginInvoke(sender: any, e: System.ComponentModel.Design.ActiveDesignerEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CheckoutException {
        constructor();
        constructor(message: string);
        constructor(message: string, errorCode: number);
        constructor(message: string, innerException: System.Exception);
        ErrorCode: number;
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        static Canceled: System.ComponentModel.Design.CheckoutException;
        ToString(): string;
        GetBaseException(): System.Exception;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class CommandID {
        constructor(menuGroup: System.Guid, commandID: number);
        ID: number;
        Guid: System.Guid;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ComponentChangedEventArgs {
        constructor(component: any, member: System.ComponentModel.MemberDescriptor, oldValue: any, newValue: any);
        Component: any; // System.Object
        Member: System.ComponentModel.MemberDescriptor;
        NewValue: any; // System.Object
        OldValue: any; // System.Object
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ComponentChangedEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.ComponentModel.Design.ComponentChangedEventArgs): void;
        BeginInvoke(sender: any, e: System.ComponentModel.Design.ComponentChangedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ComponentChangingEventArgs {
        constructor(component: any, member: System.ComponentModel.MemberDescriptor);
        Component: any; // System.Object
        Member: System.ComponentModel.MemberDescriptor;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ComponentChangingEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.ComponentModel.Design.ComponentChangingEventArgs): void;
        BeginInvoke(sender: any, e: System.ComponentModel.Design.ComponentChangingEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ComponentEventArgs {
        constructor(component: System.ComponentModel.IComponent);
        Component: System.ComponentModel.IComponent;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ComponentEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.ComponentModel.Design.ComponentEventArgs): void;
        BeginInvoke(sender: any, e: System.ComponentModel.Design.ComponentEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ComponentRenameEventArgs {
        constructor(component: any, oldName: string, newName: string);
        Component: any; // System.Object
        OldName: string;
        NewName: string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ComponentRenameEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.ComponentModel.Design.ComponentRenameEventArgs): void;
        BeginInvoke(sender: any, e: System.ComponentModel.Design.ComponentRenameEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesignerTransaction {
        Canceled: boolean;
        Committed: boolean;
        Description: string;
        Cancel(): void;
        Commit(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesignerTransactionCloseEventArgs {
        constructor(commit: boolean);
        constructor(commit: boolean, lastTransaction: boolean);
        TransactionCommitted: boolean;
        LastTransaction: boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesignerTransactionCloseEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.ComponentModel.Design.DesignerTransactionCloseEventArgs): void;
        BeginInvoke(sender: any, e: System.ComponentModel.Design.DesignerTransactionCloseEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesignerVerb {
        constructor(text: string, handler: ((sender: any, e: System.EventArgs) => void));
        constructor(text: string, handler: ((sender: any, e: System.EventArgs) => void), startCommandID: System.ComponentModel.Design.CommandID);
        Description: string;
        Text: string;
        Checked: boolean;
        Enabled: boolean;
        Properties: System.Collections.IDictionary;
        Supported: boolean;
        Visible: boolean;
        CommandID: System.ComponentModel.Design.CommandID;
        OleStatus: number;
        ToString(): string;
        Invoke(): void;
        Invoke(arg: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class DesignerVerbCollection {
        constructor();
        constructor(value: System.ComponentModel.Design.DesignerVerb[]);
        Capacity: number;
        Count: number;
        Add(value: System.ComponentModel.Design.DesignerVerb): number;
        AddRange(value: System.ComponentModel.Design.DesignerVerb[]): void;
        AddRange(value: System.ComponentModel.Design.DesignerVerbCollection): void;
        Insert(index: number, value: System.ComponentModel.Design.DesignerVerb): void;
        IndexOf(value: System.ComponentModel.Design.DesignerVerb): number;
        Contains(value: System.ComponentModel.Design.DesignerVerb): boolean;
        Remove(value: System.ComponentModel.Design.DesignerVerb): void;
        CopyTo(array: System.ComponentModel.Design.DesignerVerb[], index: number): void;
        Clear(): void;
        RemoveAt(index: number): void;
        GetEnumerator(): System.Collections.IEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesigntimeLicenseContext {
        constructor();
        UsageMode: System.ComponentModel.LicenseUsageMode;
        GetSavedLicenseKey(type: System.Type, resourceAssembly: System.Reflection.Assembly): string;
        SetSavedLicenseKey(type: System.Type, key: string): void;
        GetService(type: System.Type): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesigntimeLicenseContextSerializer {
        static Serialize(o: System.IO.Stream, cryptoKey: string, context: System.ComponentModel.Design.DesigntimeLicenseContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesignerCollection {
        constructor(designers: System.ComponentModel.Design.IDesignerHost[]);
        constructor(designers: System.Collections.IList);
        Count: number;
        GetEnumerator(): System.Collections.IEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesignerEventArgs {
        constructor(host: System.ComponentModel.Design.IDesignerHost);
        Designer: System.ComponentModel.Design.IDesignerHost;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesignerEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.ComponentModel.Design.DesignerEventArgs): void;
        BeginInvoke(sender: any, e: System.ComponentModel.Design.DesignerEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum HelpContextType {
        Ambient = 0,
        Window = 1,
        Selection = 2,
        ToolWindowSelection = 3,
      }
      export enum HelpKeywordType {
        F1Keyword = 0,
        GeneralKeyword = 1,
        FilterKeyword = 2,
      }
      export interface IComponentChangeService {
        OnComponentChanged(component: any, member: System.ComponentModel.MemberDescriptor, oldValue: any, newValue: any): void;
        OnComponentChanging(component: any, member: System.ComponentModel.MemberDescriptor): void;
      }
      export interface IComponentDiscoveryService {
        GetComponentTypes(designerHost: System.ComponentModel.Design.IDesignerHost, baseType: System.Type): System.Collections.ICollection;
      }
      export interface IComponentInitializer {
        InitializeExistingComponent(defaultValues: System.Collections.IDictionary): void;
        InitializeNewComponent(defaultValues: System.Collections.IDictionary): void;
      }
      export interface IDesigner {
        Component: System.ComponentModel.IComponent;
        Verbs: System.ComponentModel.Design.DesignerVerbCollection;
        DoDefaultAction(): void;
        Initialize(component: System.ComponentModel.IComponent): void;
      }
      export interface IDesignerEventService {
        ActiveDesigner: System.ComponentModel.Design.IDesignerHost;
        Designers: System.ComponentModel.Design.DesignerCollection;
      }
      export interface IDesignerFilter {
        PostFilterAttributes(attributes: System.Collections.IDictionary): void;
        PostFilterEvents(events: System.Collections.IDictionary): void;
        PostFilterProperties(properties: System.Collections.IDictionary): void;
        PreFilterAttributes(attributes: System.Collections.IDictionary): void;
        PreFilterEvents(events: System.Collections.IDictionary): void;
        PreFilterProperties(properties: System.Collections.IDictionary): void;
      }
      export interface IDesignerHost {
        Loading: boolean;
        InTransaction: boolean;
        Container: System.ComponentModel.IContainer;
        RootComponent: System.ComponentModel.IComponent;
        RootComponentClassName: string;
        TransactionDescription: string;
        Activate(): void;
        CreateComponent(componentClass: System.Type): System.ComponentModel.IComponent;
        CreateComponent(componentClass: System.Type, name: string): System.ComponentModel.IComponent;
        CreateTransaction(): System.ComponentModel.Design.DesignerTransaction;
        CreateTransaction(description: string): System.ComponentModel.Design.DesignerTransaction;
        DestroyComponent(component: System.ComponentModel.IComponent): void;
        GetDesigner(component: System.ComponentModel.IComponent): System.ComponentModel.Design.IDesigner;
        GetType(typeName: string): System.Type;
      }
      export interface IDesignerHostTransactionState {
        IsClosingTransaction: boolean;
      }
      export interface IDesignerOptionService {
        GetOptionValue(pageName: string, valueName: string): any;
        SetOptionValue(pageName: string, valueName: string, value: any): void;
      }
      export interface IDictionaryService {
        GetKey(value: any): any;
        GetValue(key: any): any;
        SetValue(key: any, value: any): void;
      }
      export interface IEventBindingService {
        CreateUniqueMethodName(component: System.ComponentModel.IComponent, e: System.ComponentModel.EventDescriptor): string;
        GetCompatibleMethods(e: System.ComponentModel.EventDescriptor): System.Collections.ICollection;
        GetEvent(property: System.ComponentModel.PropertyDescriptor): System.ComponentModel.EventDescriptor;
        GetEventProperties(events: System.ComponentModel.EventDescriptorCollection): System.ComponentModel.PropertyDescriptorCollection;
        GetEventProperty(e: System.ComponentModel.EventDescriptor): System.ComponentModel.PropertyDescriptor;
        ShowCode(): boolean;
        ShowCode(lineNumber: number): boolean;
        ShowCode(component: System.ComponentModel.IComponent, e: System.ComponentModel.EventDescriptor): boolean;
      }
      export interface IExtenderListService {
        GetExtenderProviders(): System.ComponentModel.IExtenderProvider[];
      }
      export interface IExtenderProviderService {
        AddExtenderProvider(provider: System.ComponentModel.IExtenderProvider): void;
        RemoveExtenderProvider(provider: System.ComponentModel.IExtenderProvider): void;
      }
      export interface IHelpService {
        AddContextAttribute(name: string, value: string, keywordType: System.ComponentModel.Design.HelpKeywordType): void;
        ClearContextAttributes(): void;
        CreateLocalContext(contextType: System.ComponentModel.Design.HelpContextType): System.ComponentModel.Design.IHelpService;
        RemoveContextAttribute(name: string, value: string): void;
        RemoveLocalContext(localContext: System.ComponentModel.Design.IHelpService): void;
        ShowHelpFromKeyword(helpKeyword: string): void;
        ShowHelpFromUrl(helpUrl: string): void;
      }
      export interface IInheritanceService {
        AddInheritedComponents(component: System.ComponentModel.IComponent, container: System.ComponentModel.IContainer): void;
        GetInheritanceAttribute(component: System.ComponentModel.IComponent): any;
      }
      export interface IMenuCommandService {
        Verbs: System.ComponentModel.Design.DesignerVerbCollection;
        AddCommand(command: System.ComponentModel.Design.MenuCommand): void;
        AddVerb(verb: System.ComponentModel.Design.DesignerVerb): void;
        FindCommand(commandID: System.ComponentModel.Design.CommandID): System.ComponentModel.Design.MenuCommand;
        GlobalInvoke(commandID: System.ComponentModel.Design.CommandID): boolean;
        RemoveCommand(command: System.ComponentModel.Design.MenuCommand): void;
        RemoveVerb(verb: System.ComponentModel.Design.DesignerVerb): void;
        ShowContextMenu(menuID: System.ComponentModel.Design.CommandID, x: number, y: number): void;
      }
      export interface IReferenceService {
        GetComponent(reference: any): System.ComponentModel.IComponent;
        GetReference(name: string): any;
        GetName(reference: any): string;
        GetReferences(): any[];
        GetReferences(baseType: System.Type): any[];
      }
      export interface IResourceService {
        GetResourceReader(info: System.Globalization.CultureInfo): System.Resources.IResourceReader;
        GetResourceWriter(info: System.Globalization.CultureInfo): System.Resources.IResourceWriter;
      }
      export interface IRootDesigner {
        SupportedTechnologies: System.ComponentModel.Design.ViewTechnology[];
        GetView(technology: System.ComponentModel.Design.ViewTechnology): any;
      }
      export interface ISelectionService {
        PrimarySelection: any; // System.Object
        SelectionCount: number;
        GetComponentSelected(component: any): boolean;
        GetSelectedComponents(): System.Collections.ICollection;
        SetSelectedComponents(components: System.Collections.ICollection): void;
        SetSelectedComponents(components: System.Collections.ICollection, selectionType: System.ComponentModel.Design.SelectionTypes): void;
      }
      export interface IServiceContainer {
        AddService(serviceType: System.Type, serviceInstance: any): void;
        AddService(serviceType: System.Type, serviceInstance: any, promote: boolean): void;
        AddService(serviceType: System.Type, callback: ((container: System.ComponentModel.Design.IServiceContainer, serviceType: System.Type) => any)): void;
        AddService(serviceType: System.Type, callback: ((container: System.ComponentModel.Design.IServiceContainer, serviceType: System.Type) => any), promote: boolean): void;
        RemoveService(serviceType: System.Type): void;
        RemoveService(serviceType: System.Type, promote: boolean): void;
      }
      export interface ITreeDesigner {
        Children: System.Collections.ICollection;
        Parent: System.ComponentModel.Design.IDesigner;
      }
      export interface ITypeDescriptorFilterService {
        FilterAttributes(component: System.ComponentModel.IComponent, attributes: System.Collections.IDictionary): boolean;
        FilterEvents(component: System.ComponentModel.IComponent, events: System.Collections.IDictionary): boolean;
        FilterProperties(component: System.ComponentModel.IComponent, properties: System.Collections.IDictionary): boolean;
      }
      export interface ITypeDiscoveryService {
        GetTypes(baseType: System.Type, excludeGlobalTypes: boolean): System.Collections.ICollection;
      }
      export interface ITypeResolutionService {
        GetAssembly(name: System.Reflection.AssemblyName): System.Reflection.Assembly;
        GetAssembly(name: System.Reflection.AssemblyName, throwOnError: boolean): System.Reflection.Assembly;
        GetType(name: string): System.Type;
        GetType(name: string, throwOnError: boolean): System.Type;
        GetType(name: string, throwOnError: boolean, ignoreCase: boolean): System.Type;
        ReferenceAssembly(name: System.Reflection.AssemblyName): void;
        GetPathOfAssembly(name: System.Reflection.AssemblyName): string;
      }
      export class MenuCommand {
        constructor(handler: ((sender: any, e: System.EventArgs) => void), command: System.ComponentModel.Design.CommandID);
        Checked: boolean;
        Enabled: boolean;
        Properties: System.Collections.IDictionary;
        Supported: boolean;
        Visible: boolean;
        CommandID: System.ComponentModel.Design.CommandID;
        OleStatus: number;
        Invoke(): void;
        Invoke(arg: any): void;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum SelectionTypes {
        Auto = 1,
        Normal = 1,
        Replace = 2,
        MouseDown = 4,
        MouseUp = 8,
        Click = 16,
        Primary = 16,
        Toggle = 32,
        Add = 64,
        Remove = 128,
        Valid = 31,
      }
      export class ServiceCreatorCallback {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(container: System.ComponentModel.Design.IServiceContainer, serviceType: System.Type): any;
        BeginInvoke(container: System.ComponentModel.Design.IServiceContainer, serviceType: System.Type, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): any;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ServiceContainer {
        constructor();
        constructor(parentProvider: System.IServiceProvider);
        AddService(serviceType: System.Type, serviceInstance: any): void;
        AddService(serviceType: System.Type, serviceInstance: any, promote: boolean): void;
        AddService(serviceType: System.Type, callback: ((container: System.ComponentModel.Design.IServiceContainer, serviceType: System.Type) => any)): void;
        AddService(serviceType: System.Type, callback: ((container: System.ComponentModel.Design.IServiceContainer, serviceType: System.Type) => any), promote: boolean): void;
        Dispose(): void;
        GetService(serviceType: System.Type): any;
        RemoveService(serviceType: System.Type): void;
        RemoveService(serviceType: System.Type, promote: boolean): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class StandardCommands {
        constructor();
        static AlignBottom: System.ComponentModel.Design.CommandID;
        static AlignHorizontalCenters: System.ComponentModel.Design.CommandID;
        static AlignLeft: System.ComponentModel.Design.CommandID;
        static AlignRight: System.ComponentModel.Design.CommandID;
        static AlignToGrid: System.ComponentModel.Design.CommandID;
        static AlignTop: System.ComponentModel.Design.CommandID;
        static AlignVerticalCenters: System.ComponentModel.Design.CommandID;
        static ArrangeBottom: System.ComponentModel.Design.CommandID;
        static ArrangeRight: System.ComponentModel.Design.CommandID;
        static BringForward: System.ComponentModel.Design.CommandID;
        static BringToFront: System.ComponentModel.Design.CommandID;
        static CenterHorizontally: System.ComponentModel.Design.CommandID;
        static CenterVertically: System.ComponentModel.Design.CommandID;
        static ViewCode: System.ComponentModel.Design.CommandID;
        static DocumentOutline: System.ComponentModel.Design.CommandID;
        static Copy: System.ComponentModel.Design.CommandID;
        static Cut: System.ComponentModel.Design.CommandID;
        static Delete: System.ComponentModel.Design.CommandID;
        static Group: System.ComponentModel.Design.CommandID;
        static HorizSpaceConcatenate: System.ComponentModel.Design.CommandID;
        static HorizSpaceDecrease: System.ComponentModel.Design.CommandID;
        static HorizSpaceIncrease: System.ComponentModel.Design.CommandID;
        static HorizSpaceMakeEqual: System.ComponentModel.Design.CommandID;
        static Paste: System.ComponentModel.Design.CommandID;
        static Properties: System.ComponentModel.Design.CommandID;
        static Redo: System.ComponentModel.Design.CommandID;
        static MultiLevelRedo: System.ComponentModel.Design.CommandID;
        static SelectAll: System.ComponentModel.Design.CommandID;
        static SendBackward: System.ComponentModel.Design.CommandID;
        static SendToBack: System.ComponentModel.Design.CommandID;
        static SizeToControl: System.ComponentModel.Design.CommandID;
        static SizeToControlHeight: System.ComponentModel.Design.CommandID;
        static SizeToControlWidth: System.ComponentModel.Design.CommandID;
        static SizeToFit: System.ComponentModel.Design.CommandID;
        static SizeToGrid: System.ComponentModel.Design.CommandID;
        static SnapToGrid: System.ComponentModel.Design.CommandID;
        static TabOrder: System.ComponentModel.Design.CommandID;
        static Undo: System.ComponentModel.Design.CommandID;
        static MultiLevelUndo: System.ComponentModel.Design.CommandID;
        static Ungroup: System.ComponentModel.Design.CommandID;
        static VertSpaceConcatenate: System.ComponentModel.Design.CommandID;
        static VertSpaceDecrease: System.ComponentModel.Design.CommandID;
        static VertSpaceIncrease: System.ComponentModel.Design.CommandID;
        static VertSpaceMakeEqual: System.ComponentModel.Design.CommandID;
        static ShowGrid: System.ComponentModel.Design.CommandID;
        static ViewGrid: System.ComponentModel.Design.CommandID;
        static Replace: System.ComponentModel.Design.CommandID;
        static PropertiesWindow: System.ComponentModel.Design.CommandID;
        static LockControls: System.ComponentModel.Design.CommandID;
        static F1Help: System.ComponentModel.Design.CommandID;
        static ArrangeIcons: System.ComponentModel.Design.CommandID;
        static LineupIcons: System.ComponentModel.Design.CommandID;
        static ShowLargeIcons: System.ComponentModel.Design.CommandID;
        static VerbFirst: System.ComponentModel.Design.CommandID;
        static VerbLast: System.ComponentModel.Design.CommandID;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class StandardToolWindows {
        constructor();
        static ObjectBrowser: System.Guid;
        static OutputWindow: System.Guid;
        static ProjectExplorer: System.Guid;
        static PropertyBrowser: System.Guid;
        static RelatedLinks: System.Guid;
        static ServerExplorer: System.Guid;
        static TaskList: System.Guid;
        static Toolbox: System.Guid;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum ViewTechnology {
        Passthrough = 0,
        WindowsForms = 1,
        Default = 2,
      }
      export class TypeDescriptionProviderService {
        GetProvider(instance: any): System.ComponentModel.TypeDescriptionProvider;
        GetProvider(type: System.Type): System.ComponentModel.TypeDescriptionProvider;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesignerOptionService {
        Options: System.ComponentModel.Design.DesignerOptionService_DesignerOptionCollection;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DesignerOptionService_DesignerOptionCollection {
        Count: number;
        Name: string;
        Parent: System.ComponentModel.Design.DesignerOptionService_DesignerOptionCollection;
        Properties: System.ComponentModel.PropertyDescriptorCollection;
        CopyTo(array: System.Array, index: number): void;
        GetEnumerator(): System.Collections.IEnumerator;
        IndexOf(value: System.ComponentModel.Design.DesignerOptionService_DesignerOptionCollection): number;
        ShowDialog(): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export namespace Serialization {
        export class ComponentSerializationService {
          CreateStore(): System.ComponentModel.Design.Serialization.SerializationStore;
          LoadStore(stream: System.IO.Stream): System.ComponentModel.Design.Serialization.SerializationStore;
          Serialize(store: System.ComponentModel.Design.Serialization.SerializationStore, value: any): void;
          SerializeAbsolute(store: System.ComponentModel.Design.Serialization.SerializationStore, value: any): void;
          SerializeMember(store: System.ComponentModel.Design.Serialization.SerializationStore, owningObject: any, member: System.ComponentModel.MemberDescriptor): void;
          SerializeMemberAbsolute(store: System.ComponentModel.Design.Serialization.SerializationStore, owningObject: any, member: System.ComponentModel.MemberDescriptor): void;
          Deserialize(store: System.ComponentModel.Design.Serialization.SerializationStore): System.Collections.ICollection;
          Deserialize(store: System.ComponentModel.Design.Serialization.SerializationStore, container: System.ComponentModel.IContainer): System.Collections.ICollection;
          DeserializeTo(store: System.ComponentModel.Design.Serialization.SerializationStore, container: System.ComponentModel.IContainer, validateRecycledTypes: boolean, applyDefaults: boolean): void;
          DeserializeTo(store: System.ComponentModel.Design.Serialization.SerializationStore, container: System.ComponentModel.IContainer): void;
          DeserializeTo(store: System.ComponentModel.Design.Serialization.SerializationStore, container: System.ComponentModel.IContainer, validateRecycledTypes: boolean): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ContextStack {
          constructor();
          Current: any; // System.Object
          Append(context: any): void;
          Pop(): any;
          Push(context: any): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class DesignerLoader {
          Loading: boolean;
          BeginLoad(host: System.ComponentModel.Design.Serialization.IDesignerLoaderHost): void;
          Dispose(): void;
          Flush(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export interface IDesignerLoaderHost {
          EndLoad(baseClassName: string, successful: boolean, errorCollection: System.Collections.ICollection): void;
          Reload(): void;
        }
        export interface IDesignerLoaderHost2 {
          IgnoreErrorsDuringReload: boolean;
          CanReloadWithErrors: boolean;
        }
        export interface IDesignerLoaderService {
          AddLoadDependency(): void;
          DependentLoadComplete(successful: boolean, errorCollection: System.Collections.ICollection): void;
          Reload(): boolean;
        }
        export interface IDesignerSerializationManager {
          Context: System.ComponentModel.Design.Serialization.ContextStack;
          Properties: System.ComponentModel.PropertyDescriptorCollection;
          AddSerializationProvider(provider: System.ComponentModel.Design.Serialization.IDesignerSerializationProvider): void;
          CreateInstance(type: System.Type, argumentsCS: System.Collections.ICollection, name: string, addToContainer: boolean): any;
          GetInstance(name: string): any;
          GetName(value: any): string;
          GetSerializer(objectType: System.Type, serializerType: System.Type): any;
          GetType(typeName: string): System.Type;
          RemoveSerializationProvider(provider: System.ComponentModel.Design.Serialization.IDesignerSerializationProvider): void;
          ReportError(errorInformation: any): void;
          SetName(instance: any, name: string): void;
        }
        export interface IDesignerSerializationProvider {
          GetSerializer(manager: System.ComponentModel.Design.Serialization.IDesignerSerializationManager, currentSerializer: any, objectType: System.Type, serializerType: System.Type): any;
        }
        export interface IDesignerSerializationService {
          Deserialize(serializationData: any): System.Collections.ICollection;
          Serialize(objects: System.Collections.ICollection): any;
        }
        export interface INameCreationService {
          CreateName(container: System.ComponentModel.IContainer, dataType: System.Type): string;
          IsValidName(name: string): boolean;
          ValidateName(name: string): void;
        }
        export class InstanceDescriptor {
          constructor(member: System.Reflection.MemberInfo, argumentsCS: System.Collections.ICollection);
          constructor(member: System.Reflection.MemberInfo, argumentsCS: System.Collections.ICollection, isComplete: boolean);
          Arguments: System.Collections.ICollection;
          IsComplete: boolean;
          MemberInfo: System.Reflection.MemberInfo;
          Invoke(): any;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class MemberRelationshipService {
          SupportsRelationship(source: System.ComponentModel.Design.Serialization.MemberRelationship, relationship: System.ComponentModel.Design.Serialization.MemberRelationship): boolean;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class MemberRelationship {
          constructor(owner: any, member: System.ComponentModel.MemberDescriptor);
          IsEmpty: boolean;
          Member: System.ComponentModel.MemberDescriptor;
          Owner: any; // System.Object
          static Empty: System.ComponentModel.Design.Serialization.MemberRelationship;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class ResolveNameEventArgs {
          constructor(name: string);
          Name: string;
          Value: any; // System.Object
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ResolveNameEventHandler {
          constructor(object: any, method: System.IntPtr);
          Method: System.Reflection.MethodInfo;
          Target: any; // System.Object
          Invoke(sender: any, e: System.ComponentModel.Design.Serialization.ResolveNameEventArgs): void;
          BeginInvoke(sender: any, e: System.ComponentModel.Design.Serialization.ResolveNameEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
          EndInvoke(result: System.IAsyncResult): void;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetInvocationList(): System.Delegate[];
          DynamicInvoke(...args: any[]): any;
          Clone(): any;
          GetType(): System.Type;
          ToString(): string;
        }
        export class SerializationStore {
          Errors: System.Collections.ICollection;
          Close(): void;
          Save(stream: System.IO.Stream): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
      }
    }
  }
  export namespace Deployment {
    export namespace Internal {
      export class InternalActivationContextHelper {
        static GetActivationContextData(appInfo: System.ActivationContext): any;
        static GetApplicationComponentManifest(appInfo: System.ActivationContext): any;
        static GetApplicationManifestBytes(appInfo: System.ActivationContext): Byte[];
        static GetDeploymentComponentManifest(appInfo: System.ActivationContext): any;
        static GetDeploymentManifestBytes(appInfo: System.ActivationContext): Byte[];
        static IsFirstRun(appInfo: System.ActivationContext): boolean;
        static PrepareForExecution(appInfo: System.ActivationContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class InternalApplicationIdentityHelper {
        static GetInternalAppId(id: System.ApplicationIdentity): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
  }
  export namespace Diagnostics {
    export enum DebuggerBrowsableState {
      Never = 0,
      Collapsed = 2,
      RootHidden = 3,
    }
    export class Debugger {
      constructor();
      static IsAttached: boolean;
      static DefaultCategory: string;
      static Break(): void;
      static IsLogging(): boolean;
      static Launch(): boolean;
      static Log(level: number, category: string, message: string): void;
      static NotifyOfCrossThreadDependency(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StackFrame {
      constructor();
      constructor(fNeedFileInfo: boolean);
      constructor(skipFrames: number);
      constructor(skipFrames: number, fNeedFileInfo: boolean);
      constructor(fileName: string, lineNumber: number);
      constructor(fileName: string, lineNumber: number, colNumber: number);
      static OFFSET_UNKNOWN: number;
      GetFileLineNumber(): number;
      GetFileColumnNumber(): number;
      GetFileName(): string;
      GetILOffset(): number;
      GetMethod(): System.Reflection.MethodBase;
      GetNativeOffset(): number;
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class StackTrace {
      constructor();
      constructor(fNeedFileInfo: boolean);
      constructor(skipFrames: number);
      constructor(skipFrames: number, fNeedFileInfo: boolean);
      constructor(e: System.Exception);
      constructor(e: System.Exception, fNeedFileInfo: boolean);
      constructor(e: System.Exception, skipFrames: number);
      constructor(e: System.Exception, skipFrames: number, fNeedFileInfo: boolean);
      constructor(frame: System.Diagnostics.StackFrame);
      constructor(targetThread: System.Threading.Thread, needFileInfo: boolean);
      FrameCount: number;
      static METHODS_TO_SKIP: number;
      GetFrame(index: number): System.Diagnostics.StackFrame;
      GetFrames(): System.Diagnostics.StackFrame[];
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class EventSchemaTraceListener {
      constructor(fileName: string);
      constructor(fileName: string, name: string);
      constructor(fileName: string, name: string, bufferSize: number);
      constructor(fileName: string, name: string, bufferSize: number, logRetentionOption: System.Diagnostics.TraceLogRetentionOption);
      constructor(fileName: string, name: string, bufferSize: number, logRetentionOption: System.Diagnostics.TraceLogRetentionOption, maximumFileSize: number);
      constructor(fileName: string, name: string, bufferSize: number, logRetentionOption: System.Diagnostics.TraceLogRetentionOption, maximumFileSize: number, maximumNumberOfFiles: number);
      BufferSize: number;
      MaximumFileSize: number;
      MaximumNumberOfFiles: number;
      TraceLogRetentionOption: System.Diagnostics.TraceLogRetentionOption;
      Writer: System.IO.TextWriter;
      Attributes: System.Collections.Specialized.StringDictionary;
      Name: string;
      IsThreadSafe: boolean;
      IndentLevel: number;
      IndentSize: number;
      Filter: System.Diagnostics.TraceFilter;
      TraceOutputOptions: System.Diagnostics.TraceOptions;
      Close(): void;
      Flush(): void;
      Write(message: string): void;
      WriteLine(message: string): void;
      Dispose(): void;
      Fail(message: string): void;
      Fail(message: string, detailMessage: string): void;
      Write(o: any): void;
      Write(message: string, category: string): void;
      Write(o: any, category: string): void;
      WriteLine(o: any): void;
      WriteLine(message: string, category: string): void;
      WriteLine(o: any, category: string): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, data: any): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, message: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
      TraceTransfer(eventCache: System.Diagnostics.TraceEventCache, source: string, id: number, message: string, relatedActivityId: System.Guid): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum TraceLogRetentionOption {
      LimitedCircularFiles = 1,
      LimitedSequentialFiles = 3,
      SingleFileBoundedSize = 4,
      SingleFileUnboundedSize = 2,
      UnlimitedSequentialFiles = 0,
    }
    export class UnescapedXmlDiagnosticData {
      constructor(xmlPayload: string);
      UnescapedXml: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StackFrameExtensions {
      static HasNativeImage(stackFrame: System.Diagnostics.StackFrame): boolean;
      static HasMethod(stackFrame: System.Diagnostics.StackFrame): boolean;
      static HasILOffset(stackFrame: System.Diagnostics.StackFrame): boolean;
      static HasSource(stackFrame: System.Diagnostics.StackFrame): boolean;
      static GetNativeIP(stackFrame: System.Diagnostics.StackFrame): System.IntPtr;
      static GetNativeImageBase(stackFrame: System.Diagnostics.StackFrame): System.IntPtr;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BooleanSwitch {
      constructor(displayName: string, description: string);
      constructor(displayName: string, description: string, defaultSwitchValue: string);
      Enabled: boolean;
      Attributes: System.Collections.Specialized.StringDictionary;
      DisplayName: string;
      Description: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ConsoleTraceListener {
      constructor();
      constructor(useErrorStream: boolean);
      Writer: System.IO.TextWriter;
      Attributes: System.Collections.Specialized.StringDictionary;
      Name: string;
      IsThreadSafe: boolean;
      IndentLevel: number;
      IndentSize: number;
      Filter: System.Diagnostics.TraceFilter;
      TraceOutputOptions: System.Diagnostics.TraceOptions;
      Close(): void;
      Flush(): void;
      Write(message: string): void;
      WriteLine(message: string): void;
      Dispose(): void;
      Fail(message: string): void;
      Fail(message: string, detailMessage: string): void;
      Write(o: any): void;
      Write(message: string, category: string): void;
      Write(o: any, category: string): void;
      WriteLine(o: any): void;
      WriteLine(message: string, category: string): void;
      WriteLine(o: any, category: string): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, data: any): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, message: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
      TraceTransfer(eventCache: System.Diagnostics.TraceEventCache, source: string, id: number, message: string, relatedActivityId: System.Guid): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CorrelationManager {
      ActivityId: System.Guid;
      LogicalOperationStack: System.Collections.Stack;
      StartLogicalOperation(operationId: any): void;
      StartLogicalOperation(): void;
      StopLogicalOperation(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Debug {
      static Listeners: System.Diagnostics.TraceListenerCollection;
      static AutoFlush: boolean;
      static IndentLevel: number;
      static IndentSize: number;
      static Flush(): void;
      static Close(): void;
      static Assert(condition: boolean): void;
      static Assert(condition: boolean, message: string): void;
      static Assert(condition: boolean, message: string, detailMessage: string): void;
      static Assert(condition: boolean, message: string, detailMessageFormat: string, ...args: any[]): void;
      static Fail(message: string): void;
      static Fail(message: string, detailMessage: string): void;
      static Print(message: string): void;
      static Print(format: string, ...args: any[]): void;
      static Write(message: string): void;
      static Write(value: any): void;
      static Write(message: string, category: string): void;
      static Write(value: any, category: string): void;
      static WriteLine(message: string): void;
      static WriteLine(value: any): void;
      static WriteLine(message: string, category: string): void;
      static WriteLine(value: any, category: string): void;
      static WriteLine(format: string, ...args: any[]): void;
      static WriteIf(condition: boolean, message: string): void;
      static WriteIf(condition: boolean, value: any): void;
      static WriteIf(condition: boolean, message: string, category: string): void;
      static WriteIf(condition: boolean, value: any, category: string): void;
      static WriteLineIf(condition: boolean, message: string): void;
      static WriteLineIf(condition: boolean, value: any): void;
      static WriteLineIf(condition: boolean, message: string, category: string): void;
      static WriteLineIf(condition: boolean, value: any, category: string): void;
      static Indent(): void;
      static Unindent(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DelimitedListTraceListener {
      constructor(stream: System.IO.Stream);
      constructor(stream: System.IO.Stream, name: string);
      constructor(writer: System.IO.TextWriter);
      constructor(writer: System.IO.TextWriter, name: string);
      constructor(fileName: string);
      constructor(fileName: string, name: string);
      Delimiter: string;
      Writer: System.IO.TextWriter;
      Attributes: System.Collections.Specialized.StringDictionary;
      Name: string;
      IsThreadSafe: boolean;
      IndentLevel: number;
      IndentSize: number;
      Filter: System.Diagnostics.TraceFilter;
      TraceOutputOptions: System.Diagnostics.TraceOptions;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, message: string): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, data: any): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
      Close(): void;
      Flush(): void;
      Write(message: string): void;
      WriteLine(message: string): void;
      Dispose(): void;
      Fail(message: string): void;
      Fail(message: string, detailMessage: string): void;
      Write(o: any): void;
      Write(message: string, category: string): void;
      Write(o: any, category: string): void;
      WriteLine(o: any): void;
      WriteLine(message: string, category: string): void;
      WriteLine(o: any, category: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number): void;
      TraceTransfer(eventCache: System.Diagnostics.TraceEventCache, source: string, id: number, message: string, relatedActivityId: System.Guid): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EventTypeFilter {
      constructor(level: System.Diagnostics.SourceLevels);
      EventType: System.Diagnostics.SourceLevels;
      ShouldTrace(cache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, formatOrMessage: string, args: any[], data1: any, data: any[]): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SourceFilter {
      constructor(source: string);
      Source: string;
      ShouldTrace(cache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, formatOrMessage: string, args: any[], data1: any, data: any[]): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum SourceLevels {
      Off = 0,
      Critical = 1,
      Error = 3,
      Warning = 7,
      Information = 15,
      Verbose = 31,
      ActivityTracing = 65280,
      All = -1,
    }
    export class SourceSwitch {
      constructor(name: string);
      constructor(displayName: string, defaultSwitchValue: string);
      Level: System.Diagnostics.SourceLevels;
      Attributes: System.Collections.Specialized.StringDictionary;
      DisplayName: string;
      Description: string;
      ShouldTrace(eventType: System.Diagnostics.TraceEventType): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Switch {
      Attributes: System.Collections.Specialized.StringDictionary;
      DisplayName: string;
      Description: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TextWriterTraceListener {
      constructor();
      constructor(stream: System.IO.Stream);
      constructor(stream: System.IO.Stream, name: string);
      constructor(writer: System.IO.TextWriter);
      constructor(writer: System.IO.TextWriter, name: string);
      constructor(fileName: string);
      constructor(fileName: string, name: string);
      Writer: System.IO.TextWriter;
      Attributes: System.Collections.Specialized.StringDictionary;
      Name: string;
      IsThreadSafe: boolean;
      IndentLevel: number;
      IndentSize: number;
      Filter: System.Diagnostics.TraceFilter;
      TraceOutputOptions: System.Diagnostics.TraceOptions;
      Close(): void;
      Flush(): void;
      Write(message: string): void;
      WriteLine(message: string): void;
      Dispose(): void;
      Fail(message: string): void;
      Fail(message: string, detailMessage: string): void;
      Write(o: any): void;
      Write(message: string, category: string): void;
      Write(o: any, category: string): void;
      WriteLine(o: any): void;
      WriteLine(message: string, category: string): void;
      WriteLine(o: any, category: string): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, data: any): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, message: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
      TraceTransfer(eventCache: System.Diagnostics.TraceEventCache, source: string, id: number, message: string, relatedActivityId: System.Guid): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Trace {
      static Listeners: System.Diagnostics.TraceListenerCollection;
      static AutoFlush: boolean;
      static UseGlobalLock: boolean;
      static CorrelationManager: System.Diagnostics.CorrelationManager;
      static IndentLevel: number;
      static IndentSize: number;
      static Flush(): void;
      static Close(): void;
      static Assert(condition: boolean): void;
      static Assert(condition: boolean, message: string): void;
      static Assert(condition: boolean, message: string, detailMessage: string): void;
      static Fail(message: string): void;
      static Fail(message: string, detailMessage: string): void;
      static Refresh(): void;
      static TraceInformation(message: string): void;
      static TraceInformation(format: string, ...args: any[]): void;
      static TraceWarning(message: string): void;
      static TraceWarning(format: string, ...args: any[]): void;
      static TraceError(message: string): void;
      static TraceError(format: string, ...args: any[]): void;
      static Write(message: string): void;
      static Write(value: any): void;
      static Write(message: string, category: string): void;
      static Write(value: any, category: string): void;
      static WriteLine(message: string): void;
      static WriteLine(value: any): void;
      static WriteLine(message: string, category: string): void;
      static WriteLine(value: any, category: string): void;
      static WriteIf(condition: boolean, message: string): void;
      static WriteIf(condition: boolean, value: any): void;
      static WriteIf(condition: boolean, message: string, category: string): void;
      static WriteIf(condition: boolean, value: any, category: string): void;
      static WriteLineIf(condition: boolean, message: string): void;
      static WriteLineIf(condition: boolean, value: any): void;
      static WriteLineIf(condition: boolean, message: string, category: string): void;
      static WriteLineIf(condition: boolean, value: any, category: string): void;
      static Indent(): void;
      static Unindent(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TraceEventCache {
      constructor();
      Callstack: string;
      LogicalOperationStack: System.Collections.Stack;
      DateTime: System.DateTime;
      ProcessId: number;
      ThreadId: string;
      Timestamp: number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum TraceEventType {
      Critical = 1,
      Error = 2,
      Warning = 4,
      Information = 8,
      Verbose = 16,
      Start = 256,
      Stop = 512,
      Suspend = 1024,
      Resume = 2048,
      Transfer = 4096,
    }
    export class TraceFilter {
      ShouldTrace(cache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, formatOrMessage: string, args: any[], data1: any, data: any[]): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum TraceLevel {
      Off = 0,
      Error = 1,
      Warning = 2,
      Info = 3,
      Verbose = 4,
    }
    export class TraceListener {
      Attributes: System.Collections.Specialized.StringDictionary;
      Name: string;
      IsThreadSafe: boolean;
      IndentLevel: number;
      IndentSize: number;
      Filter: System.Diagnostics.TraceFilter;
      TraceOutputOptions: System.Diagnostics.TraceOptions;
      Dispose(): void;
      Close(): void;
      Flush(): void;
      Fail(message: string): void;
      Fail(message: string, detailMessage: string): void;
      Write(message: string): void;
      Write(o: any): void;
      Write(message: string, category: string): void;
      Write(o: any, category: string): void;
      WriteLine(message: string): void;
      WriteLine(o: any): void;
      WriteLine(message: string, category: string): void;
      WriteLine(o: any, category: string): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, data: any): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, message: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
      TraceTransfer(eventCache: System.Diagnostics.TraceEventCache, source: string, id: number, message: string, relatedActivityId: System.Guid): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TraceListenerCollection {
      Count: number;
      Add(listener: System.Diagnostics.TraceListener): number;
      AddRange(value: System.Diagnostics.TraceListener[]): void;
      AddRange(value: System.Diagnostics.TraceListenerCollection): void;
      Clear(): void;
      Contains(listener: System.Diagnostics.TraceListener): boolean;
      CopyTo(listeners: System.Diagnostics.TraceListener[], index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      IndexOf(listener: System.Diagnostics.TraceListener): number;
      Insert(index: number, listener: System.Diagnostics.TraceListener): void;
      Remove(listener: System.Diagnostics.TraceListener): void;
      Remove(name: string): void;
      RemoveAt(index: number): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum TraceOptions {
      None = 0,
      LogicalOperationStack = 1,
      DateTime = 2,
      Timestamp = 4,
      ProcessId = 8,
      ThreadId = 16,
      Callstack = 32,
    }
    export class TraceSource {
      constructor(name: string);
      constructor(name: string, defaultLevel: System.Diagnostics.SourceLevels);
      Attributes: System.Collections.Specialized.StringDictionary;
      Name: string;
      Listeners: System.Diagnostics.TraceListenerCollection;
      Switch: System.Diagnostics.SourceSwitch;
      Close(): void;
      Flush(): void;
      TraceEvent(eventType: System.Diagnostics.TraceEventType, id: number): void;
      TraceEvent(eventType: System.Diagnostics.TraceEventType, id: number, message: string): void;
      TraceEvent(eventType: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
      TraceData(eventType: System.Diagnostics.TraceEventType, id: number, data: any): void;
      TraceData(eventType: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
      TraceInformation(message: string): void;
      TraceInformation(format: string, ...args: any[]): void;
      TraceTransfer(id: number, message: string, relatedActivityId: System.Guid): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TraceSwitch {
      constructor(displayName: string, description: string);
      constructor(displayName: string, description: string, defaultSwitchValue: string);
      Level: System.Diagnostics.TraceLevel;
      TraceError: boolean;
      TraceWarning: boolean;
      TraceInfo: boolean;
      TraceVerbose: boolean;
      Attributes: System.Collections.Specialized.StringDictionary;
      DisplayName: string;
      Description: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class XmlWriterTraceListener {
      constructor(stream: System.IO.Stream);
      constructor(stream: System.IO.Stream, name: string);
      constructor(writer: System.IO.TextWriter);
      constructor(writer: System.IO.TextWriter, name: string);
      constructor(filename: string);
      constructor(filename: string, name: string);
      Writer: System.IO.TextWriter;
      Attributes: System.Collections.Specialized.StringDictionary;
      Name: string;
      IsThreadSafe: boolean;
      IndentLevel: number;
      IndentSize: number;
      Filter: System.Diagnostics.TraceFilter;
      TraceOutputOptions: System.Diagnostics.TraceOptions;
      Write(message: string): void;
      WriteLine(message: string): void;
      Fail(message: string, detailMessage: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, message: string): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, data: any): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
      Close(): void;
      TraceTransfer(eventCache: System.Diagnostics.TraceEventCache, source: string, id: number, message: string, relatedActivityId: System.Guid): void;
      Flush(): void;
      Dispose(): void;
      Fail(message: string): void;
      Write(o: any): void;
      Write(message: string, category: string): void;
      Write(o: any, category: string): void;
      WriteLine(o: any): void;
      WriteLine(message: string, category: string): void;
      WriteLine(o: any, category: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Process {
      constructor();
      ExitCode: number;
      HasExited: boolean;
      ExitTime: System.DateTime;
      Handle: System.IntPtr;
      SafeHandle: any; // Microsoft.Win32.SafeHandles.SafeProcessHandle
      Id: number;
      MachineName: string;
      MaxWorkingSet: System.IntPtr;
      MinWorkingSet: System.IntPtr;
      PriorityClass: System.Diagnostics.ProcessPriorityClass;
      PrivilegedProcessorTime: System.TimeSpan;
      StartInfo: System.Diagnostics.ProcessStartInfo;
      StartTime: System.DateTime;
      SynchronizingObject: System.ComponentModel.ISynchronizeInvoke;
      TotalProcessorTime: System.TimeSpan;
      UserProcessorTime: System.TimeSpan;
      EnableRaisingEvents: boolean;
      StandardInput: System.IO.StreamWriter;
      StandardOutput: System.IO.StreamReader;
      StandardError: System.IO.StreamReader;
      BasePriority: number;
      HandleCount: number;
      MainModule: System.Diagnostics.ProcessModule;
      MainWindowHandle: System.IntPtr;
      MainWindowTitle: string;
      Modules: System.Diagnostics.ProcessModuleCollection;
      NonpagedSystemMemorySize: number;
      PagedMemorySize: number;
      PagedSystemMemorySize: number;
      PeakPagedMemorySize: number;
      PeakVirtualMemorySize: number;
      PeakWorkingSet: number;
      NonpagedSystemMemorySize64: number;
      PagedMemorySize64: number;
      PagedSystemMemorySize64: number;
      PeakPagedMemorySize64: number;
      PeakVirtualMemorySize64: number;
      PeakWorkingSet64: number;
      PriorityBoostEnabled: boolean;
      PrivateMemorySize: number;
      SessionId: number;
      ProcessName: string;
      ProcessorAffinity: System.IntPtr;
      Responding: boolean;
      Threads: System.Diagnostics.ProcessThreadCollection;
      VirtualMemorySize: number;
      WorkingSet: number;
      PrivateMemorySize64: number;
      VirtualMemorySize64: number;
      WorkingSet64: number;
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      Close(): void;
      static EnterDebugMode(): void;
      static LeaveDebugMode(): void;
      static GetProcessById(processId: number): System.Diagnostics.Process;
      static GetProcessesByName(processName: string): System.Diagnostics.Process[];
      static GetProcesses(): System.Diagnostics.Process[];
      static GetCurrentProcess(): System.Diagnostics.Process;
      Refresh(): void;
      Start(): boolean;
      static Start(fileName: string, userName: string, password: System.Security.SecureString, domain: string): System.Diagnostics.Process;
      static Start(fileName: string, argumentsCS: string, userName: string, password: System.Security.SecureString, domain: string): System.Diagnostics.Process;
      static Start(fileName: string): System.Diagnostics.Process;
      static Start(fileName: string, argumentsCS: string): System.Diagnostics.Process;
      static Start(startInfo: System.Diagnostics.ProcessStartInfo): System.Diagnostics.Process;
      Kill(): void;
      ToString(): string;
      WaitForExit(milliseconds: number): boolean;
      WaitForExit(): void;
      WaitForInputIdle(milliseconds: number): boolean;
      WaitForInputIdle(): boolean;
      BeginOutputReadLine(): void;
      BeginErrorReadLine(): void;
      CancelOutputRead(): void;
      CancelErrorRead(): void;
      CloseMainWindow(): boolean;
      static GetProcessById(processId: number, machineName: string): System.Diagnostics.Process;
      static GetProcessesByName(processName: string, machineName: string): System.Diagnostics.Process[];
      static GetProcesses(machineName: string): System.Diagnostics.Process[];
      Dispose(): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ProcessModuleCollection {
      constructor(processModules: System.Diagnostics.ProcessModule[]);
      Count: number;
      IndexOf(module: System.Diagnostics.ProcessModule): number;
      Contains(module: System.Diagnostics.ProcessModule): boolean;
      CopyTo(array: System.Diagnostics.ProcessModule[], index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ProcessStartInfo {
      constructor();
      constructor(fileName: string);
      constructor(fileName: string, argumentsCS: string);
      ArgumentList: string[];
      Verb: string;
      Arguments: string;
      CreateNoWindow: boolean;
      EnvironmentVariables: System.Collections.Specialized.StringDictionary;
      Environment: Record<string, string>;
      RedirectStandardInput: boolean;
      RedirectStandardOutput: boolean;
      RedirectStandardError: boolean;
      StandardErrorEncoding: System.Text.Encoding;
      StandardOutputEncoding: System.Text.Encoding;
      UseShellExecute: boolean;
      UserName: string;
      Password: System.Security.SecureString;
      PasswordInClearText: string;
      Domain: string;
      LoadUserProfile: boolean;
      FileName: string;
      WorkingDirectory: string;
      ErrorDialog: boolean;
      ErrorDialogParentHandle: System.IntPtr;
      WindowStyle: System.Diagnostics.ProcessWindowStyle;
      StandardInputEncoding: System.Text.Encoding;
      Verbs: string[];
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ProcessThreadCollection {
      constructor(processThreads: System.Diagnostics.ProcessThread[]);
      Count: number;
      Add(thread: System.Diagnostics.ProcessThread): number;
      Insert(index: number, thread: System.Diagnostics.ProcessThread): void;
      IndexOf(thread: System.Diagnostics.ProcessThread): number;
      Contains(thread: System.Diagnostics.ProcessThread): boolean;
      Remove(thread: System.Diagnostics.ProcessThread): void;
      CopyTo(array: System.Diagnostics.ProcessThread[], index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CounterCreationData {
      constructor();
      constructor(counterName: string, counterHelp: string, counterType: System.Diagnostics.PerformanceCounterType);
      CounterHelp: string;
      CounterName: string;
      CounterType: System.Diagnostics.PerformanceCounterType;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CounterCreationDataCollection {
      constructor();
      constructor(value: System.Diagnostics.CounterCreationData[]);
      constructor(value: System.Diagnostics.CounterCreationDataCollection);
      Capacity: number;
      Count: number;
      Add(value: System.Diagnostics.CounterCreationData): number;
      AddRange(value: System.Diagnostics.CounterCreationData[]): void;
      AddRange(value: System.Diagnostics.CounterCreationDataCollection): void;
      Contains(value: System.Diagnostics.CounterCreationData): boolean;
      CopyTo(array: System.Diagnostics.CounterCreationData[], index: number): void;
      IndexOf(value: System.Diagnostics.CounterCreationData): number;
      Insert(index: number, value: System.Diagnostics.CounterCreationData): void;
      Remove(value: System.Diagnostics.CounterCreationData): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CounterSample {
      constructor(rawValue: number, baseValue: number, counterFrequency: number, systemFrequency: number, timeStamp: number, timeStamp100nSec: number, counterType: System.Diagnostics.PerformanceCounterType);
      constructor(rawValue: number, baseValue: number, counterFrequency: number, systemFrequency: number, timeStamp: number, timeStamp100nSec: number, counterType: System.Diagnostics.PerformanceCounterType, counterTimeStamp: number);
      BaseValue: number;
      CounterFrequency: number;
      CounterTimeStamp: number;
      CounterType: System.Diagnostics.PerformanceCounterType;
      RawValue: number;
      SystemFrequency: number;
      TimeStamp: number;
      TimeStamp100nSec: number;
      static Empty: System.Diagnostics.CounterSample;
      static Calculate(counterSample: System.Diagnostics.CounterSample): number;
      static Calculate(counterSample: System.Diagnostics.CounterSample, nextCounterSample: System.Diagnostics.CounterSample): number;
      Equals(o: any): boolean;
      Equals(sample: System.Diagnostics.CounterSample): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class CounterSampleCalculator {
      static ComputeCounterValue(newSample: System.Diagnostics.CounterSample): number;
      static ComputeCounterValue(oldSample: System.Diagnostics.CounterSample, newSample: System.Diagnostics.CounterSample): number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DataReceivedEventArgs {
      Data: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DataReceivedEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.Diagnostics.DataReceivedEventArgs): void;
      BeginInvoke(sender: any, e: System.Diagnostics.DataReceivedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DefaultTraceListener {
      constructor();
      AssertUiEnabled: boolean;
      LogFileName: string;
      Attributes: System.Collections.Specialized.StringDictionary;
      Name: string;
      IsThreadSafe: boolean;
      IndentLevel: number;
      IndentSize: number;
      Filter: System.Diagnostics.TraceFilter;
      TraceOutputOptions: System.Diagnostics.TraceOptions;
      Fail(message: string): void;
      Fail(message: string, detailMessage: string): void;
      Write(message: string): void;
      WriteLine(message: string): void;
      Dispose(): void;
      Close(): void;
      Flush(): void;
      Write(o: any): void;
      Write(message: string, category: string): void;
      Write(o: any, category: string): void;
      WriteLine(o: any): void;
      WriteLine(message: string, category: string): void;
      WriteLine(o: any, category: string): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, data: any): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, message: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
      TraceTransfer(eventCache: System.Diagnostics.TraceEventCache, source: string, id: number, message: string, relatedActivityId: System.Guid): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DiagnosticsConfigurationHandler {
      constructor();
      Create(parent: any, configContext: any, section: any): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EntryWrittenEventArgs {
      constructor();
      constructor(entry: System.Diagnostics.EventLogEntry);
      Entry: System.Diagnostics.EventLogEntry;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EntryWrittenEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.Diagnostics.EntryWrittenEventArgs): void;
      BeginInvoke(sender: any, e: System.Diagnostics.EntryWrittenEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EventInstance {
      constructor(instanceId: number, categoryId: number);
      constructor(instanceId: number, categoryId: number, entryType: System.Diagnostics.EventLogEntryType);
      CategoryId: number;
      EntryType: System.Diagnostics.EventLogEntryType;
      InstanceId: number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EventLog {
      constructor();
      constructor(logName: string);
      constructor(logName: string, machineName: string);
      constructor(logName: string, machineName: string, source: string);
      EnableRaisingEvents: boolean;
      Entries: System.Diagnostics.EventLogEntryCollection;
      Log: string;
      LogDisplayName: string;
      MachineName: string;
      Source: string;
      SynchronizingObject: System.ComponentModel.ISynchronizeInvoke;
      OverflowAction: System.Diagnostics.OverflowAction;
      MinimumRetentionDays: number;
      MaximumKilobytes: number;
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      ModifyOverflowPolicy(action: System.Diagnostics.OverflowAction, retentionDays: number): void;
      RegisterDisplayName(resourceFile: string, resourceId: number): void;
      BeginInit(): void;
      Clear(): void;
      Close(): void;
      static CreateEventSource(source: string, logName: string): void;
      static CreateEventSource(source: string, logName: string, machineName: string): void;
      static CreateEventSource(sourceData: System.Diagnostics.EventSourceCreationData): void;
      static Delete(logName: string): void;
      static Delete(logName: string, machineName: string): void;
      static DeleteEventSource(source: string): void;
      static DeleteEventSource(source: string, machineName: string): void;
      EndInit(): void;
      static Exists(logName: string): boolean;
      static Exists(logName: string, machineName: string): boolean;
      static GetEventLogs(): System.Diagnostics.EventLog[];
      static GetEventLogs(machineName: string): System.Diagnostics.EventLog[];
      static LogNameFromSourceName(source: string, machineName: string): string;
      static SourceExists(source: string): boolean;
      static SourceExists(source: string, machineName: string): boolean;
      WriteEntry(message: string): void;
      WriteEntry(message: string, type: System.Diagnostics.EventLogEntryType): void;
      WriteEntry(message: string, type: System.Diagnostics.EventLogEntryType, eventID: number): void;
      WriteEntry(message: string, type: System.Diagnostics.EventLogEntryType, eventID: number, category: number): void;
      WriteEntry(message: string, type: System.Diagnostics.EventLogEntryType, eventID: number, category: number, rawData: Byte[]): void;
      static WriteEntry(source: string, message: string): void;
      static WriteEntry(source: string, message: string, type: System.Diagnostics.EventLogEntryType): void;
      static WriteEntry(source: string, message: string, type: System.Diagnostics.EventLogEntryType, eventID: number): void;
      static WriteEntry(source: string, message: string, type: System.Diagnostics.EventLogEntryType, eventID: number, category: number): void;
      static WriteEntry(source: string, message: string, type: System.Diagnostics.EventLogEntryType, eventID: number, category: number, rawData: Byte[]): void;
      WriteEvent(instance: System.Diagnostics.EventInstance, ...values: any[]): void;
      WriteEvent(instance: System.Diagnostics.EventInstance, data: Byte[], ...values: any[]): void;
      static WriteEvent(source: string, instance: System.Diagnostics.EventInstance, ...values: any[]): void;
      static WriteEvent(source: string, instance: System.Diagnostics.EventInstance, data: Byte[], ...values: any[]): void;
      Dispose(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class EventLogEntry {
      Category: string;
      CategoryNumber: number;
      Data: Byte[];
      EntryType: System.Diagnostics.EventLogEntryType;
      EventID: number;
      Index: number;
      InstanceId: number;
      MachineName: string;
      Message: string;
      ReplacementStrings: string[];
      Source: string;
      TimeGenerated: System.DateTime;
      TimeWritten: System.DateTime;
      UserName: string;
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      Equals(otherEntry: System.Diagnostics.EventLogEntry): boolean;
      Dispose(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class EventLogEntryCollection {
      Count: number;
      CopyTo(entries: System.Diagnostics.EventLogEntry[], index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum EventLogEntryType {
      Error = 1,
      Warning = 2,
      Information = 4,
      SuccessAudit = 8,
      FailureAudit = 16,
    }
    export class EventLogPermission {
      constructor();
      constructor(permissionAccessEntries: System.Diagnostics.EventLogPermissionEntry[]);
      constructor(state: System.Security.Permissions.PermissionState);
      constructor(permissionAccess: System.Diagnostics.EventLogPermissionAccess, machineName: string);
      PermissionEntries: System.Diagnostics.EventLogPermissionEntryCollection;
      Copy(): System.Security.IPermission;
      FromXml(securityElement: System.Security.SecurityElement): void;
      Intersect(target: System.Security.IPermission): System.Security.IPermission;
      IsSubsetOf(target: System.Security.IPermission): boolean;
      IsUnrestricted(): boolean;
      ToXml(): System.Security.SecurityElement;
      Union(target: System.Security.IPermission): System.Security.IPermission;
      Assert(): void;
      Demand(): void;
      Deny(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      PermitOnly(): void;
      GetType(): System.Type;
    }
    export enum EventLogPermissionAccess {
      None = 0,
      Browse = 2,
      Instrument = 6,
      Audit = 10,
      Write = 16,
      Administer = 48,
    }
    export class EventLogPermissionEntry {
      constructor(permissionAccess: System.Diagnostics.EventLogPermissionAccess, machineName: string);
      MachineName: string;
      PermissionAccess: System.Diagnostics.EventLogPermissionAccess;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EventLogPermissionEntryCollection {
      Capacity: number;
      Count: number;
      Add(value: System.Diagnostics.EventLogPermissionEntry): number;
      AddRange(value: System.Diagnostics.EventLogPermissionEntry[]): void;
      AddRange(value: System.Diagnostics.EventLogPermissionEntryCollection): void;
      Contains(value: System.Diagnostics.EventLogPermissionEntry): boolean;
      CopyTo(array: System.Diagnostics.EventLogPermissionEntry[], index: number): void;
      IndexOf(value: System.Diagnostics.EventLogPermissionEntry): number;
      Insert(index: number, value: System.Diagnostics.EventLogPermissionEntry): void;
      Remove(value: System.Diagnostics.EventLogPermissionEntry): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EventLogTraceListener {
      constructor();
      constructor(eventLog: System.Diagnostics.EventLog);
      constructor(source: string);
      EventLog: System.Diagnostics.EventLog;
      Name: string;
      Attributes: System.Collections.Specialized.StringDictionary;
      IsThreadSafe: boolean;
      IndentLevel: number;
      IndentSize: number;
      Filter: System.Diagnostics.TraceFilter;
      TraceOutputOptions: System.Diagnostics.TraceOptions;
      Close(): void;
      Write(message: string): void;
      WriteLine(message: string): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, severity: System.Diagnostics.TraceEventType, id: number, data: any): void;
      TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, severity: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, severity: System.Diagnostics.TraceEventType, id: number, message: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, severity: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
      Dispose(): void;
      Flush(): void;
      Fail(message: string): void;
      Fail(message: string, detailMessage: string): void;
      Write(o: any): void;
      Write(message: string, category: string): void;
      Write(o: any, category: string): void;
      WriteLine(o: any): void;
      WriteLine(message: string, category: string): void;
      WriteLine(o: any, category: string): void;
      TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number): void;
      TraceTransfer(eventCache: System.Diagnostics.TraceEventCache, source: string, id: number, message: string, relatedActivityId: System.Guid): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EventSourceCreationData {
      constructor(source: string, logName: string);
      CategoryCount: number;
      CategoryResourceFile: string;
      LogName: string;
      MachineName: string;
      MessageResourceFile: string;
      ParameterResourceFile: string;
      Source: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class FileVersionInfo {
      Comments: string;
      CompanyName: string;
      FileBuildPart: number;
      FileDescription: string;
      FileMajorPart: number;
      FileMinorPart: number;
      FileName: string;
      FilePrivatePart: number;
      FileVersion: string;
      InternalName: string;
      IsDebug: boolean;
      IsPatched: boolean;
      IsPreRelease: boolean;
      IsPrivateBuild: boolean;
      IsSpecialBuild: boolean;
      Language: string;
      LegalCopyright: string;
      LegalTrademarks: string;
      OriginalFilename: string;
      PrivateBuild: string;
      ProductBuildPart: number;
      ProductMajorPart: number;
      ProductMinorPart: number;
      ProductName: string;
      ProductPrivatePart: number;
      ProductVersion: string;
      SpecialBuild: string;
      static GetVersionInfo(fileName: string): System.Diagnostics.FileVersionInfo;
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export interface ICollectData {
      CloseData(): void;
    }
    export class InstanceData {
      constructor(instanceName: string, sample: System.Diagnostics.CounterSample);
      InstanceName: string;
      RawValue: number;
      Sample: System.Diagnostics.CounterSample;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class InstanceDataCollection {
      constructor(counterName: string);
      CounterName: string;
      Keys: System.Collections.ICollection;
      Values: System.Collections.ICollection;
      Count: number;
      Contains(instanceName: string): boolean;
      CopyTo(instances: System.Diagnostics.InstanceData[], index: number): void;
      CopyTo(array: System.Array, index: number): void;
      Clear(): void;
      GetEnumerator(): System.Collections.IDictionaryEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class InstanceDataCollectionCollection {
      constructor();
      Keys: System.Collections.ICollection;
      Values: System.Collections.ICollection;
      Count: number;
      Contains(counterName: string): boolean;
      CopyTo(counters: System.Diagnostics.InstanceDataCollection[], index: number): void;
      CopyTo(array: System.Array, index: number): void;
      Clear(): void;
      GetEnumerator(): System.Collections.IDictionaryEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum OverflowAction {
      DoNotOverwrite = -1,
      OverwriteAsNeeded = 0,
      OverwriteOlder = 1,
    }
    export class PerformanceCounter {
      constructor();
      constructor(categoryName: string, counterName: string);
      constructor(categoryName: string, counterName: string, readOnly: boolean);
      constructor(categoryName: string, counterName: string, instanceName: string);
      constructor(categoryName: string, counterName: string, instanceName: string, readOnly: boolean);
      constructor(categoryName: string, counterName: string, instanceName: string, machineName: string);
      CategoryName: string;
      CounterHelp: string;
      CounterName: string;
      CounterType: System.Diagnostics.PerformanceCounterType;
      InstanceLifetime: System.Diagnostics.PerformanceCounterInstanceLifetime;
      InstanceName: string;
      MachineName: string;
      RawValue: number;
      ReadOnly: boolean;
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      static DefaultFileMappingSize: number;
      BeginInit(): void;
      EndInit(): void;
      Close(): void;
      static CloseSharedResources(): void;
      Decrement(): number;
      Increment(): number;
      IncrementBy(value: number): number;
      NextSample(): System.Diagnostics.CounterSample;
      NextValue(): number;
      RemoveInstance(): void;
      Dispose(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class PerformanceCounterCategory {
      constructor();
      constructor(categoryName: string);
      constructor(categoryName: string, machineName: string);
      CategoryHelp: string;
      CategoryName: string;
      MachineName: string;
      CategoryType: System.Diagnostics.PerformanceCounterCategoryType;
      CounterExists(counterName: string): boolean;
      static CounterExists(counterName: string, categoryName: string): boolean;
      static CounterExists(counterName: string, categoryName: string, machineName: string): boolean;
      static Create(categoryName: string, categoryHelp: string, counterData: System.Diagnostics.CounterCreationDataCollection): System.Diagnostics.PerformanceCounterCategory;
      static Create(categoryName: string, categoryHelp: string, counterName: string, counterHelp: string): System.Diagnostics.PerformanceCounterCategory;
      static Create(categoryName: string, categoryHelp: string, categoryType: System.Diagnostics.PerformanceCounterCategoryType, counterData: System.Diagnostics.CounterCreationDataCollection): System.Diagnostics.PerformanceCounterCategory;
      static Create(categoryName: string, categoryHelp: string, categoryType: System.Diagnostics.PerformanceCounterCategoryType, counterName: string, counterHelp: string): System.Diagnostics.PerformanceCounterCategory;
      static Delete(categoryName: string): void;
      static Exists(categoryName: string): boolean;
      static Exists(categoryName: string, machineName: string): boolean;
      static GetCategories(): System.Diagnostics.PerformanceCounterCategory[];
      static GetCategories(machineName: string): System.Diagnostics.PerformanceCounterCategory[];
      GetCounters(): System.Diagnostics.PerformanceCounter[];
      GetCounters(instanceName: string): System.Diagnostics.PerformanceCounter[];
      GetInstanceNames(): string[];
      InstanceExists(instanceName: string): boolean;
      static InstanceExists(instanceName: string, categoryName: string): boolean;
      static InstanceExists(instanceName: string, categoryName: string, machineName: string): boolean;
      ReadCategory(): System.Diagnostics.InstanceDataCollectionCollection;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum PerformanceCounterCategoryType {
      SingleInstance = 0,
      MultiInstance = 1,
      Unknown = -1,
    }
    export enum PerformanceCounterInstanceLifetime {
      Global = 0,
      Process = 1,
    }
    export class PerformanceCounterManager {
      constructor();
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PerformanceCounterPermission {
      constructor();
      constructor(permissionAccessEntries: System.Diagnostics.PerformanceCounterPermissionEntry[]);
      constructor(state: System.Security.Permissions.PermissionState);
      constructor(permissionAccess: System.Diagnostics.PerformanceCounterPermissionAccess, machineName: string, categoryName: string);
      PermissionEntries: System.Diagnostics.PerformanceCounterPermissionEntryCollection;
      Copy(): System.Security.IPermission;
      FromXml(securityElement: System.Security.SecurityElement): void;
      Intersect(target: System.Security.IPermission): System.Security.IPermission;
      IsSubsetOf(target: System.Security.IPermission): boolean;
      IsUnrestricted(): boolean;
      ToXml(): System.Security.SecurityElement;
      Union(target: System.Security.IPermission): System.Security.IPermission;
      Assert(): void;
      Demand(): void;
      Deny(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      PermitOnly(): void;
      GetType(): System.Type;
    }
    export enum PerformanceCounterPermissionAccess {
      None = 0,
      Browse = 1,
      Read = 1,
      Write = 2,
      Instrument = 3,
      Administer = 7,
    }
    export class PerformanceCounterPermissionEntry {
      constructor(permissionAccess: System.Diagnostics.PerformanceCounterPermissionAccess, machineName: string, categoryName: string);
      CategoryName: string;
      MachineName: string;
      PermissionAccess: System.Diagnostics.PerformanceCounterPermissionAccess;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PerformanceCounterPermissionEntryCollection {
      Capacity: number;
      Count: number;
      Add(value: System.Diagnostics.PerformanceCounterPermissionEntry): number;
      AddRange(value: System.Diagnostics.PerformanceCounterPermissionEntry[]): void;
      AddRange(value: System.Diagnostics.PerformanceCounterPermissionEntryCollection): void;
      Contains(value: System.Diagnostics.PerformanceCounterPermissionEntry): boolean;
      CopyTo(array: System.Diagnostics.PerformanceCounterPermissionEntry[], index: number): void;
      IndexOf(value: System.Diagnostics.PerformanceCounterPermissionEntry): number;
      Insert(index: number, value: System.Diagnostics.PerformanceCounterPermissionEntry): void;
      Remove(value: System.Diagnostics.PerformanceCounterPermissionEntry): void;
      Clear(): void;
      RemoveAt(index: number): void;
      GetEnumerator(): System.Collections.IEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum PerformanceCounterType {
      NumberOfItemsHEX32 = 0,
      NumberOfItemsHEX64 = 256,
      NumberOfItems32 = 65536,
      NumberOfItems64 = 65792,
      CounterDelta32 = 4195328,
      CounterDelta64 = 4195584,
      SampleCounter = 4260864,
      CountPerTimeInterval32 = 4523008,
      CountPerTimeInterval64 = 4523264,
      RateOfCountsPerSecond32 = 272696320,
      RateOfCountsPerSecond64 = 272696576,
      RawFraction = 537003008,
      CounterTimer = 541132032,
      Timer100Ns = 542180608,
      SampleFraction = 549585920,
      CounterTimerInverse = 557909248,
      Timer100NsInverse = 558957824,
      CounterMultiTimer = 574686464,
      CounterMultiTimer100Ns = 575735040,
      CounterMultiTimerInverse = 591463680,
      CounterMultiTimer100NsInverse = 592512256,
      AverageTimer32 = 805438464,
      ElapsedTime = 807666944,
      AverageCount64 = 1073874176,
      SampleBase = 1073939457,
      AverageBase = 1073939458,
      RawBase = 1073939459,
      CounterMultiBase = 1107494144,
    }
    export class ProcessModule {
      BaseAddress: System.IntPtr;
      EntryPointAddress: System.IntPtr;
      FileName: string;
      FileVersionInfo: System.Diagnostics.FileVersionInfo;
      ModuleMemorySize: number;
      ModuleName: string;
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      ToString(): string;
      Dispose(): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum ProcessPriorityClass {
      AboveNormal = 32768,
      BelowNormal = 16384,
      High = 128,
      Idle = 64,
      Normal = 32,
      RealTime = 256,
    }
    export class ProcessThread {
      BasePriority: number;
      CurrentPriority: number;
      Id: number;
      IdealProcessor: number;
      PriorityBoostEnabled: boolean;
      PriorityLevel: System.Diagnostics.ThreadPriorityLevel;
      PrivilegedProcessorTime: System.TimeSpan;
      ProcessorAffinity: System.IntPtr;
      StartAddress: System.IntPtr;
      StartTime: System.DateTime;
      ThreadState: System.Diagnostics.ThreadState;
      TotalProcessorTime: System.TimeSpan;
      UserProcessorTime: System.TimeSpan;
      WaitReason: System.Diagnostics.ThreadWaitReason;
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      ResetIdealProcessor(): void;
      Dispose(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum ProcessWindowStyle {
      Hidden = 1,
      Maximized = 3,
      Minimized = 2,
      Normal = 0,
    }
    export class Stopwatch {
      constructor();
      Elapsed: System.TimeSpan;
      ElapsedMilliseconds: number;
      ElapsedTicks: number;
      IsRunning: boolean;
      static Frequency: number;
      static IsHighResolution: boolean;
      static GetTimestamp(): number;
      static StartNew(): System.Diagnostics.Stopwatch;
      Reset(): void;
      Start(): void;
      Stop(): void;
      Restart(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum ThreadPriorityLevel {
      AboveNormal = 1,
      BelowNormal = -1,
      Highest = 2,
      Idle = -15,
      Lowest = -2,
      Normal = 0,
      TimeCritical = 15,
    }
    export enum ThreadState {
      Initialized = 0,
      Ready = 1,
      Running = 2,
      Standby = 3,
      Terminated = 4,
      Transition = 6,
      Unknown = 7,
      Wait = 5,
    }
    export enum ThreadWaitReason {
      EventPairHigh = 7,
      EventPairLow = 8,
      ExecutionDelay = 4,
      Executive = 0,
      FreePage = 1,
      LpcReceive = 9,
      LpcReply = 10,
      PageIn = 2,
      PageOut = 12,
      Suspended = 5,
      SystemAllocation = 3,
      Unknown = 13,
      UserRequest = 6,
      VirtualMemory = 11,
    }
    export namespace Contracts {
      export class Contract {
        static Assume(condition: boolean): void;
        static Assume(condition: boolean, userMessage: string): void;
        static Assert(condition: boolean): void;
        static Assert(condition: boolean, userMessage: string): void;
        static Requires(condition: boolean): void;
        static Requires(condition: boolean, userMessage: string): void;
        static Ensures(condition: boolean): void;
        static Ensures(condition: boolean, userMessage: string): void;
        static Invariant(condition: boolean): void;
        static Invariant(condition: boolean, userMessage: string): void;
        static ForAll(fromInclusive: number, toExclusive: number, predicate: ((obj: number) => boolean)): boolean;
        static Exists(fromInclusive: number, toExclusive: number, predicate: ((obj: number) => boolean)): boolean;
        static EndContractBlock(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum ContractFailureKind {
        Precondition = 0,
        Postcondition = 1,
        PostconditionOnException = 2,
        Invariant = 3,
        Assert = 4,
        Assume = 5,
      }
      export class ContractFailedEventArgs {
        constructor(failureKind: System.Diagnostics.Contracts.ContractFailureKind, message: string, condition: string, originalException: System.Exception);
        Message: string;
        Condition: string;
        FailureKind: System.Diagnostics.Contracts.ContractFailureKind;
        OriginalException: System.Exception;
        Handled: boolean;
        Unwind: boolean;
        SetHandled(): void;
        SetUnwind(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export namespace Internal {
        export class ContractHelper {
          static RaiseContractFailedEvent(failureKind: System.Diagnostics.Contracts.ContractFailureKind, userMessage: string, conditionText: string, innerException: System.Exception): string;
          static TriggerFailure(kind: System.Diagnostics.Contracts.ContractFailureKind, displayMessage: string, userMessage: string, conditionText: string, innerException: System.Exception): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
      }
    }
    export namespace Eventing {
      export class EventDescriptor {
        constructor(id: number, version: Byte, channel: Byte, level: Byte, opcode: Byte, task: number, keywords: number);
        Channel: Byte;
        EventId: number;
        Keywords: number;
        Level: Byte;
        Opcode: Byte;
        Task: number;
        Version: Byte;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class EventProvider {
        constructor(providerGuid: System.Guid);
        Close(): void;
        static CreateActivityId(): System.Guid;
        Dispose(): void;
        static GetLastWriteEventError(): System.Diagnostics.Eventing.EventProvider_WriteEventErrorCode;
        IsEnabled(): boolean;
        IsEnabled(level: Byte, keywords: number): boolean;
        WriteMessageEvent(eventMessage: string): boolean;
        WriteMessageEvent(eventMessage: string, eventLevel: Byte, eventKeywords: number): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum EventProvider_WriteEventErrorCode {
        EventTooBig = 2,
        NoError = 0,
        NoFreeBuffers = 1,
      }
      export class EventProviderTraceListener {
        constructor(providerId: string);
        constructor(providerId: string, name: string);
        constructor(providerId: string, name: string, delimiter: string);
        Delimiter: string;
        Attributes: System.Collections.Specialized.StringDictionary;
        Name: string;
        IsThreadSafe: boolean;
        IndentLevel: number;
        IndentSize: number;
        Filter: System.Diagnostics.TraceFilter;
        TraceOutputOptions: System.Diagnostics.TraceOptions;
        Write(message: string): void;
        WriteLine(message: string): void;
        Dispose(): void;
        Close(): void;
        Flush(): void;
        Fail(message: string): void;
        Fail(message: string, detailMessage: string): void;
        Write(o: any): void;
        Write(message: string, category: string): void;
        Write(o: any, category: string): void;
        WriteLine(o: any): void;
        WriteLine(message: string, category: string): void;
        WriteLine(o: any, category: string): void;
        TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, data: any): void;
        TraceData(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, ...data: any[]): void;
        TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number): void;
        TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, message: string): void;
        TraceEvent(eventCache: System.Diagnostics.TraceEventCache, source: string, eventType: System.Diagnostics.TraceEventType, id: number, format: string, ...args: any[]): void;
        TraceTransfer(eventCache: System.Diagnostics.TraceEventCache, source: string, id: number, message: string, relatedActivityId: System.Guid): void;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export namespace Reader {
        export class EventBookmark {
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventKeyword {
          DisplayName: string;
          Name: string;
          Value: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventLevel {
          DisplayName: string;
          Name: string;
          Value: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventLogConfiguration {
          constructor(logName: string);
          constructor(logName: string, session: System.Diagnostics.Eventing.Reader.EventLogSession);
          IsClassicLog: boolean;
          IsEnabled: boolean;
          LogFilePath: string;
          LogIsolation: System.Diagnostics.Eventing.Reader.EventLogIsolation;
          LogMode: System.Diagnostics.Eventing.Reader.EventLogMode;
          LogName: string;
          LogType: System.Diagnostics.Eventing.Reader.EventLogType;
          MaximumSizeInBytes: number;
          OwningProviderName: string;
          ProviderBufferSize?: number | undefined;
          ProviderControlGuid?: System.Guid | undefined;
          ProviderKeywords?: number | undefined;
          ProviderLatency?: number | undefined;
          ProviderLevel?: number | undefined;
          ProviderMaximumNumberOfBuffers?: number | undefined;
          ProviderMinimumNumberOfBuffers?: number | undefined;
          ProviderNames: System.Collections.Generic.IEnumerable<string>;
          SecurityDescriptor: string;
          Dispose(): void;
          SaveChanges(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventLogSession {
          constructor();
          constructor(server: string);
          constructor(server: string, domain: string, user: string, password: System.Security.SecureString, logOnType: System.Diagnostics.Eventing.Reader.SessionAuthentication);
          static GlobalSession: System.Diagnostics.Eventing.Reader.EventLogSession;
          CancelCurrentOperations(): void;
          ClearLog(logName: string): void;
          ClearLog(logName: string, backupPath: string): void;
          Dispose(): void;
          ExportLog(path: string, pathType: System.Diagnostics.Eventing.Reader.PathType, query: string, targetFilePath: string): void;
          ExportLog(path: string, pathType: System.Diagnostics.Eventing.Reader.PathType, query: string, targetFilePath: string, tolerateQueryErrors: boolean): void;
          ExportLogAndMessages(path: string, pathType: System.Diagnostics.Eventing.Reader.PathType, query: string, targetFilePath: string): void;
          ExportLogAndMessages(path: string, pathType: System.Diagnostics.Eventing.Reader.PathType, query: string, targetFilePath: string, tolerateQueryErrors: boolean, targetCultureInfo: System.Globalization.CultureInfo): void;
          GetLogInformation(logName: string, pathType: System.Diagnostics.Eventing.Reader.PathType): System.Diagnostics.Eventing.Reader.EventLogInformation;
          GetLogNames(): System.Collections.Generic.IEnumerable<string>;
          GetProviderNames(): System.Collections.Generic.IEnumerable<string>;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export enum SessionAuthentication {
          Default = 0,
          Kerberos = 2,
          Negotiate = 1,
          Ntlm = 3,
        }
        export enum PathType {
          FilePath = 2,
          LogName = 1,
        }
        export class EventLogInformation {
          Attributes?: number | undefined;
          CreationTime?: System.DateTime | undefined;
          FileSize?: number | undefined;
          IsLogFull?: boolean | undefined;
          LastAccessTime?: System.DateTime | undefined;
          LastWriteTime?: System.DateTime | undefined;
          OldestRecordNumber?: number | undefined;
          RecordCount?: number | undefined;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export enum EventLogIsolation {
          Application = 0,
          Custom = 2,
          System = 1,
        }
        export enum EventLogMode {
          AutoBackup = 1,
          Circular = 0,
          Retain = 2,
        }
        export enum EventLogType {
          Administrative = 0,
          Analytical = 2,
          Debug = 3,
          Operational = 1,
        }
        export class EventLogException {
          constructor();
          constructor(message: string);
          constructor(message: string, innerException: System.Exception);
          Message: string;
          Data: System.Collections.IDictionary;
          InnerException: System.Exception;
          TargetSite: System.Reflection.MethodBase;
          StackTrace: string;
          HelpLink: string;
          Source: string;
          HResult: number;
          GetBaseException(): System.Exception;
          ToString(): string;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetType(): System.Type;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
        }
        export class EventLogInvalidDataException {
          constructor();
          constructor(message: string);
          constructor(message: string, innerException: System.Exception);
          Message: string;
          Data: System.Collections.IDictionary;
          InnerException: System.Exception;
          TargetSite: System.Reflection.MethodBase;
          StackTrace: string;
          HelpLink: string;
          Source: string;
          HResult: number;
          GetBaseException(): System.Exception;
          ToString(): string;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetType(): System.Type;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
        }
        export class EventLogLink {
          DisplayName: string;
          IsImported: boolean;
          LogName: string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventLogNotFoundException {
          constructor();
          constructor(message: string);
          constructor(message: string, innerException: System.Exception);
          Message: string;
          Data: System.Collections.IDictionary;
          InnerException: System.Exception;
          TargetSite: System.Reflection.MethodBase;
          StackTrace: string;
          HelpLink: string;
          Source: string;
          HResult: number;
          GetBaseException(): System.Exception;
          ToString(): string;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetType(): System.Type;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
        }
        export class EventLogPropertySelector {
          constructor(propertyQueries: System.Collections.Generic.IEnumerable<string>);
          Dispose(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventLogProviderDisabledException {
          constructor();
          constructor(message: string);
          constructor(message: string, innerException: System.Exception);
          Message: string;
          Data: System.Collections.IDictionary;
          InnerException: System.Exception;
          TargetSite: System.Reflection.MethodBase;
          StackTrace: string;
          HelpLink: string;
          Source: string;
          HResult: number;
          GetBaseException(): System.Exception;
          ToString(): string;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetType(): System.Type;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
        }
        export class EventLogQuery {
          constructor(path: string, pathType: System.Diagnostics.Eventing.Reader.PathType);
          constructor(path: string, pathType: System.Diagnostics.Eventing.Reader.PathType, query: string);
          ReverseDirection: boolean;
          Session: System.Diagnostics.Eventing.Reader.EventLogSession;
          TolerateQueryErrors: boolean;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventLogReader {
          constructor(eventQuery: System.Diagnostics.Eventing.Reader.EventLogQuery);
          constructor(eventQuery: System.Diagnostics.Eventing.Reader.EventLogQuery, bookmark: System.Diagnostics.Eventing.Reader.EventBookmark);
          constructor(path: string);
          constructor(path: string, pathType: System.Diagnostics.Eventing.Reader.PathType);
          BatchSize: number;
          LogStatus: System.Diagnostics.Eventing.Reader.EventLogStatus[];
          CancelReading(): void;
          Dispose(): void;
          ReadEvent(): System.Diagnostics.Eventing.Reader.EventRecord;
          ReadEvent(timeout: System.TimeSpan): System.Diagnostics.Eventing.Reader.EventRecord;
          Seek(bookmark: System.Diagnostics.Eventing.Reader.EventBookmark): void;
          Seek(bookmark: System.Diagnostics.Eventing.Reader.EventBookmark, offset: number): void;
          Seek(origin: System.IO.SeekOrigin, offset: number): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventLogStatus {
          LogName: string;
          StatusCode: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventRecord {
          ActivityId?: System.Guid | undefined;
          Bookmark: System.Diagnostics.Eventing.Reader.EventBookmark;
          Id: number;
          Keywords?: number | undefined;
          KeywordsDisplayNames: System.Collections.Generic.IEnumerable<string>;
          Level?: Byte | undefined;
          LevelDisplayName: string;
          LogName: string;
          MachineName: string;
          Opcode?: number | undefined;
          OpcodeDisplayName: string;
          ProcessId?: number | undefined;
          Properties: System.Diagnostics.Eventing.Reader.EventProperty[];
          ProviderId?: System.Guid | undefined;
          ProviderName: string;
          Qualifiers?: number | undefined;
          RecordId?: number | undefined;
          RelatedActivityId?: System.Guid | undefined;
          Task?: number | undefined;
          TaskDisplayName: string;
          ThreadId?: number | undefined;
          TimeCreated?: System.DateTime | undefined;
          UserId: System.Security.Principal.SecurityIdentifier;
          Version?: Byte | undefined;
          Dispose(): void;
          FormatDescription(): string;
          FormatDescription(values: System.Collections.Generic.IEnumerable<any>): string;
          ToXml(): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventProperty {
          Value: any; // System.Object
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventLogReadingException {
          constructor();
          constructor(message: string);
          constructor(message: string, innerException: System.Exception);
          Message: string;
          Data: System.Collections.IDictionary;
          InnerException: System.Exception;
          TargetSite: System.Reflection.MethodBase;
          StackTrace: string;
          HelpLink: string;
          Source: string;
          HResult: number;
          GetBaseException(): System.Exception;
          ToString(): string;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetType(): System.Type;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
        }
        export class EventLogRecord {
          ActivityId?: System.Guid | undefined;
          Bookmark: System.Diagnostics.Eventing.Reader.EventBookmark;
          ContainerLog: string;
          Id: number;
          Keywords?: number | undefined;
          KeywordsDisplayNames: System.Collections.Generic.IEnumerable<string>;
          Level?: Byte | undefined;
          LevelDisplayName: string;
          LogName: string;
          MachineName: string;
          MatchedQueryIds: System.Collections.Generic.IEnumerable<number>;
          Opcode?: number | undefined;
          OpcodeDisplayName: string;
          ProcessId?: number | undefined;
          Properties: System.Diagnostics.Eventing.Reader.EventProperty[];
          ProviderId?: System.Guid | undefined;
          ProviderName: string;
          Qualifiers?: number | undefined;
          RecordId?: number | undefined;
          RelatedActivityId?: System.Guid | undefined;
          Task?: number | undefined;
          TaskDisplayName: string;
          ThreadId?: number | undefined;
          TimeCreated?: System.DateTime | undefined;
          UserId: System.Security.Principal.SecurityIdentifier;
          Version?: Byte | undefined;
          FormatDescription(): string;
          FormatDescription(values: System.Collections.Generic.IEnumerable<any>): string;
          GetPropertyValues(propertySelector: System.Diagnostics.Eventing.Reader.EventLogPropertySelector): any[];
          ToXml(): string;
          Dispose(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventLogWatcher {
          constructor(eventQuery: System.Diagnostics.Eventing.Reader.EventLogQuery);
          constructor(eventQuery: System.Diagnostics.Eventing.Reader.EventLogQuery, bookmark: System.Diagnostics.Eventing.Reader.EventBookmark);
          constructor(eventQuery: System.Diagnostics.Eventing.Reader.EventLogQuery, bookmark: System.Diagnostics.Eventing.Reader.EventBookmark, readExistingEvents: boolean);
          constructor(path: string);
          Enabled: boolean;
          Dispose(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventRecordWrittenEventArgs {
          EventException: System.Exception;
          EventRecord: System.Diagnostics.Eventing.Reader.EventRecord;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventMetadata {
          Description: string;
          Id: number;
          Keywords: System.Collections.Generic.IEnumerable<System.Diagnostics.Eventing.Reader.EventKeyword>;
          Level: System.Diagnostics.Eventing.Reader.EventLevel;
          LogLink: System.Diagnostics.Eventing.Reader.EventLogLink;
          Opcode: System.Diagnostics.Eventing.Reader.EventOpcode;
          Task: System.Diagnostics.Eventing.Reader.EventTask;
          Template: string;
          Version: Byte;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventOpcode {
          DisplayName: string;
          Name: string;
          Value: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class EventTask {
          DisplayName: string;
          EventGuid: System.Guid;
          Name: string;
          Value: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ProviderMetadata {
          constructor(providerName: string);
          constructor(providerName: string, session: System.Diagnostics.Eventing.Reader.EventLogSession, targetCultureInfo: System.Globalization.CultureInfo);
          DisplayName: string;
          Events: System.Collections.Generic.IEnumerable<System.Diagnostics.Eventing.Reader.EventMetadata>;
          HelpLink: System.Uri;
          Id: System.Guid;
          Keywords: System.Diagnostics.Eventing.Reader.EventKeyword[];
          Levels: System.Diagnostics.Eventing.Reader.EventLevel[];
          LogLinks: System.Diagnostics.Eventing.Reader.EventLogLink[];
          MessageFilePath: string;
          Name: string;
          Opcodes: System.Diagnostics.Eventing.Reader.EventOpcode[];
          ParameterFilePath: string;
          ResourceFilePath: string;
          Tasks: System.Diagnostics.Eventing.Reader.EventTask[];
          Dispose(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export enum StandardEventKeywords {
          AuditFailure = 4503599627370496,
          AuditSuccess = 9007199254740992,
          CorrelationHint = 4503599627370496,
          CorrelationHint2 = 18014398509481984,
          EventLogClassic = 36028797018963968,
          None = 0,
          ResponseTime = 281474976710656,
          Sqm = 2251799813685248,
          WdiContext = 562949953421312,
          WdiDiagnostic = 1125899906842624,
        }
        export enum StandardEventLevel {
          Critical = 1,
          Error = 2,
          Informational = 4,
          LogAlways = 0,
          Verbose = 5,
          Warning = 3,
        }
        export enum StandardEventOpcode {
          DataCollectionStart = 3,
          DataCollectionStop = 4,
          Extension = 5,
          Info = 0,
          Receive = 240,
          Reply = 6,
          Resume = 7,
          Send = 9,
          Start = 1,
          Stop = 2,
          Suspend = 8,
        }
        export enum StandardEventTask {
          None = 0,
        }
      }
    }
    export namespace PerformanceData {
      export class CounterData {
        RawValue: number;
        Value: number;
        Decrement(): void;
        Increment(): void;
        IncrementBy(value: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CounterSet {
        constructor(providerGuid: System.Guid, counterSetGuid: System.Guid, instanceType: System.Diagnostics.PerformanceData.CounterSetInstanceType);
        AddCounter(counterId: number, counterType: System.Diagnostics.PerformanceData.CounterType): void;
        AddCounter(counterId: number, counterType: System.Diagnostics.PerformanceData.CounterType, counterName: string): void;
        CreateCounterSetInstance(instanceName: string): System.Diagnostics.PerformanceData.CounterSetInstance;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum CounterSetInstanceType {
        GlobalAggregate = 4,
        GlobalAggregateWithHistory = 11,
        InstanceAggregate = 22,
        Multiple = 2,
        MultipleAggregate = 6,
        Single = 0,
      }
      export enum CounterType {
        AverageBase = 1073939458,
        AverageCount64 = 1073874176,
        AverageTimer32 = 805438464,
        Delta32 = 4195328,
        Delta64 = 4195584,
        ElapsedTime = 807666944,
        LargeQueueLength = 4523264,
        MultiTimerBase = 1107494144,
        MultiTimerPercentageActive = 574686464,
        MultiTimerPercentageActive100Ns = 575735040,
        MultiTimerPercentageNotActive = 591463680,
        MultiTimerPercentageNotActive100Ns = 592512256,
        ObjectSpecificTimer = 543229184,
        PercentageActive = 541132032,
        PercentageActive100Ns = 542180608,
        PercentageNotActive = 557909248,
        PercentageNotActive100Ns = 558957824,
        PrecisionObjectSpecificTimer = 543622400,
        PrecisionSystemTimer = 541525248,
        PrecisionTimer100Ns = 542573824,
        QueueLength = 4523008,
        QueueLength100Ns = 5571840,
        QueueLengthObjectTime = 6620416,
        RateOfCountPerSecond32 = 272696320,
        RateOfCountPerSecond64 = 272696576,
        RawBase32 = 1073939459,
        RawBase64 = 1073939712,
        RawData32 = 65536,
        RawData64 = 65792,
        RawDataHex32 = 0,
        RawDataHex64 = 256,
        RawFraction32 = 537003008,
        RawFraction64 = 537003264,
        SampleBase = 1073939457,
        SampleCounter = 4260864,
        SampleFraction = 549585920,
      }
      export class CounterSetInstance {
        Counters: System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CounterSetInstanceCounterDataSet {
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace SymbolStore {
      export class SymbolToken {
        constructor(val: number);
        GetToken(): number;
        GetHashCode(): number;
        Equals(obj: any): boolean;
        Equals(obj: System.Diagnostics.SymbolStore.SymbolToken): boolean;
        ToString(): string;
        GetType(): System.Type;
      }
      export interface ISymbolBinder {
        GetReader(importer: number, filename: string, searchPath: string): System.Diagnostics.SymbolStore.ISymbolReader;
      }
      export interface ISymbolBinder1 {
        GetReader(importer: System.IntPtr, filename: string, searchPath: string): System.Diagnostics.SymbolStore.ISymbolReader;
      }
      export interface ISymbolDocument {
        CheckSumAlgorithmId: System.Guid;
        DocumentType: System.Guid;
        HasEmbeddedSource: boolean;
        Language: System.Guid;
        LanguageVendor: System.Guid;
        SourceLength: number;
        URL: string;
        FindClosestLine(line: number): number;
        GetCheckSum(): Byte[];
        GetSourceRange(startLine: number, startColumn: number, endLine: number, endColumn: number): Byte[];
      }
      export interface ISymbolDocumentWriter {
        SetCheckSum(algorithmId: System.Guid, checkSum: Byte[]): void;
        SetSource(source: Byte[]): void;
      }
      export interface ISymbolMethod {
        RootScope: System.Diagnostics.SymbolStore.ISymbolScope;
        SequencePointCount: number;
        Token: System.Diagnostics.SymbolStore.SymbolToken;
        GetNamespace(): System.Diagnostics.SymbolStore.ISymbolNamespace;
        GetOffset(document: System.Diagnostics.SymbolStore.ISymbolDocument, line: number, column: number): number;
        GetParameters(): System.Diagnostics.SymbolStore.ISymbolVariable[];
        GetRanges(document: System.Diagnostics.SymbolStore.ISymbolDocument, line: number, column: number): number[];
        GetScope(offset: number): System.Diagnostics.SymbolStore.ISymbolScope;
        GetSequencePoints(offsets: number[], documents: System.Diagnostics.SymbolStore.ISymbolDocument[], lines: number[], columns: number[], endLines: number[], endColumns: number[]): void;
        GetSourceStartEnd(docs: System.Diagnostics.SymbolStore.ISymbolDocument[], lines: number[], columns: number[]): boolean;
      }
      export interface ISymbolNamespace {
        Name: string;
        GetNamespaces(): System.Diagnostics.SymbolStore.ISymbolNamespace[];
        GetVariables(): System.Diagnostics.SymbolStore.ISymbolVariable[];
      }
      export interface ISymbolReader {
        UserEntryPoint: System.Diagnostics.SymbolStore.SymbolToken;
        GetDocument(url: string, language: System.Guid, languageVendor: System.Guid, documentType: System.Guid): System.Diagnostics.SymbolStore.ISymbolDocument;
        GetDocuments(): System.Diagnostics.SymbolStore.ISymbolDocument[];
        GetGlobalVariables(): System.Diagnostics.SymbolStore.ISymbolVariable[];
        GetMethod(method: System.Diagnostics.SymbolStore.SymbolToken): System.Diagnostics.SymbolStore.ISymbolMethod;
        GetMethod(method: System.Diagnostics.SymbolStore.SymbolToken, version: number): System.Diagnostics.SymbolStore.ISymbolMethod;
        GetMethodFromDocumentPosition(document: System.Diagnostics.SymbolStore.ISymbolDocument, line: number, column: number): System.Diagnostics.SymbolStore.ISymbolMethod;
        GetNamespaces(): System.Diagnostics.SymbolStore.ISymbolNamespace[];
        GetSymAttribute(parent: System.Diagnostics.SymbolStore.SymbolToken, name: string): Byte[];
        GetVariables(parent: System.Diagnostics.SymbolStore.SymbolToken): System.Diagnostics.SymbolStore.ISymbolVariable[];
      }
      export interface ISymbolScope {
        EndOffset: number;
        Method: System.Diagnostics.SymbolStore.ISymbolMethod;
        Parent: System.Diagnostics.SymbolStore.ISymbolScope;
        StartOffset: number;
        GetChildren(): System.Diagnostics.SymbolStore.ISymbolScope[];
        GetLocals(): System.Diagnostics.SymbolStore.ISymbolVariable[];
        GetNamespaces(): System.Diagnostics.SymbolStore.ISymbolNamespace[];
      }
      export interface ISymbolVariable {
        AddressField1: number;
        AddressField2: number;
        AddressField3: number;
        AddressKind: System.Diagnostics.SymbolStore.SymAddressKind;
        Attributes: any; // System.Object
        EndOffset: number;
        Name: string;
        StartOffset: number;
        GetSignature(): Byte[];
      }
      export interface ISymbolWriter {
        Close(): void;
        CloseMethod(): void;
        CloseNamespace(): void;
        CloseScope(endOffset: number): void;
        DefineDocument(url: string, language: System.Guid, languageVendor: System.Guid, documentType: System.Guid): System.Diagnostics.SymbolStore.ISymbolDocumentWriter;
        DefineField(parent: System.Diagnostics.SymbolStore.SymbolToken, name: string, attributes: System.Reflection.FieldAttributes, signature: Byte[], addrKind: System.Diagnostics.SymbolStore.SymAddressKind, addr1: number, addr2: number, addr3: number): void;
        DefineGlobalVariable(name: string, attributes: System.Reflection.FieldAttributes, signature: Byte[], addrKind: System.Diagnostics.SymbolStore.SymAddressKind, addr1: number, addr2: number, addr3: number): void;
        DefineLocalVariable(name: string, attributes: System.Reflection.FieldAttributes, signature: Byte[], addrKind: System.Diagnostics.SymbolStore.SymAddressKind, addr1: number, addr2: number, addr3: number, startOffset: number, endOffset: number): void;
        DefineParameter(name: string, attributes: System.Reflection.ParameterAttributes, sequence: number, addrKind: System.Diagnostics.SymbolStore.SymAddressKind, addr1: number, addr2: number, addr3: number): void;
        DefineSequencePoints(document: System.Diagnostics.SymbolStore.ISymbolDocumentWriter, offsets: number[], lines: number[], columns: number[], endLines: number[], endColumns: number[]): void;
        Initialize(emitter: System.IntPtr, filename: string, fFullBuild: boolean): void;
        OpenMethod(method: System.Diagnostics.SymbolStore.SymbolToken): void;
        OpenNamespace(name: string): void;
        OpenScope(startOffset: number): number;
        SetMethodSourceRange(startDoc: System.Diagnostics.SymbolStore.ISymbolDocumentWriter, startLine: number, startColumn: number, endDoc: System.Diagnostics.SymbolStore.ISymbolDocumentWriter, endLine: number, endColumn: number): void;
        SetScopeRange(scopeID: number, startOffset: number, endOffset: number): void;
        SetSymAttribute(parent: System.Diagnostics.SymbolStore.SymbolToken, name: string, data: Byte[]): void;
        SetUnderlyingWriter(underlyingWriter: System.IntPtr): void;
        SetUserEntryPoint(entryMethod: System.Diagnostics.SymbolStore.SymbolToken): void;
        UsingNamespace(fullName: string): void;
      }
      export enum SymAddressKind {
        ILOffset = 1,
        NativeRVA = 2,
        NativeRegister = 3,
        NativeRegisterRelative = 4,
        NativeOffset = 5,
        NativeRegisterRegister = 6,
        NativeRegisterStack = 7,
        NativeStackRegister = 8,
        BitField = 9,
        NativeSectionOffset = 10,
      }
      export class SymDocumentType {
        constructor();
        static Text: System.Guid;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SymLanguageType {
        constructor();
        static Basic: System.Guid;
        static C: System.Guid;
        static Cobol: System.Guid;
        static CPlusPlus: System.Guid;
        static CSharp: System.Guid;
        static ILAssembly: System.Guid;
        static Java: System.Guid;
        static JScript: System.Guid;
        static MCPlusPlus: System.Guid;
        static Pascal: System.Guid;
        static SMC: System.Guid;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SymLanguageVendor {
        constructor();
        static Microsoft: System.Guid;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace Tracing {
      export enum EventActivityOptions {
        None = 0,
        Disable = 2,
        Recursive = 4,
        Detachable = 8,
      }
      export class EventSourceException {
        constructor();
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class EventSourceOptions {
        Level: System.Diagnostics.Tracing.EventLevel;
        Opcode: System.Diagnostics.Tracing.EventOpcode;
        Keywords: System.Diagnostics.Tracing.EventKeywords;
        Tags: System.Diagnostics.Tracing.EventTags;
        ActivityOptions: System.Diagnostics.Tracing.EventActivityOptions;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum EventTags {
        None = 0,
      }
      export enum EventLevel {
        LogAlways = 0,
        Critical = 1,
        Error = 2,
        Warning = 3,
        Informational = 4,
        Verbose = 5,
      }
      export enum EventTask {
        None = 0,
      }
      export enum EventOpcode {
        Info = 0,
        Start = 1,
        Stop = 2,
        DataCollectionStart = 3,
        DataCollectionStop = 4,
        Extension = 5,
        Reply = 6,
        Resume = 7,
        Suspend = 8,
        Send = 9,
        Receive = 240,
      }
      export enum EventChannel {
        None = 0,
        Admin = 16,
        Operational = 17,
        Analytic = 18,
        Debug = 19,
      }
      export enum EventKeywords {
        None = 0,
        All = -1,
        MicrosoftTelemetry = 562949953421312,
        WdiContext = 562949953421312,
        WdiDiagnostic = 1125899906842624,
        Sqm = 2251799813685248,
        AuditFailure = 4503599627370496,
        AuditSuccess = 9007199254740992,
        CorrelationHint = 4503599627370496,
        EventLogClassic = 36028797018963968,
      }
      export enum EventCommand {
        Update = 0,
        SendManifest = -1,
        Enable = -2,
        Disable = -3,
      }
      export class EventCommandEventArgs {
        Arguments: Record<string, string>;
        Command: System.Diagnostics.Tracing.EventCommand;
        DisableEvent(eventId: number): boolean;
        EnableEvent(eventId: number): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class EventCounter {
        constructor(name: string, eventSource: System.Diagnostics.Tracing.EventSource);
        DisplayName: string;
        DisplayUnits: string;
        EventSource: System.Diagnostics.Tracing.EventSource;
        Name: string;
        WriteMetric(value: number): void;
        WriteMetric(value: number): void;
        AddMetadata(key: string, value: string): void;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum EventFieldFormat {
        Boolean = 3,
        Default = 0,
        Hexadecimal = 4,
        HResult = 15,
        Json = 12,
        String = 2,
        Xml = 11,
      }
      export enum EventFieldTags {
        None = 0,
      }
      export class EventListener {
        constructor();
        static EventSourceIndex(eventSource: System.Diagnostics.Tracing.EventSource): number;
        EnableEvents(eventSource: System.Diagnostics.Tracing.EventSource, level: System.Diagnostics.Tracing.EventLevel): void;
        EnableEvents(eventSource: System.Diagnostics.Tracing.EventSource, level: System.Diagnostics.Tracing.EventLevel, matchAnyKeyword: System.Diagnostics.Tracing.EventKeywords): void;
        EnableEvents(eventSource: System.Diagnostics.Tracing.EventSource, level: System.Diagnostics.Tracing.EventLevel, matchAnyKeyword: System.Diagnostics.Tracing.EventKeywords, argumentsCS: Record<string, string>): void;
        DisableEvents(eventSource: System.Diagnostics.Tracing.EventSource): void;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum EventManifestOptions {
        AllCultures = 2,
        AllowEventSourceOverride = 8,
        None = 0,
        OnlyIfNeededForRegistration = 4,
        Strict = 1,
      }
      export class EventSource {
        constructor(eventSourceName: string);
        constructor(eventSourceName: string, config: System.Diagnostics.Tracing.EventSourceSettings);
        constructor(eventSourceName: string, config: System.Diagnostics.Tracing.EventSourceSettings, ...traits: string[]);
        ConstructionException: System.Exception;
        static CurrentThreadActivityId: System.Guid;
        Guid: System.Guid;
        Name: string;
        Settings: System.Diagnostics.Tracing.EventSourceSettings;
        IsEnabled(): boolean;
        IsEnabled(level: System.Diagnostics.Tracing.EventLevel, keywords: System.Diagnostics.Tracing.EventKeywords): boolean;
        IsEnabled(level: System.Diagnostics.Tracing.EventLevel, keywords: System.Diagnostics.Tracing.EventKeywords, channel: System.Diagnostics.Tracing.EventChannel): boolean;
        Dispose(): void;
        GetTrait(key: string): string;
        Write(eventName: string): void;
        Write(eventName: string, options: System.Diagnostics.Tracing.EventSourceOptions): void;
        static GenerateManifest(eventSourceType: System.Type, assemblyPathToIncludeInManifest: string): string;
        static GenerateManifest(eventSourceType: System.Type, assemblyPathToIncludeInManifest: string, flags: System.Diagnostics.Tracing.EventManifestOptions): string;
        static GetGuid(eventSourceType: System.Type): System.Guid;
        static GetName(eventSourceType: System.Type): string;
        static GetSources(): any;
        static SendCommand(eventSource: System.Diagnostics.Tracing.EventSource, command: System.Diagnostics.Tracing.EventCommand, commandArguments: any): void;
        static SetCurrentThreadActivityId(activityId: System.Guid): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class EventSourceCreatedEventArgs {
        constructor();
        EventSource: System.Diagnostics.Tracing.EventSource;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum EventSourceSettings {
        Default = 0,
        ThrowOnEventWriteErrors = 1,
        EtwManifestEventFormat = 4,
        EtwSelfDescribingEventFormat = 8,
      }
      export class EventWrittenEventArgs {
        ActivityId: System.Guid;
        Channel: System.Diagnostics.Tracing.EventChannel;
        EventId: number;
        OSThreadId: number;
        TimeStamp: System.DateTime;
        EventName: string;
        EventSource: System.Diagnostics.Tracing.EventSource;
        Keywords: System.Diagnostics.Tracing.EventKeywords;
        Level: System.Diagnostics.Tracing.EventLevel;
        Message: string;
        Opcode: System.Diagnostics.Tracing.EventOpcode;
        Payload: any[];
        PayloadNames: string[];
        RelatedActivityId: System.Guid;
        Tags: System.Diagnostics.Tracing.EventTags;
        Task: System.Diagnostics.Tracing.EventTask;
        Version: Byte;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DiagnosticCounter {
        DisplayName: string;
        DisplayUnits: string;
        EventSource: System.Diagnostics.Tracing.EventSource;
        Name: string;
        AddMetadata(key: string, value: string): void;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IncrementingEventCounter {
        constructor(name: string, eventSource: System.Diagnostics.Tracing.EventSource);
        DisplayRateTimeScale: System.TimeSpan;
        DisplayName: string;
        DisplayUnits: string;
        EventSource: System.Diagnostics.Tracing.EventSource;
        Name: string;
        Increment(increment?: number): void;
        AddMetadata(key: string, value: string): void;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IncrementingPollingCounter {
        constructor(name: string, eventSource: System.Diagnostics.Tracing.EventSource, totalValueProvider: (() => number));
        DisplayRateTimeScale: System.TimeSpan;
        DisplayName: string;
        DisplayUnits: string;
        EventSource: System.Diagnostics.Tracing.EventSource;
        Name: string;
        AddMetadata(key: string, value: string): void;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class PollingCounter {
        constructor(name: string, eventSource: System.Diagnostics.Tracing.EventSource, metricProvider: (() => number));
        DisplayName: string;
        DisplayUnits: string;
        EventSource: System.Diagnostics.Tracing.EventSource;
        Name: string;
        AddMetadata(key: string, value: string): void;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
  }
  export namespace Dynamic {
    export class BinaryOperationBinder {
      ReturnType: System.Type;
      Operation: System.Linq.Expressions.ExpressionType;
      FallbackBinaryOperation(target: System.Dynamic.DynamicMetaObject, arg: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      FallbackBinaryOperation(target: System.Dynamic.DynamicMetaObject, arg: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BindingRestrictions {
      static Empty: System.Dynamic.BindingRestrictions;
      Merge(restrictions: System.Dynamic.BindingRestrictions): System.Dynamic.BindingRestrictions;
      static GetTypeRestriction(expression: System.Linq.Expressions.Expression, type: System.Type): System.Dynamic.BindingRestrictions;
      static GetInstanceRestriction(expression: System.Linq.Expressions.Expression, instance: any): System.Dynamic.BindingRestrictions;
      static GetExpressionRestriction(expression: System.Linq.Expressions.Expression): System.Dynamic.BindingRestrictions;
      static Combine(contributingObjects: System.Dynamic.DynamicMetaObject[]): System.Dynamic.BindingRestrictions;
      ToExpression(): System.Linq.Expressions.Expression;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CallInfo {
      constructor(argCount: number, ...argNames: string[]);
      constructor(argCount: number, argNames: System.Collections.Generic.IEnumerable<string>);
      ArgumentCount: number;
      ArgumentNames: string[];
      GetHashCode(): number;
      Equals(obj: any): boolean;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ConvertBinder {
      Type: System.Type;
      Explicit: boolean;
      ReturnType: System.Type;
      FallbackConvert(target: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      FallbackConvert(target: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CreateInstanceBinder {
      ReturnType: System.Type;
      CallInfo: System.Dynamic.CallInfo;
      FallbackCreateInstance(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackCreateInstance(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[], errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DeleteIndexBinder {
      ReturnType: System.Type;
      CallInfo: System.Dynamic.CallInfo;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackDeleteIndex(target: System.Dynamic.DynamicMetaObject, indexes: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackDeleteIndex(target: System.Dynamic.DynamicMetaObject, indexes: System.Dynamic.DynamicMetaObject[], errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DeleteMemberBinder {
      Name: string;
      IgnoreCase: boolean;
      ReturnType: System.Type;
      FallbackDeleteMember(target: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      FallbackDeleteMember(target: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DynamicMetaObject {
      constructor(expression: System.Linq.Expressions.Expression, restrictions: System.Dynamic.BindingRestrictions);
      constructor(expression: System.Linq.Expressions.Expression, restrictions: System.Dynamic.BindingRestrictions, value: any);
      Expression: System.Linq.Expressions.Expression;
      Restrictions: System.Dynamic.BindingRestrictions;
      Value: any; // System.Object
      HasValue: boolean;
      RuntimeType: System.Type;
      LimitType: System.Type;
      static EmptyMetaObjects: System.Dynamic.DynamicMetaObject[];
      BindConvert(binder: System.Dynamic.ConvertBinder): System.Dynamic.DynamicMetaObject;
      BindGetMember(binder: System.Dynamic.GetMemberBinder): System.Dynamic.DynamicMetaObject;
      BindSetMember(binder: System.Dynamic.SetMemberBinder, value: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      BindDeleteMember(binder: System.Dynamic.DeleteMemberBinder): System.Dynamic.DynamicMetaObject;
      BindGetIndex(binder: System.Dynamic.GetIndexBinder, indexes: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      BindSetIndex(binder: System.Dynamic.SetIndexBinder, indexes: System.Dynamic.DynamicMetaObject[], value: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      BindDeleteIndex(binder: System.Dynamic.DeleteIndexBinder, indexes: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      BindInvokeMember(binder: System.Dynamic.InvokeMemberBinder, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      BindInvoke(binder: System.Dynamic.InvokeBinder, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      BindCreateInstance(binder: System.Dynamic.CreateInstanceBinder, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      BindUnaryOperation(binder: System.Dynamic.UnaryOperationBinder): System.Dynamic.DynamicMetaObject;
      BindBinaryOperation(binder: System.Dynamic.BinaryOperationBinder, arg: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      GetDynamicMemberNames(): System.Collections.Generic.IEnumerable<string>;
      static Create(value: any, expression: System.Linq.Expressions.Expression): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DynamicMetaObjectBinder {
      ReturnType: System.Type;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DynamicObject {
      TrySetMember(binder: System.Dynamic.SetMemberBinder, value: any): boolean;
      TryDeleteMember(binder: System.Dynamic.DeleteMemberBinder): boolean;
      TrySetIndex(binder: System.Dynamic.SetIndexBinder, indexes: any[], value: any): boolean;
      TryDeleteIndex(binder: System.Dynamic.DeleteIndexBinder, indexes: any[]): boolean;
      GetDynamicMemberNames(): System.Collections.Generic.IEnumerable<string>;
      GetMetaObject(parameter: System.Linq.Expressions.Expression): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ExpandoObject {
      constructor();
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class GetIndexBinder {
      ReturnType: System.Type;
      CallInfo: System.Dynamic.CallInfo;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackGetIndex(target: System.Dynamic.DynamicMetaObject, indexes: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackGetIndex(target: System.Dynamic.DynamicMetaObject, indexes: System.Dynamic.DynamicMetaObject[], errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class GetMemberBinder {
      ReturnType: System.Type;
      Name: string;
      IgnoreCase: boolean;
      FallbackGetMember(target: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      FallbackGetMember(target: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IDynamicMetaObjectProvider {
      GetMetaObject(parameter: System.Linq.Expressions.Expression): System.Dynamic.DynamicMetaObject;
    }
    export interface IInvokeOnGetBinder {
      InvokeOnGet: boolean;
    }
    export class InvokeBinder {
      ReturnType: System.Type;
      CallInfo: System.Dynamic.CallInfo;
      FallbackInvoke(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackInvoke(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[], errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class InvokeMemberBinder {
      ReturnType: System.Type;
      Name: string;
      IgnoreCase: boolean;
      CallInfo: System.Dynamic.CallInfo;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackInvokeMember(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackInvokeMember(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[], errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      FallbackInvoke(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[], errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SetIndexBinder {
      ReturnType: System.Type;
      CallInfo: System.Dynamic.CallInfo;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackSetIndex(target: System.Dynamic.DynamicMetaObject, indexes: System.Dynamic.DynamicMetaObject[], value: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      FallbackSetIndex(target: System.Dynamic.DynamicMetaObject, indexes: System.Dynamic.DynamicMetaObject[], value: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SetMemberBinder {
      ReturnType: System.Type;
      Name: string;
      IgnoreCase: boolean;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      FallbackSetMember(target: System.Dynamic.DynamicMetaObject, value: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      FallbackSetMember(target: System.Dynamic.DynamicMetaObject, value: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class UnaryOperationBinder {
      ReturnType: System.Type;
      Operation: System.Linq.Expressions.ExpressionType;
      FallbackUnaryOperation(target: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      FallbackUnaryOperation(target: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject): System.Dynamic.DynamicMetaObject;
      Bind(target: System.Dynamic.DynamicMetaObject, args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
      GetUpdateExpression(type: System.Type): System.Linq.Expressions.Expression;
      Defer(target: System.Dynamic.DynamicMetaObject, ...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Defer(...args: System.Dynamic.DynamicMetaObject[]): System.Dynamic.DynamicMetaObject;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
  }
  export namespace Globalization {
    export enum CalendarAlgorithmType {
      Unknown = 0,
      SolarCalendar = 1,
      LunarCalendar = 2,
      LunisolarCalendar = 3,
    }
    export enum CalendarWeekRule {
      FirstDay = 0,
      FirstFullWeek = 1,
      FirstFourDayWeek = 2,
    }
    export class CharUnicodeInfo {
      static GetNumericValue(ch: System.Char): number;
      static GetNumericValue(s: string, index: number): number;
      static GetDecimalDigitValue(ch: System.Char): number;
      static GetDecimalDigitValue(s: string, index: number): number;
      static GetDigitValue(ch: System.Char): number;
      static GetDigitValue(s: string, index: number): number;
      static GetUnicodeCategory(ch: System.Char): System.Globalization.UnicodeCategory;
      static GetUnicodeCategory(s: string, index: number): System.Globalization.UnicodeCategory;
      static GetUnicodeCategory(codePoint: number): System.Globalization.UnicodeCategory;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CompareInfo {
      Name: string;
      Version: System.Globalization.SortVersion;
      LCID: number;
      static GetCompareInfo(culture: number, assembly: System.Reflection.Assembly): System.Globalization.CompareInfo;
      static GetCompareInfo(name: string, assembly: System.Reflection.Assembly): System.Globalization.CompareInfo;
      static GetCompareInfo(culture: number): System.Globalization.CompareInfo;
      static GetCompareInfo(name: string): System.Globalization.CompareInfo;
      static IsSortable(ch: System.Char): boolean;
      static IsSortable(text: string): boolean;
      Compare(string1: string, string2: string): number;
      Compare(string1: string, string2: string, options: System.Globalization.CompareOptions): number;
      Compare(string1: string, offset1: number, length1: number, string2: string, offset2: number, length2: number): number;
      Compare(string1: string, offset1: number, string2: string, offset2: number, options: System.Globalization.CompareOptions): number;
      Compare(string1: string, offset1: number, string2: string, offset2: number): number;
      Compare(string1: string, offset1: number, length1: number, string2: string, offset2: number, length2: number, options: System.Globalization.CompareOptions): number;
      IsPrefix(source: string, prefix: string, options: System.Globalization.CompareOptions): boolean;
      IsPrefix(source: string, prefix: string): boolean;
      IsSuffix(source: string, suffix: string, options: System.Globalization.CompareOptions): boolean;
      IsSuffix(source: string, suffix: string): boolean;
      IndexOf(source: string, value: System.Char): number;
      IndexOf(source: string, value: string): number;
      IndexOf(source: string, value: System.Char, options: System.Globalization.CompareOptions): number;
      IndexOf(source: string, value: string, options: System.Globalization.CompareOptions): number;
      IndexOf(source: string, value: System.Char, startIndex: number): number;
      IndexOf(source: string, value: string, startIndex: number): number;
      IndexOf(source: string, value: System.Char, startIndex: number, options: System.Globalization.CompareOptions): number;
      IndexOf(source: string, value: string, startIndex: number, options: System.Globalization.CompareOptions): number;
      IndexOf(source: string, value: System.Char, startIndex: number, count: number): number;
      IndexOf(source: string, value: string, startIndex: number, count: number): number;
      IndexOf(source: string, value: System.Char, startIndex: number, count: number, options: System.Globalization.CompareOptions): number;
      IndexOf(source: string, value: string, startIndex: number, count: number, options: System.Globalization.CompareOptions): number;
      LastIndexOf(source: string, value: System.Char): number;
      LastIndexOf(source: string, value: string): number;
      LastIndexOf(source: string, value: System.Char, options: System.Globalization.CompareOptions): number;
      LastIndexOf(source: string, value: string, options: System.Globalization.CompareOptions): number;
      LastIndexOf(source: string, value: System.Char, startIndex: number): number;
      LastIndexOf(source: string, value: string, startIndex: number): number;
      LastIndexOf(source: string, value: System.Char, startIndex: number, options: System.Globalization.CompareOptions): number;
      LastIndexOf(source: string, value: string, startIndex: number, options: System.Globalization.CompareOptions): number;
      LastIndexOf(source: string, value: System.Char, startIndex: number, count: number): number;
      LastIndexOf(source: string, value: string, startIndex: number, count: number): number;
      LastIndexOf(source: string, value: System.Char, startIndex: number, count: number, options: System.Globalization.CompareOptions): number;
      LastIndexOf(source: string, value: string, startIndex: number, count: number, options: System.Globalization.CompareOptions): number;
      GetSortKey(source: string, options: System.Globalization.CompareOptions): System.Globalization.SortKey;
      GetSortKey(source: string): System.Globalization.SortKey;
      Equals(value: any): boolean;
      GetHashCode(): number;
      GetHashCode(source: string, options: System.Globalization.CompareOptions): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export enum CompareOptions {
      None = 0,
      IgnoreCase = 1,
      IgnoreNonSpace = 2,
      IgnoreSymbols = 4,
      IgnoreKanaType = 8,
      IgnoreWidth = 16,
      OrdinalIgnoreCase = 268435456,
      StringSort = 536870912,
      Ordinal = 1073741824,
    }
    export class CultureNotFoundException {
      constructor();
      constructor(message: string);
      constructor(paramName: string, message: string);
      constructor(message: string, innerException: System.Exception);
      constructor(paramName: string, invalidCultureName: string, message: string);
      constructor(message: string, invalidCultureName: string, innerException: System.Exception);
      constructor(message: string, invalidCultureId: number, innerException: System.Exception);
      constructor(paramName: string, invalidCultureId: number, message: string);
      InvalidCultureId?: number | undefined;
      InvalidCultureName: string;
      Message: string;
      ParamName: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum CultureTypes {
      NeutralCultures = 1,
      SpecificCultures = 2,
      InstalledWin32Cultures = 4,
      AllCultures = 7,
      UserCustomCulture = 8,
      ReplacementCultures = 16,
      WindowsOnlyCultures = 32,
      FrameworkCultures = 64,
    }
    export class DateTimeFormatInfo {
      constructor();
      static InvariantInfo: System.Globalization.DateTimeFormatInfo;
      static CurrentInfo: System.Globalization.DateTimeFormatInfo;
      AMDesignator: string;
      Calendar: System.Globalization.Calendar;
      DateSeparator: string;
      FirstDayOfWeek: System.DayOfWeek;
      CalendarWeekRule: System.Globalization.CalendarWeekRule;
      FullDateTimePattern: string;
      LongDatePattern: string;
      LongTimePattern: string;
      MonthDayPattern: string;
      PMDesignator: string;
      RFC1123Pattern: string;
      ShortDatePattern: string;
      ShortTimePattern: string;
      SortableDateTimePattern: string;
      TimeSeparator: string;
      UniversalSortableDateTimePattern: string;
      YearMonthPattern: string;
      AbbreviatedDayNames: string[];
      ShortestDayNames: string[];
      DayNames: string[];
      AbbreviatedMonthNames: string[];
      MonthNames: string[];
      IsReadOnly: boolean;
      NativeCalendarName: string;
      AbbreviatedMonthGenitiveNames: string[];
      MonthGenitiveNames: string[];
      static GetInstance(provider: System.IFormatProvider): System.Globalization.DateTimeFormatInfo;
      GetFormat(formatType: System.Type): any;
      Clone(): any;
      GetEra(eraName: string): number;
      GetEraName(era: number): string;
      GetAbbreviatedEraName(era: number): string;
      GetAbbreviatedDayName(dayofweek: System.DayOfWeek): string;
      GetShortestDayName(dayOfWeek: System.DayOfWeek): string;
      GetAllDateTimePatterns(): string[];
      GetAllDateTimePatterns(format: System.Char): string[];
      GetDayName(dayofweek: System.DayOfWeek): string;
      GetAbbreviatedMonthName(month: number): string;
      GetMonthName(month: number): string;
      static ReadOnly(dtfi: System.Globalization.DateTimeFormatInfo): System.Globalization.DateTimeFormatInfo;
      SetAllDateTimePatterns(patterns: string[], format: System.Char): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum DateTimeStyles {
      None = 0,
      AllowLeadingWhite = 1,
      AllowTrailingWhite = 2,
      AllowInnerWhite = 4,
      AllowWhiteSpaces = 7,
      NoCurrentDateDefault = 8,
      AdjustToUniversal = 16,
      AssumeLocal = 32,
      AssumeUniversal = 64,
      RoundtripKind = 128,
    }
    export class DaylightTime {
      constructor(start: System.DateTime, end: System.DateTime, delta: System.TimeSpan);
      Start: System.DateTime;
      End: System.DateTime;
      Delta: System.TimeSpan;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum DigitShapes {
      Context = 0,
      None = 1,
      NativeNational = 2,
    }
    export class GlobalizationExtensions {
      static GetStringComparer(compareInfo: System.Globalization.CompareInfo, options: System.Globalization.CompareOptions): System.StringComparer;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum NumberStyles {
      None = 0,
      AllowLeadingWhite = 1,
      AllowTrailingWhite = 2,
      AllowLeadingSign = 4,
      AllowTrailingSign = 8,
      AllowParentheses = 16,
      AllowDecimalPoint = 32,
      AllowThousands = 64,
      AllowExponent = 128,
      AllowCurrencySymbol = 256,
      AllowHexSpecifier = 512,
      Integer = 7,
      HexNumber = 515,
      Number = 111,
      Float = 167,
      Currency = 383,
      Any = 511,
    }
    export class SortVersion {
      constructor(fullVersion: number, sortId: System.Guid);
      FullVersion: number;
      SortId: System.Guid;
      Equals(obj: any): boolean;
      Equals(other: System.Globalization.SortVersion): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum TimeSpanStyles {
      None = 0,
      AssumeNegative = 1,
    }
    export enum UnicodeCategory {
      UppercaseLetter = 0,
      LowercaseLetter = 1,
      TitlecaseLetter = 2,
      ModifierLetter = 3,
      OtherLetter = 4,
      NonSpacingMark = 5,
      SpacingCombiningMark = 6,
      EnclosingMark = 7,
      DecimalDigitNumber = 8,
      LetterNumber = 9,
      OtherNumber = 10,
      SpaceSeparator = 11,
      LineSeparator = 12,
      ParagraphSeparator = 13,
      Control = 14,
      Format = 15,
      Surrogate = 16,
      PrivateUse = 17,
      ConnectorPunctuation = 18,
      DashPunctuation = 19,
      OpenPunctuation = 20,
      ClosePunctuation = 21,
      InitialQuotePunctuation = 22,
      FinalQuotePunctuation = 23,
      OtherPunctuation = 24,
      MathSymbol = 25,
      CurrencySymbol = 26,
      ModifierSymbol = 27,
      OtherSymbol = 28,
      OtherNotAssigned = 29,
    }
    export class ISOWeek {
      static GetWeekOfYear(date: System.DateTime): number;
      static GetYear(date: System.DateTime): number;
      static GetYearStart(year: number): System.DateTime;
      static GetYearEnd(year: number): System.DateTime;
      static GetWeeksInYear(year: number): number;
      static ToDateTime(year: number, week: number, dayOfWeek: System.DayOfWeek): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PersianCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static PersianEra: number;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Calendar {
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      IsReadOnly: boolean;
      Eras: number[];
      TwoDigitYearMax: number;
      static CurrentEra: number;
      Clone(): any;
      static ReadOnly(calendar: System.Globalization.Calendar): System.Globalization.Calendar;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetEra(time: System.DateTime): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetMonthsInYear(year: number, era: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      GetLeapMonth(year: number): number;
      GetLeapMonth(year: number, era: number): number;
      IsLeapYear(year: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ChineseLunisolarCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      Eras: number[];
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static ChineseEra: number;
      GetEra(time: System.DateTime): number;
      GetSexagenaryYear(time: System.DateTime): number;
      GetCelestialStem(sexagenaryYear: number): number;
      GetTerrestrialBranch(sexagenaryYear: number): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfYear(time: System.DateTime): number;
      GetDayOfMonth(time: System.DateTime): number;
      GetDaysInYear(year: number, era: number): number;
      GetMonth(time: System.DateTime): number;
      GetYear(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetMonthsInYear(year: number, era: number): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapYear(year: number, era: number): boolean;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EastAsianLunisolarCalendar {
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      TwoDigitYearMax: number;
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      IsReadOnly: boolean;
      Eras: number[];
      GetSexagenaryYear(time: System.DateTime): number;
      GetCelestialStem(sexagenaryYear: number): number;
      GetTerrestrialBranch(sexagenaryYear: number): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfYear(time: System.DateTime): number;
      GetDayOfMonth(time: System.DateTime): number;
      GetDaysInYear(year: number, era: number): number;
      GetMonth(time: System.DateTime): number;
      GetYear(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetMonthsInYear(year: number, era: number): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapYear(year: number, era: number): boolean;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetEra(time: System.DateTime): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class GregorianCalendar {
      constructor();
      constructor(type: System.Globalization.GregorianCalendarTypes);
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      CalendarType: System.Globalization.GregorianCalendarTypes;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static ADEra: number;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum GregorianCalendarTypes {
      Localized = 1,
      USEnglish = 2,
      MiddleEastFrench = 9,
      Arabic = 10,
      TransliteratedEnglish = 11,
      TransliteratedFrench = 12,
    }
    export class HebrewCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static HebrewEra: number;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class HijriCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      HijriAdjustment: number;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static HijriEra: number;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class JapaneseCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class JapaneseLunisolarCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      Eras: number[];
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static JapaneseEra: number;
      GetEra(time: System.DateTime): number;
      GetSexagenaryYear(time: System.DateTime): number;
      GetCelestialStem(sexagenaryYear: number): number;
      GetTerrestrialBranch(sexagenaryYear: number): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfYear(time: System.DateTime): number;
      GetDayOfMonth(time: System.DateTime): number;
      GetDaysInYear(year: number, era: number): number;
      GetMonth(time: System.DateTime): number;
      GetYear(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetMonthsInYear(year: number, era: number): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapYear(year: number, era: number): boolean;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class JulianCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static JulianEra: number;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class KoreanCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static KoreanEra: number;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class KoreanLunisolarCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      Eras: number[];
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static GregorianEra: number;
      GetEra(time: System.DateTime): number;
      GetSexagenaryYear(time: System.DateTime): number;
      GetCelestialStem(sexagenaryYear: number): number;
      GetTerrestrialBranch(sexagenaryYear: number): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfYear(time: System.DateTime): number;
      GetDayOfMonth(time: System.DateTime): number;
      GetDaysInYear(year: number, era: number): number;
      GetMonth(time: System.DateTime): number;
      GetYear(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetMonthsInYear(year: number, era: number): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapYear(year: number, era: number): boolean;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class NumberFormatInfo {
      constructor();
      static InvariantInfo: System.Globalization.NumberFormatInfo;
      CurrencyDecimalDigits: number;
      CurrencyDecimalSeparator: string;
      IsReadOnly: boolean;
      CurrencyGroupSizes: number[];
      NumberGroupSizes: number[];
      PercentGroupSizes: number[];
      CurrencyGroupSeparator: string;
      CurrencySymbol: string;
      static CurrentInfo: System.Globalization.NumberFormatInfo;
      NaNSymbol: string;
      CurrencyNegativePattern: number;
      NumberNegativePattern: number;
      PercentPositivePattern: number;
      PercentNegativePattern: number;
      NegativeInfinitySymbol: string;
      NegativeSign: string;
      NumberDecimalDigits: number;
      NumberDecimalSeparator: string;
      NumberGroupSeparator: string;
      CurrencyPositivePattern: number;
      PositiveInfinitySymbol: string;
      PositiveSign: string;
      PercentDecimalDigits: number;
      PercentDecimalSeparator: string;
      PercentGroupSeparator: string;
      PercentSymbol: string;
      PerMilleSymbol: string;
      NativeDigits: string[];
      DigitSubstitution: System.Globalization.DigitShapes;
      static GetInstance(formatProvider: System.IFormatProvider): System.Globalization.NumberFormatInfo;
      Clone(): any;
      GetFormat(formatType: System.Type): any;
      static ReadOnly(nfi: System.Globalization.NumberFormatInfo): System.Globalization.NumberFormatInfo;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StringInfo {
      constructor();
      constructor(value: string);
      String: string;
      LengthInTextElements: number;
      Equals(value: any): boolean;
      GetHashCode(): number;
      SubstringByTextElements(startingTextElement: number): string;
      SubstringByTextElements(startingTextElement: number, lengthInTextElements: number): string;
      static GetNextTextElement(str: string): string;
      static GetNextTextElement(str: string, index: number): string;
      static GetTextElementEnumerator(str: string): System.Globalization.TextElementEnumerator;
      static GetTextElementEnumerator(str: string, index: number): System.Globalization.TextElementEnumerator;
      static ParseCombiningCharacters(str: string): number[];
      GetType(): System.Type;
      ToString(): string;
    }
    export class TaiwanCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TaiwanLunisolarCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      Eras: number[];
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      GetEra(time: System.DateTime): number;
      GetSexagenaryYear(time: System.DateTime): number;
      GetCelestialStem(sexagenaryYear: number): number;
      GetTerrestrialBranch(sexagenaryYear: number): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfYear(time: System.DateTime): number;
      GetDayOfMonth(time: System.DateTime): number;
      GetDaysInYear(year: number, era: number): number;
      GetMonth(time: System.DateTime): number;
      GetYear(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetMonthsInYear(year: number, era: number): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapYear(year: number, era: number): boolean;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TextElementEnumerator {
      Current: any; // System.Object
      ElementIndex: number;
      MoveNext(): boolean;
      GetTextElement(): string;
      Reset(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TextInfo {
      ANSICodePage: number;
      OEMCodePage: number;
      MacCodePage: number;
      EBCDICCodePage: number;
      LCID: number;
      CultureName: string;
      IsReadOnly: boolean;
      ListSeparator: string;
      IsRightToLeft: boolean;
      Clone(): any;
      static ReadOnly(textInfo: System.Globalization.TextInfo): System.Globalization.TextInfo;
      ToLower(c: System.Char): System.Char;
      ToLower(str: string): string;
      ToUpper(c: System.Char): System.Char;
      ToUpper(str: string): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      ToTitleCase(str: string): string;
      GetType(): System.Type;
    }
    export class ThaiBuddhistCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static ThaiBuddhistEra: number;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class UmAlQuraCalendar {
      constructor();
      MinSupportedDateTime: System.DateTime;
      MaxSupportedDateTime: System.DateTime;
      AlgorithmType: System.Globalization.CalendarAlgorithmType;
      Eras: number[];
      TwoDigitYearMax: number;
      IsReadOnly: boolean;
      static UmAlQuraEra: number;
      AddMonths(time: System.DateTime, months: number): System.DateTime;
      AddYears(time: System.DateTime, years: number): System.DateTime;
      GetDayOfMonth(time: System.DateTime): number;
      GetDayOfWeek(time: System.DateTime): System.DayOfWeek;
      GetDayOfYear(time: System.DateTime): number;
      GetDaysInMonth(year: number, month: number, era: number): number;
      GetDaysInYear(year: number, era: number): number;
      GetEra(time: System.DateTime): number;
      GetMonth(time: System.DateTime): number;
      GetMonthsInYear(year: number, era: number): number;
      GetYear(time: System.DateTime): number;
      IsLeapDay(year: number, month: number, day: number, era: number): boolean;
      GetLeapMonth(year: number, era: number): number;
      IsLeapMonth(year: number, month: number, era: number): boolean;
      IsLeapYear(year: number, era: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): System.DateTime;
      ToFourDigitYear(year: number): number;
      Clone(): any;
      AddMilliseconds(time: System.DateTime, milliseconds: number): System.DateTime;
      AddDays(time: System.DateTime, days: number): System.DateTime;
      AddHours(time: System.DateTime, hours: number): System.DateTime;
      AddMinutes(time: System.DateTime, minutes: number): System.DateTime;
      AddSeconds(time: System.DateTime, seconds: number): System.DateTime;
      AddWeeks(time: System.DateTime, weeks: number): System.DateTime;
      GetDaysInMonth(year: number, month: number): number;
      GetDaysInYear(year: number): number;
      GetHour(time: System.DateTime): number;
      GetMilliseconds(time: System.DateTime): number;
      GetMinute(time: System.DateTime): number;
      GetMonthsInYear(year: number): number;
      GetSecond(time: System.DateTime): number;
      GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek): number;
      IsLeapDay(year: number, month: number, day: number): boolean;
      IsLeapMonth(year: number, month: number): boolean;
      GetLeapMonth(year: number): number;
      IsLeapYear(year: number): boolean;
      ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SortKey {
      OriginalString: string;
      KeyData: Byte[];
      static Compare(sortkey1: System.Globalization.SortKey, sortkey2: System.Globalization.SortKey): number;
      Equals(value: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class CultureInfo {
      constructor(culture: number);
      constructor(culture: number, useUserOverride: boolean);
      constructor(name: string);
      constructor(name: string, useUserOverride: boolean);
      static InvariantCulture: System.Globalization.CultureInfo;
      static CurrentCulture: System.Globalization.CultureInfo;
      static CurrentUICulture: System.Globalization.CultureInfo;
      CultureTypes: System.Globalization.CultureTypes;
      IetfLanguageTag: string;
      KeyboardLayoutId: number;
      LCID: number;
      Name: string;
      NativeName: string;
      Calendar: System.Globalization.Calendar;
      OptionalCalendars: System.Globalization.Calendar[];
      Parent: System.Globalization.CultureInfo;
      TextInfo: System.Globalization.TextInfo;
      ThreeLetterISOLanguageName: string;
      ThreeLetterWindowsLanguageName: string;
      TwoLetterISOLanguageName: string;
      UseUserOverride: boolean;
      CompareInfo: System.Globalization.CompareInfo;
      IsNeutralCulture: boolean;
      NumberFormat: System.Globalization.NumberFormatInfo;
      DateTimeFormat: System.Globalization.DateTimeFormatInfo;
      DisplayName: string;
      EnglishName: string;
      static InstalledUICulture: System.Globalization.CultureInfo;
      IsReadOnly: boolean;
      static DefaultThreadCurrentCulture: System.Globalization.CultureInfo;
      static DefaultThreadCurrentUICulture: System.Globalization.CultureInfo;
      GetConsoleFallbackUICulture(): System.Globalization.CultureInfo;
      ClearCachedData(): void;
      Clone(): any;
      Equals(value: any): boolean;
      static GetCultures(types: System.Globalization.CultureTypes): System.Globalization.CultureInfo[];
      GetHashCode(): number;
      static ReadOnly(ci: System.Globalization.CultureInfo): System.Globalization.CultureInfo;
      ToString(): string;
      GetFormat(formatType: System.Type): any;
      static GetCultureInfo(culture: number): System.Globalization.CultureInfo;
      static GetCultureInfo(name: string): System.Globalization.CultureInfo;
      static GetCultureInfo(name: string, altName: string): System.Globalization.CultureInfo;
      static GetCultureInfoByIetfLanguageTag(name: string): System.Globalization.CultureInfo;
      static CreateSpecificCulture(name: string): System.Globalization.CultureInfo;
      GetType(): System.Type;
    }
    export class IdnMapping {
      constructor();
      AllowUnassigned: boolean;
      UseStd3AsciiRules: boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetAscii(unicode: string): string;
      GetAscii(unicode: string, index: number): string;
      GetAscii(unicode: string, index: number, count: number): string;
      GetUnicode(ascii: string): string;
      GetUnicode(ascii: string, index: number): string;
      GetUnicode(ascii: string, index: number, count: number): string;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RegionInfo {
      constructor(culture: number);
      constructor(name: string);
      static CurrentRegion: System.Globalization.RegionInfo;
      CurrencyEnglishName: string;
      CurrencySymbol: string;
      DisplayName: string;
      EnglishName: string;
      GeoId: number;
      IsMetric: boolean;
      ISOCurrencySymbol: string;
      NativeName: string;
      CurrencyNativeName: string;
      Name: string;
      ThreeLetterISORegionName: string;
      ThreeLetterWindowsRegionName: string;
      TwoLetterISORegionName: string;
      Equals(value: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
  }
  export namespace IO {
    export class DirectoryNotFoundException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class EndOfStreamException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum FileAccess {
      Read = 1,
      Write = 2,
      ReadWrite = 3,
    }
    export class FileLoadException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      constructor(message: string, fileName: string);
      constructor(message: string, fileName: string, inner: System.Exception);
      Message: string;
      FileName: string;
      FusionLog: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum FileMode {
      CreateNew = 1,
      Create = 2,
      Open = 3,
      OpenOrCreate = 4,
      Truncate = 5,
      Append = 6,
    }
    export class FileNotFoundException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      constructor(message: string, fileName: string);
      constructor(message: string, fileName: string, innerException: System.Exception);
      Message: string;
      FileName: string;
      FusionLog: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum FileOptions {
      None = 0,
      WriteThrough = -2147483648,
      Asynchronous = 1073741824,
      RandomAccess = 268435456,
      DeleteOnClose = 67108864,
      SequentialScan = 134217728,
      Encrypted = 16384,
    }
    export enum FileShare {
      None = 0,
      Read = 1,
      Write = 2,
      ReadWrite = 3,
      Delete = 4,
      Inheritable = 16,
    }
    export class IOException {
      constructor();
      constructor(message: string);
      constructor(message: string, hresult: number);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class MemoryStream {
      constructor();
      constructor(capacity: number);
      constructor(buffer: Byte[]);
      constructor(buffer: Byte[], writable: boolean);
      constructor(buffer: Byte[], index: number, count: number);
      constructor(buffer: Byte[], index: number, count: number, writable: boolean);
      constructor(buffer: Byte[], index: number, count: number, writable: boolean, publiclyVisible: boolean);
      CanRead: boolean;
      CanSeek: boolean;
      CanWrite: boolean;
      Capacity: number;
      Length: number;
      Position: number;
      CanTimeout: boolean;
      ReadTimeout: number;
      WriteTimeout: number;
      Flush(): void;
      FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      GetBuffer(): Byte[];
      Read(buffer: Byte[], offset: number, count: number): number;
      Read(buffer: System.Span<Byte>): number;
      ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
      ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      ReadByte(): number;
      CopyTo(destination: System.IO.Stream, bufferSize: number): void;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      Seek(offset: number, loc: System.IO.SeekOrigin): number;
      SetLength(value: number): void;
      ToArray(): Byte[];
      Write(buffer: Byte[], offset: number, count: number): void;
      Write(buffer: System.ReadOnlySpan<Byte>): void;
      WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
      WriteByte(value: Byte): void;
      WriteTo(stream: System.IO.Stream): void;
      CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyTo(destination: System.IO.Stream): void;
      Close(): void;
      Dispose(): void;
      FlushAsync(): System.Threading.Tasks.Task;
      BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
      EndRead(asyncResult: System.IAsyncResult): number;
      ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
      BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
      EndWrite(asyncResult: System.IAsyncResult): void;
      WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PathTooLongException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum SeekOrigin {
      Begin = 0,
      Current = 1,
      End = 2,
    }
    export class StreamReader {
      constructor(stream: System.IO.Stream);
      constructor(stream: System.IO.Stream, detectEncodingFromByteOrderMarks: boolean);
      constructor(stream: System.IO.Stream, encoding: System.Text.Encoding);
      constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean);
      constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: number);
      constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: number, leaveOpen: boolean);
      constructor(path: string);
      constructor(path: string, detectEncodingFromByteOrderMarks: boolean);
      constructor(path: string, encoding: System.Text.Encoding);
      constructor(path: string, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean);
      constructor(path: string, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: number);
      CurrentEncoding: System.Text.Encoding;
      BaseStream: System.IO.Stream;
      EndOfStream: boolean;
      static Null: System.IO.StreamReader;
      Close(): void;
      DiscardBufferedData(): void;
      Peek(): number;
      Read(): number;
      Read(buffer: System.Char[], index: number, count: number): number;
      Read(buffer: System.Span<System.Char>): number;
      ReadToEnd(): string;
      ReadBlock(buffer: System.Char[], index: number, count: number): number;
      ReadBlock(buffer: System.Span<System.Char>): number;
      ReadLine(): string;
      ReadLineAsync(): System.Threading.Tasks.Task<string>;
      ReadToEndAsync(): System.Threading.Tasks.Task<string>;
      ReadAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task<number>;
      ReadAsync(buffer: System.Memory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      ReadBlockAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task<number>;
      ReadBlockAsync(buffer: System.Memory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      Dispose(): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StreamWriter {
      constructor(stream: System.IO.Stream);
      constructor(stream: System.IO.Stream, encoding: System.Text.Encoding);
      constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, bufferSize: number);
      constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, bufferSize: number, leaveOpen: boolean);
      constructor(path: string);
      constructor(path: string, append: boolean);
      constructor(path: string, append: boolean, encoding: System.Text.Encoding);
      constructor(path: string, append: boolean, encoding: System.Text.Encoding, bufferSize: number);
      AutoFlush: boolean;
      BaseStream: System.IO.Stream;
      Encoding: System.Text.Encoding;
      FormatProvider: System.IFormatProvider;
      NewLine: string;
      static Null: System.IO.StreamWriter;
      Close(): void;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      Flush(): void;
      Write(value: System.Char): void;
      Write(buffer: System.Char[]): void;
      Write(buffer: System.Char[], index: number, count: number): void;
      Write(buffer: System.ReadOnlySpan<System.Char>): void;
      Write(value: string): void;
      WriteLine(value: string): void;
      WriteLine(value: System.ReadOnlySpan<System.Char>): void;
      WriteAsync(value: System.Char): System.Threading.Tasks.Task;
      WriteAsync(value: string): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.ReadOnlyMemory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WriteLineAsync(): System.Threading.Tasks.Task;
      WriteLineAsync(value: System.Char): System.Threading.Tasks.Task;
      WriteLineAsync(value: string): System.Threading.Tasks.Task;
      WriteLineAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task;
      WriteLineAsync(buffer: System.ReadOnlyMemory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      FlushAsync(): System.Threading.Tasks.Task;
      Dispose(): void;
      Write(value: boolean): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: any): void;
      Write(format: string, arg0: any): void;
      Write(format: string, arg0: any, arg1: any): void;
      Write(format: string, arg0: any, arg1: any, arg2: any): void;
      Write(format: string, ...arg: any[]): void;
      WriteLine(): void;
      WriteLine(value: System.Char): void;
      WriteLine(buffer: System.Char[]): void;
      WriteLine(buffer: System.Char[], index: number, count: number): void;
      WriteLine(value: boolean): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: any): void;
      WriteLine(format: string, arg0: any): void;
      WriteLine(format: string, arg0: any, arg1: any): void;
      WriteLine(format: string, arg0: any, arg1: any, arg2: any): void;
      WriteLine(format: string, ...arg: any[]): void;
      WriteAsync(buffer: System.Char[]): System.Threading.Tasks.Task;
      WriteLineAsync(buffer: System.Char[]): System.Threading.Tasks.Task;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TextReader {
      static Null: System.IO.TextReader;
      Close(): void;
      Dispose(): void;
      Peek(): number;
      Read(): number;
      Read(buffer: System.Char[], index: number, count: number): number;
      Read(buffer: System.Span<System.Char>): number;
      ReadToEnd(): string;
      ReadBlock(buffer: System.Char[], index: number, count: number): number;
      ReadBlock(buffer: System.Span<System.Char>): number;
      ReadLine(): string;
      ReadLineAsync(): System.Threading.Tasks.Task<string>;
      ReadToEndAsync(): System.Threading.Tasks.Task<string>;
      ReadAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task<number>;
      ReadAsync(buffer: System.Memory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      ReadBlockAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task<number>;
      ReadBlockAsync(buffer: System.Memory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      static Synchronized(reader: System.IO.TextReader): System.IO.TextReader;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TextWriter {
      FormatProvider: System.IFormatProvider;
      Encoding: System.Text.Encoding;
      NewLine: string;
      static Null: System.IO.TextWriter;
      Close(): void;
      Dispose(): void;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      Flush(): void;
      Write(value: System.Char): void;
      Write(buffer: System.Char[]): void;
      Write(buffer: System.Char[], index: number, count: number): void;
      Write(buffer: System.ReadOnlySpan<System.Char>): void;
      Write(value: boolean): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: string): void;
      Write(value: any): void;
      Write(format: string, arg0: any): void;
      Write(format: string, arg0: any, arg1: any): void;
      Write(format: string, arg0: any, arg1: any, arg2: any): void;
      Write(format: string, ...arg: any[]): void;
      WriteLine(): void;
      WriteLine(value: System.Char): void;
      WriteLine(buffer: System.Char[]): void;
      WriteLine(buffer: System.Char[], index: number, count: number): void;
      WriteLine(buffer: System.ReadOnlySpan<System.Char>): void;
      WriteLine(value: boolean): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: string): void;
      WriteLine(value: any): void;
      WriteLine(format: string, arg0: any): void;
      WriteLine(format: string, arg0: any, arg1: any): void;
      WriteLine(format: string, arg0: any, arg1: any, arg2: any): void;
      WriteLine(format: string, ...arg: any[]): void;
      WriteAsync(value: System.Char): System.Threading.Tasks.Task;
      WriteAsync(value: string): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.Char[]): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.ReadOnlyMemory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WriteLineAsync(value: System.Char): System.Threading.Tasks.Task;
      WriteLineAsync(value: string): System.Threading.Tasks.Task;
      WriteLineAsync(buffer: System.Char[]): System.Threading.Tasks.Task;
      WriteLineAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task;
      WriteLineAsync(buffer: System.ReadOnlyMemory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WriteLineAsync(): System.Threading.Tasks.Task;
      FlushAsync(): System.Threading.Tasks.Task;
      static Synchronized(writer: System.IO.TextWriter): System.IO.TextWriter;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class UnmanagedMemoryAccessor {
      constructor(buffer: System.Runtime.InteropServices.SafeBuffer, offset: number, capacity: number);
      constructor(buffer: System.Runtime.InteropServices.SafeBuffer, offset: number, capacity: number, access: System.IO.FileAccess);
      Capacity: number;
      CanRead: boolean;
      CanWrite: boolean;
      Dispose(): void;
      ReadBoolean(position: number): boolean;
      ReadByte(position: number): Byte;
      ReadChar(position: number): System.Char;
      ReadInt16(position: number): number;
      ReadInt32(position: number): number;
      ReadInt64(position: number): number;
      ReadDecimal(position: number): number;
      ReadSingle(position: number): number;
      ReadDouble(position: number): number;
      ReadSByte(position: number): System.SByte;
      ReadUInt16(position: number): number;
      ReadUInt32(position: number): number;
      ReadUInt64(position: number): number;
      Write(position: number, value: boolean): void;
      Write(position: number, value: Byte): void;
      Write(position: number, value: System.Char): void;
      Write(position: number, value: number): void;
      Write(position: number, value: number): void;
      Write(position: number, value: number): void;
      Write(position: number, value: number): void;
      Write(position: number, value: number): void;
      Write(position: number, value: number): void;
      Write(position: number, value: System.SByte): void;
      Write(position: number, value: number): void;
      Write(position: number, value: number): void;
      Write(position: number, value: number): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class UnmanagedMemoryStream {
      constructor(buffer: System.Runtime.InteropServices.SafeBuffer, offset: number, length: number);
      constructor(buffer: System.Runtime.InteropServices.SafeBuffer, offset: number, length: number, access: System.IO.FileAccess);
      CanRead: boolean;
      CanSeek: boolean;
      CanWrite: boolean;
      Length: number;
      Capacity: number;
      Position: number;
      CanTimeout: boolean;
      ReadTimeout: number;
      WriteTimeout: number;
      Flush(): void;
      FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      Read(buffer: Byte[], offset: number, count: number): number;
      Read(buffer: System.Span<Byte>): number;
      ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
      ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      ReadByte(): number;
      Seek(offset: number, loc: System.IO.SeekOrigin): number;
      SetLength(value: number): void;
      Write(buffer: Byte[], offset: number, count: number): void;
      Write(buffer: System.ReadOnlySpan<Byte>): void;
      WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
      WriteByte(value: Byte): void;
      CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyTo(destination: System.IO.Stream): void;
      CopyTo(destination: System.IO.Stream, bufferSize: number): void;
      Close(): void;
      Dispose(): void;
      FlushAsync(): System.Threading.Tasks.Task;
      BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
      EndRead(asyncResult: System.IAsyncResult): number;
      ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
      BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
      EndWrite(asyncResult: System.IAsyncResult): void;
      WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DriveNotFoundException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum DriveType {
      Unknown = 0,
      NoRootDirectory = 1,
      Removable = 2,
      Fixed = 3,
      Network = 4,
      CDRom = 5,
      Ram = 6,
    }
    export class Directory {
      static GetParent(path: string): System.IO.DirectoryInfo;
      static CreateDirectory(path: string): System.IO.DirectoryInfo;
      static Exists(path: string): boolean;
      static SetCreationTime(path: string, creationTime: System.DateTime): void;
      static SetCreationTimeUtc(path: string, creationTimeUtc: System.DateTime): void;
      static GetCreationTime(path: string): System.DateTime;
      static GetCreationTimeUtc(path: string): System.DateTime;
      static SetLastWriteTime(path: string, lastWriteTime: System.DateTime): void;
      static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: System.DateTime): void;
      static GetLastWriteTime(path: string): System.DateTime;
      static GetLastWriteTimeUtc(path: string): System.DateTime;
      static SetLastAccessTime(path: string, lastAccessTime: System.DateTime): void;
      static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: System.DateTime): void;
      static GetLastAccessTime(path: string): System.DateTime;
      static GetLastAccessTimeUtc(path: string): System.DateTime;
      static GetFiles(path: string): string[];
      static GetFiles(path: string, searchPattern: string): string[];
      static GetFiles(path: string, searchPattern: string, searchOption: System.IO.SearchOption): string[];
      static GetFiles(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): string[];
      static GetDirectories(path: string): string[];
      static GetDirectories(path: string, searchPattern: string): string[];
      static GetDirectories(path: string, searchPattern: string, searchOption: System.IO.SearchOption): string[];
      static GetDirectories(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): string[];
      static GetFileSystemEntries(path: string): string[];
      static GetFileSystemEntries(path: string, searchPattern: string): string[];
      static GetFileSystemEntries(path: string, searchPattern: string, searchOption: System.IO.SearchOption): string[];
      static GetFileSystemEntries(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): string[];
      static EnumerateDirectories(path: string): any;
      static EnumerateDirectories(path: string, searchPattern: string): any;
      static EnumerateDirectories(path: string, searchPattern: string, searchOption: System.IO.SearchOption): any;
      static EnumerateDirectories(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): any;
      static EnumerateFiles(path: string): any;
      static EnumerateFiles(path: string, searchPattern: string): any;
      static EnumerateFiles(path: string, searchPattern: string, searchOption: System.IO.SearchOption): any;
      static EnumerateFiles(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): any;
      static EnumerateFileSystemEntries(path: string): any;
      static EnumerateFileSystemEntries(path: string, searchPattern: string): any;
      static EnumerateFileSystemEntries(path: string, searchPattern: string, searchOption: System.IO.SearchOption): any;
      static EnumerateFileSystemEntries(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): any;
      static GetDirectoryRoot(path: string): string;
      static GetCurrentDirectory(): string;
      static SetCurrentDirectory(path: string): void;
      static Move(sourceDirName: string, destDirName: string): void;
      static Delete(path: string): void;
      static Delete(path: string, recursive: boolean): void;
      static GetLogicalDrives(): string[];
      static CreateDirectory(path: string, directorySecurity: System.Security.AccessControl.DirectorySecurity): System.IO.DirectoryInfo;
      static GetAccessControl(path: string, includeSections: System.Security.AccessControl.AccessControlSections): System.Security.AccessControl.DirectorySecurity;
      static GetAccessControl(path: string): System.Security.AccessControl.DirectorySecurity;
      static SetAccessControl(path: string, directorySecurity: System.Security.AccessControl.DirectorySecurity): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DirectoryInfo {
      constructor(path: string);
      Parent: System.IO.DirectoryInfo;
      Root: System.IO.DirectoryInfo;
      Attributes: System.IO.FileAttributes;
      FullName: string;
      Extension: string;
      Name: string;
      Exists: boolean;
      CreationTime: System.DateTime;
      CreationTimeUtc: System.DateTime;
      LastAccessTime: System.DateTime;
      LastAccessTimeUtc: System.DateTime;
      LastWriteTime: System.DateTime;
      LastWriteTimeUtc: System.DateTime;
      CreateSubdirectory(path: string): System.IO.DirectoryInfo;
      Create(): void;
      GetFiles(): System.IO.FileInfo[];
      GetFiles(searchPattern: string): System.IO.FileInfo[];
      GetFiles(searchPattern: string, searchOption: System.IO.SearchOption): System.IO.FileInfo[];
      GetFiles(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): System.IO.FileInfo[];
      GetFileSystemInfos(): System.IO.FileSystemInfo[];
      GetFileSystemInfos(searchPattern: string): System.IO.FileSystemInfo[];
      GetFileSystemInfos(searchPattern: string, searchOption: System.IO.SearchOption): System.IO.FileSystemInfo[];
      GetFileSystemInfos(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): System.IO.FileSystemInfo[];
      GetDirectories(): System.IO.DirectoryInfo[];
      GetDirectories(searchPattern: string): System.IO.DirectoryInfo[];
      GetDirectories(searchPattern: string, searchOption: System.IO.SearchOption): System.IO.DirectoryInfo[];
      GetDirectories(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): System.IO.DirectoryInfo[];
      EnumerateDirectories(): System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo>;
      EnumerateDirectories(searchPattern: string): System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo>;
      EnumerateDirectories(searchPattern: string, searchOption: System.IO.SearchOption): System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo>;
      EnumerateDirectories(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo>;
      EnumerateFiles(): System.Collections.Generic.IEnumerable<System.IO.FileInfo>;
      EnumerateFiles(searchPattern: string): System.Collections.Generic.IEnumerable<System.IO.FileInfo>;
      EnumerateFiles(searchPattern: string, searchOption: System.IO.SearchOption): System.Collections.Generic.IEnumerable<System.IO.FileInfo>;
      EnumerateFiles(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): System.Collections.Generic.IEnumerable<System.IO.FileInfo>;
      EnumerateFileSystemInfos(): System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo>;
      EnumerateFileSystemInfos(searchPattern: string): System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo>;
      EnumerateFileSystemInfos(searchPattern: string, searchOption: System.IO.SearchOption): System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo>;
      EnumerateFileSystemInfos(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions): System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo>;
      MoveTo(destDirName: string): void;
      Delete(): void;
      Delete(recursive: boolean): void;
      Create(directorySecurity: System.Security.AccessControl.DirectorySecurity): void;
      CreateSubdirectory(path: string, directorySecurity: System.Security.AccessControl.DirectorySecurity): System.IO.DirectoryInfo;
      GetAccessControl(): System.Security.AccessControl.DirectorySecurity;
      GetAccessControl(includeSections: System.Security.AccessControl.AccessControlSections): System.Security.AccessControl.DirectorySecurity;
      SetAccessControl(directorySecurity: System.Security.AccessControl.DirectorySecurity): void;
      Refresh(): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class EnumerationOptions {
      constructor();
      RecurseSubdirectories: boolean;
      IgnoreInaccessible: boolean;
      BufferSize: number;
      AttributesToSkip: System.IO.FileAttributes;
      MatchType: System.IO.MatchType;
      MatchCasing: System.IO.MatchCasing;
      ReturnSpecialDirectories: boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class File {
      static OpenText(path: string): System.IO.StreamReader;
      static CreateText(path: string): System.IO.StreamWriter;
      static AppendText(path: string): System.IO.StreamWriter;
      static Copy(sourceFileName: string, destFileName: string): void;
      static Copy(sourceFileName: string, destFileName: string, overwrite: boolean): void;
      static Create(path: string): System.IO.FileStream;
      static Create(path: string, bufferSize: number): System.IO.FileStream;
      static Create(path: string, bufferSize: number, options: System.IO.FileOptions): System.IO.FileStream;
      static Delete(path: string): void;
      static Exists(path: string): boolean;
      static Open(path: string, mode: System.IO.FileMode): System.IO.FileStream;
      static Open(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess): System.IO.FileStream;
      static Open(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare): System.IO.FileStream;
      static SetCreationTime(path: string, creationTime: System.DateTime): void;
      static SetCreationTimeUtc(path: string, creationTimeUtc: System.DateTime): void;
      static GetCreationTime(path: string): System.DateTime;
      static GetCreationTimeUtc(path: string): System.DateTime;
      static SetLastAccessTime(path: string, lastAccessTime: System.DateTime): void;
      static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: System.DateTime): void;
      static GetLastAccessTime(path: string): System.DateTime;
      static GetLastAccessTimeUtc(path: string): System.DateTime;
      static SetLastWriteTime(path: string, lastWriteTime: System.DateTime): void;
      static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: System.DateTime): void;
      static GetLastWriteTime(path: string): System.DateTime;
      static GetLastWriteTimeUtc(path: string): System.DateTime;
      static GetAttributes(path: string): System.IO.FileAttributes;
      static SetAttributes(path: string, fileAttributes: System.IO.FileAttributes): void;
      static OpenRead(path: string): System.IO.FileStream;
      static OpenWrite(path: string): System.IO.FileStream;
      static ReadAllText(path: string): string;
      static ReadAllText(path: string, encoding: System.Text.Encoding): string;
      static WriteAllText(path: string, contents: string): void;
      static WriteAllText(path: string, contents: string, encoding: System.Text.Encoding): void;
      static ReadAllBytes(path: string): Byte[];
      static WriteAllBytes(path: string, bytes: Byte[]): void;
      static ReadAllLines(path: string): string[];
      static ReadAllLines(path: string, encoding: System.Text.Encoding): string[];
      static ReadLines(path: string): any;
      static ReadLines(path: string, encoding: System.Text.Encoding): any;
      static WriteAllLines(path: string, contents: string[]): void;
      static WriteAllLines(path: string, contents: any): void;
      static WriteAllLines(path: string, contents: string[], encoding: System.Text.Encoding): void;
      static WriteAllLines(path: string, contents: any, encoding: System.Text.Encoding): void;
      static AppendAllText(path: string, contents: string): void;
      static AppendAllText(path: string, contents: string, encoding: System.Text.Encoding): void;
      static AppendAllLines(path: string, contents: any): void;
      static AppendAllLines(path: string, contents: any, encoding: System.Text.Encoding): void;
      static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string): void;
      static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): void;
      static Move(sourceFileName: string, destFileName: string): void;
      static Encrypt(path: string): void;
      static Decrypt(path: string): void;
      static ReadAllTextAsync(path: string, cancellationToken?: System.Threading.CancellationToken): any;
      static ReadAllTextAsync(path: string, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken): any;
      static WriteAllTextAsync(path: string, contents: string, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      static WriteAllTextAsync(path: string, contents: string, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      static ReadAllBytesAsync(path: string, cancellationToken?: System.Threading.CancellationToken): any;
      static WriteAllBytesAsync(path: string, bytes: Byte[], cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      static ReadAllLinesAsync(path: string, cancellationToken?: System.Threading.CancellationToken): any;
      static ReadAllLinesAsync(path: string, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken): any;
      static WriteAllLinesAsync(path: string, contents: any, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      static WriteAllLinesAsync(path: string, contents: any, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      static AppendAllTextAsync(path: string, contents: string, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      static AppendAllTextAsync(path: string, contents: string, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      static AppendAllLinesAsync(path: string, contents: any, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      static AppendAllLinesAsync(path: string, contents: any, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      static Create(path: string, bufferSize: number, options: System.IO.FileOptions, fileSecurity: System.Security.AccessControl.FileSecurity): System.IO.FileStream;
      static GetAccessControl(path: string): System.Security.AccessControl.FileSecurity;
      static GetAccessControl(path: string, includeSections: System.Security.AccessControl.AccessControlSections): System.Security.AccessControl.FileSecurity;
      static SetAccessControl(path: string, fileSecurity: System.Security.AccessControl.FileSecurity): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class FileInfo {
      constructor(fileName: string);
      Length: number;
      DirectoryName: string;
      Directory: System.IO.DirectoryInfo;
      IsReadOnly: boolean;
      Name: string;
      Attributes: System.IO.FileAttributes;
      FullName: string;
      Extension: string;
      Exists: boolean;
      CreationTime: System.DateTime;
      CreationTimeUtc: System.DateTime;
      LastAccessTime: System.DateTime;
      LastAccessTimeUtc: System.DateTime;
      LastWriteTime: System.DateTime;
      LastWriteTimeUtc: System.DateTime;
      OpenText(): System.IO.StreamReader;
      CreateText(): System.IO.StreamWriter;
      AppendText(): System.IO.StreamWriter;
      CopyTo(destFileName: string): System.IO.FileInfo;
      CopyTo(destFileName: string, overwrite: boolean): System.IO.FileInfo;
      Create(): System.IO.FileStream;
      Delete(): void;
      Open(mode: System.IO.FileMode): System.IO.FileStream;
      Open(mode: System.IO.FileMode, access: System.IO.FileAccess): System.IO.FileStream;
      Open(mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare): System.IO.FileStream;
      OpenRead(): System.IO.FileStream;
      OpenWrite(): System.IO.FileStream;
      MoveTo(destFileName: string): void;
      Replace(destinationFileName: string, destinationBackupFileName: string): System.IO.FileInfo;
      Replace(destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): System.IO.FileInfo;
      Decrypt(): void;
      Encrypt(): void;
      GetAccessControl(): System.Security.AccessControl.FileSecurity;
      GetAccessControl(includeSections: System.Security.AccessControl.AccessControlSections): System.Security.AccessControl.FileSecurity;
      SetAccessControl(fileSecurity: System.Security.AccessControl.FileSecurity): void;
      Refresh(): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class FileSystemInfo {
      Attributes: System.IO.FileAttributes;
      FullName: string;
      Extension: string;
      Name: string;
      Exists: boolean;
      CreationTime: System.DateTime;
      CreationTimeUtc: System.DateTime;
      LastAccessTime: System.DateTime;
      LastAccessTimeUtc: System.DateTime;
      LastWriteTime: System.DateTime;
      LastWriteTimeUtc: System.DateTime;
      Refresh(): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Delete(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum MatchCasing {
      PlatformDefault = 0,
      CaseSensitive = 1,
      CaseInsensitive = 2,
    }
    export enum MatchType {
      Simple = 0,
      Win32 = 1,
    }
    export enum SearchOption {
      TopDirectoryOnly = 0,
      AllDirectories = 1,
    }
    export class BufferedStream {
      constructor(stream: System.IO.Stream);
      constructor(stream: System.IO.Stream, bufferSize: number);
      UnderlyingStream: System.IO.Stream;
      BufferSize: number;
      CanRead: boolean;
      CanWrite: boolean;
      CanSeek: boolean;
      Length: number;
      Position: number;
      CanTimeout: boolean;
      ReadTimeout: number;
      WriteTimeout: number;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      Flush(): void;
      FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      Read(array: Byte[], offset: number, count: number): number;
      Read(destination: System.Span<Byte>): number;
      ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
      ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
      EndRead(asyncResult: System.IAsyncResult): number;
      ReadByte(): number;
      Write(array: Byte[], offset: number, count: number): void;
      Write(buffer: System.ReadOnlySpan<Byte>): void;
      WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
      BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
      EndWrite(asyncResult: System.IAsyncResult): void;
      WriteByte(value: Byte): void;
      Seek(offset: number, origin: System.IO.SeekOrigin): number;
      SetLength(value: number): void;
      CopyTo(destination: System.IO.Stream, bufferSize: number): void;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyTo(destination: System.IO.Stream): void;
      Close(): void;
      Dispose(): void;
      FlushAsync(): System.Threading.Tasks.Task;
      ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
      WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum FileAttributes {
      ReadOnly = 1,
      Hidden = 2,
      System = 4,
      Directory = 16,
      Archive = 32,
      Device = 64,
      Normal = 128,
      Temporary = 256,
      SparseFile = 512,
      ReparsePoint = 1024,
      Compressed = 2048,
      Offline = 4096,
      NotContentIndexed = 8192,
      Encrypted = 16384,
      IntegrityStream = 32768,
      NoScrubData = 131072,
    }
    export class Stream {
      CanRead: boolean;
      CanSeek: boolean;
      CanTimeout: boolean;
      CanWrite: boolean;
      Length: number;
      Position: number;
      ReadTimeout: number;
      WriteTimeout: number;
      static Null: System.IO.Stream;
      CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyTo(destination: System.IO.Stream): void;
      CopyTo(destination: System.IO.Stream, bufferSize: number): void;
      Close(): void;
      Dispose(): void;
      Flush(): void;
      FlushAsync(): System.Threading.Tasks.Task;
      FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
      EndRead(asyncResult: System.IAsyncResult): number;
      ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
      ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
      ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
      EndWrite(asyncResult: System.IAsyncResult): void;
      WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
      WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
      Seek(offset: number, origin: System.IO.SeekOrigin): number;
      SetLength(value: number): void;
      Read(buffer: Byte[], offset: number, count: number): number;
      Read(buffer: System.Span<Byte>): number;
      ReadByte(): number;
      Write(buffer: Byte[], offset: number, count: number): void;
      Write(buffer: System.ReadOnlySpan<Byte>): void;
      WriteByte(value: Byte): void;
      static Synchronized(stream: System.IO.Stream): System.IO.Stream;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BinaryReader {
      constructor(input: System.IO.Stream);
      constructor(input: System.IO.Stream, encoding: System.Text.Encoding);
      constructor(input: System.IO.Stream, encoding: System.Text.Encoding, leaveOpen: boolean);
      BaseStream: System.IO.Stream;
      Close(): void;
      Dispose(): void;
      PeekChar(): number;
      Read(): number;
      ReadBoolean(): boolean;
      ReadByte(): Byte;
      ReadSByte(): System.SByte;
      ReadChar(): System.Char;
      ReadInt16(): number;
      ReadUInt16(): number;
      ReadInt32(): number;
      ReadUInt32(): number;
      ReadInt64(): number;
      ReadUInt64(): number;
      ReadSingle(): number;
      ReadDouble(): number;
      ReadDecimal(): number;
      ReadString(): string;
      Read(buffer: System.Char[], index: number, count: number): number;
      ReadChars(count: number): System.Char[];
      Read(buffer: System.Span<System.Char>): number;
      Read(buffer: System.Span<Byte>): number;
      Read(buffer: Byte[], index: number, count: number): number;
      ReadBytes(count: number): Byte[];
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BinaryWriter {
      constructor(output: System.IO.Stream);
      constructor(output: System.IO.Stream, encoding: System.Text.Encoding);
      constructor(output: System.IO.Stream, encoding: System.Text.Encoding, leaveOpen: boolean);
      BaseStream: System.IO.Stream;
      static Null: System.IO.BinaryWriter;
      Close(): void;
      Dispose(): void;
      Flush(): void;
      Seek(offset: number, origin: System.IO.SeekOrigin): number;
      Write(buffer: System.ReadOnlySpan<Byte>): void;
      Write(buffer: System.ReadOnlySpan<System.Char>): void;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      Write(value: boolean): void;
      Write(value: Byte): void;
      Write(value: System.SByte): void;
      Write(buffer: Byte[]): void;
      Write(buffer: Byte[], index: number, count: number): void;
      Write(ch: System.Char): void;
      Write(chars: System.Char[]): void;
      Write(chars: System.Char[], index: number, count: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: string): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StringReader {
      constructor(s: string);
      Close(): void;
      Peek(): number;
      Read(): number;
      Read(buffer: System.Char[], index: number, count: number): number;
      ReadToEnd(): string;
      ReadLine(): string;
      ReadLineAsync(): System.Threading.Tasks.Task<string>;
      ReadToEndAsync(): System.Threading.Tasks.Task<string>;
      ReadBlockAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task<number>;
      ReadAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task<number>;
      Dispose(): void;
      Read(buffer: System.Span<System.Char>): number;
      ReadBlock(buffer: System.Char[], index: number, count: number): number;
      ReadBlock(buffer: System.Span<System.Char>): number;
      ReadAsync(buffer: System.Memory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      ReadBlockAsync(buffer: System.Memory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StringWriter {
      constructor();
      constructor(formatProvider: System.IFormatProvider);
      constructor(sb: System.Text.StringBuilder);
      constructor(sb: System.Text.StringBuilder, formatProvider: System.IFormatProvider);
      Encoding: System.Text.Encoding;
      FormatProvider: System.IFormatProvider;
      NewLine: string;
      Close(): void;
      GetStringBuilder(): System.Text.StringBuilder;
      Write(value: System.Char): void;
      Write(buffer: System.Char[], index: number, count: number): void;
      Write(value: string): void;
      WriteAsync(value: System.Char): System.Threading.Tasks.Task;
      WriteAsync(value: string): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task;
      WriteLineAsync(value: System.Char): System.Threading.Tasks.Task;
      WriteLineAsync(value: string): System.Threading.Tasks.Task;
      WriteLineAsync(buffer: System.Char[], index: number, count: number): System.Threading.Tasks.Task;
      FlushAsync(): System.Threading.Tasks.Task;
      ToString(): string;
      Dispose(): void;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      Flush(): void;
      Write(buffer: System.Char[]): void;
      Write(buffer: System.ReadOnlySpan<System.Char>): void;
      Write(value: boolean): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: number): void;
      Write(value: any): void;
      Write(format: string, arg0: any): void;
      Write(format: string, arg0: any, arg1: any): void;
      Write(format: string, arg0: any, arg1: any, arg2: any): void;
      Write(format: string, ...arg: any[]): void;
      WriteLine(): void;
      WriteLine(value: System.Char): void;
      WriteLine(buffer: System.Char[]): void;
      WriteLine(buffer: System.Char[], index: number, count: number): void;
      WriteLine(buffer: System.ReadOnlySpan<System.Char>): void;
      WriteLine(value: boolean): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: number): void;
      WriteLine(value: string): void;
      WriteLine(value: any): void;
      WriteLine(format: string, arg0: any): void;
      WriteLine(format: string, arg0: any, arg1: any): void;
      WriteLine(format: string, arg0: any, arg1: any, arg2: any): void;
      WriteLine(format: string, ...arg: any[]): void;
      WriteAsync(buffer: System.Char[]): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.ReadOnlyMemory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WriteLineAsync(buffer: System.Char[]): System.Threading.Tasks.Task;
      WriteLineAsync(buffer: System.ReadOnlyMemory<System.Char>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WriteLineAsync(): System.Threading.Tasks.Task;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class DriveInfo {
      constructor(driveName: string);
      AvailableFreeSpace: number;
      TotalFreeSpace: number;
      TotalSize: number;
      VolumeLabel: string;
      DriveFormat: string;
      DriveType: System.IO.DriveType;
      Name: string;
      RootDirectory: System.IO.DirectoryInfo;
      IsReady: boolean;
      static GetDrives(): System.IO.DriveInfo[];
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class FileStream {
      constructor(handle: System.IntPtr, access: System.IO.FileAccess);
      constructor(handle: System.IntPtr, access: System.IO.FileAccess, ownsHandle: boolean);
      constructor(handle: System.IntPtr, access: System.IO.FileAccess, ownsHandle: boolean, bufferSize: number);
      constructor(handle: System.IntPtr, access: System.IO.FileAccess, ownsHandle: boolean, bufferSize: number, isAsync: boolean);
      constructor(path: string, mode: System.IO.FileMode);
      constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess);
      constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare);
      constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare, bufferSize: number);
      constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare, bufferSize: number, useAsync: boolean);
      constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare, bufferSize: number, options: System.IO.FileOptions);
      constructor(handle: any, access: System.IO.FileAccess);
      constructor(handle: any, access: System.IO.FileAccess, bufferSize: number);
      constructor(handle: any, access: System.IO.FileAccess, bufferSize: number, isAsync: boolean);
      constructor(path: string, mode: System.IO.FileMode, rights: System.Security.AccessControl.FileSystemRights, share: System.IO.FileShare, bufferSize: number, options: System.IO.FileOptions);
      constructor(path: string, mode: System.IO.FileMode, rights: System.Security.AccessControl.FileSystemRights, share: System.IO.FileShare, bufferSize: number, options: System.IO.FileOptions, fileSecurity: System.Security.AccessControl.FileSecurity);
      CanRead: boolean;
      CanWrite: boolean;
      CanSeek: boolean;
      IsAsync: boolean;
      Name: string;
      Length: number;
      Position: number;
      Handle: System.IntPtr;
      SafeFileHandle: any; // Microsoft.Win32.SafeHandles.SafeFileHandle
      CanTimeout: boolean;
      ReadTimeout: number;
      WriteTimeout: number;
      ReadByte(): number;
      WriteByte(value: Byte): void;
      Read(array: Byte[], offset: number, count: number): number;
      BeginRead(array: Byte[], offset: number, numBytes: number, userCallback: ((ar: System.IAsyncResult) => void), stateObject: any): System.IAsyncResult;
      EndRead(asyncResult: System.IAsyncResult): number;
      Write(array: Byte[], offset: number, count: number): void;
      BeginWrite(array: Byte[], offset: number, numBytes: number, userCallback: ((ar: System.IAsyncResult) => void), stateObject: any): System.IAsyncResult;
      EndWrite(asyncResult: System.IAsyncResult): void;
      Seek(offset: number, origin: System.IO.SeekOrigin): number;
      SetLength(value: number): void;
      Flush(): void;
      Flush(flushToDisk: boolean): void;
      Lock(position: number, length: number): void;
      Unlock(position: number, length: number): void;
      GetAccessControl(): System.Security.AccessControl.FileSecurity;
      SetAccessControl(fileSecurity: System.Security.AccessControl.FileSecurity): void;
      FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
      WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      CopyTo(destination: System.IO.Stream): void;
      CopyTo(destination: System.IO.Stream, bufferSize: number): void;
      Close(): void;
      Dispose(): void;
      FlushAsync(): System.Threading.Tasks.Task;
      ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
      ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
      WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
      WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
      Read(buffer: System.Span<Byte>): number;
      Write(buffer: System.ReadOnlySpan<Byte>): void;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Path {
      static InvalidPathChars: System.Char[];
      static AltDirectorySeparatorChar: System.Char;
      static DirectorySeparatorChar: System.Char;
      static PathSeparator: System.Char;
      static VolumeSeparatorChar: System.Char;
      static ChangeExtension(path: string, extension: string): string;
      static Combine(path1: string, path2: string): string;
      static GetDirectoryName(path: string): string;
      static GetDirectoryName(path: any): any;
      static GetExtension(path: string): string;
      static GetFileName(path: string): string;
      static GetFileNameWithoutExtension(path: string): string;
      static GetFullPath(path: string): string;
      static GetPathRoot(path: string): string;
      static GetTempFileName(): string;
      static GetTempPath(): string;
      static HasExtension(path: string): boolean;
      static IsPathRooted(path: any): boolean;
      static IsPathRooted(path: string): boolean;
      static GetInvalidFileNameChars(): System.Char[];
      static GetInvalidPathChars(): System.Char[];
      static GetRandomFileName(): string;
      static Combine(...paths: string[]): string;
      static Combine(path1: string, path2: string, path3: string): string;
      static Combine(path1: string, path2: string, path3: string, path4: string): string;
      static GetFileName(path: any): any;
      static Join(path1: any, path2: any): string;
      static Join(path1: any, path2: any, path3: any): string;
      static GetExtension(path: any): any;
      static GetFileNameWithoutExtension(path: any): any;
      static GetPathRoot(path: any): any;
      static HasExtension(path: any): boolean;
      static GetRelativePath(relativeTo: string, path: string): string;
      static IsPathFullyQualified(path: string): boolean;
      static IsPathFullyQualified(path: any): boolean;
      static GetFullPath(path: string, basePath: string): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum HandleInheritability {
      None = 0,
      Inheritable = 1,
    }
    export class FileSystemEventArgs {
      constructor(changeType: System.IO.WatcherChangeTypes, directory: string, name: string);
      ChangeType: System.IO.WatcherChangeTypes;
      FullPath: string;
      Name: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class FileSystemEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.IO.FileSystemEventArgs): void;
      BeginInvoke(sender: any, e: System.IO.FileSystemEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RenamedEventArgs {
      constructor(changeType: System.IO.WatcherChangeTypes, directory: string, name: string, oldName: string);
      OldFullPath: string;
      OldName: string;
      ChangeType: System.IO.WatcherChangeTypes;
      FullPath: string;
      Name: string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RenamedEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.IO.RenamedEventArgs): void;
      BeginInvoke(sender: any, e: System.IO.RenamedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class WaitForChangedResult {
      ChangeType: System.IO.WatcherChangeTypes;
      Name: string;
      OldName: string;
      TimedOut: boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class ErrorEventArgs {
      constructor(exception: System.Exception);
      GetException(): System.Exception;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ErrorEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.IO.ErrorEventArgs): void;
      BeginInvoke(sender: any, e: System.IO.ErrorEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class FileSystemWatcher {
      constructor();
      constructor(path: string);
      constructor(path: string, filter: string);
      EnableRaisingEvents: boolean;
      Filter: string;
      IncludeSubdirectories: boolean;
      InternalBufferSize: number;
      NotifyFilter: System.IO.NotifyFilters;
      Path: string;
      Site: System.ComponentModel.ISite;
      SynchronizingObject: System.ComponentModel.ISynchronizeInvoke;
      Container: System.ComponentModel.IContainer;
      BeginInit(): void;
      EndInit(): void;
      WaitForChanged(changeType: System.IO.WatcherChangeTypes): System.IO.WaitForChangedResult;
      WaitForChanged(changeType: System.IO.WatcherChangeTypes, timeout: number): System.IO.WaitForChangedResult;
      Dispose(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class InternalBufferOverflowException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class InvalidDataException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum NotifyFilters {
      Attributes = 4,
      CreationTime = 64,
      DirectoryName = 2,
      FileName = 1,
      LastAccess = 32,
      LastWrite = 16,
      Security = 256,
      Size = 8,
    }
    export enum WatcherChangeTypes {
      All = 15,
      Changed = 4,
      Created = 1,
      Deleted = 2,
      Renamed = 8,
    }
    export namespace Compression {
      export enum CompressionLevel {
        Optimal = 0,
        Fastest = 1,
        NoCompression = 2,
      }
      export enum CompressionMode {
        Decompress = 0,
        Compress = 1,
      }
      export class GZipStream {
        constructor(stream: System.IO.Stream, mode: System.IO.Compression.CompressionMode);
        constructor(stream: System.IO.Stream, mode: System.IO.Compression.CompressionMode, leaveOpen: boolean);
        constructor(stream: System.IO.Stream, compressionLevel: System.IO.Compression.CompressionLevel);
        constructor(stream: System.IO.Stream, compressionLevel: System.IO.Compression.CompressionLevel, leaveOpen: boolean);
        CanRead: boolean;
        CanWrite: boolean;
        CanSeek: boolean;
        Length: number;
        Position: number;
        BaseStream: System.IO.Stream;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        Flush(): void;
        Seek(offset: number, origin: System.IO.SeekOrigin): number;
        SetLength(value: number): void;
        ReadByte(): number;
        BeginRead(array: Byte[], offset: number, count: number, asyncCallback: ((ar: System.IAsyncResult) => void), asyncState: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        Read(array: Byte[], offset: number, count: number): number;
        Read(buffer: System.Span<Byte>): number;
        BeginWrite(array: Byte[], offset: number, count: number, asyncCallback: ((ar: System.IAsyncResult) => void), asyncState: any): System.IAsyncResult;
        EndWrite(asyncResult: System.IAsyncResult): void;
        Write(array: Byte[], offset: number, count: number): void;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        ReadAsync(array: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        WriteAsync(array: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        WriteByte(value: Byte): void;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DeflateStream {
        constructor(stream: System.IO.Stream, mode: System.IO.Compression.CompressionMode);
        constructor(stream: System.IO.Stream, mode: System.IO.Compression.CompressionMode, leaveOpen: boolean);
        constructor(stream: System.IO.Stream, compressionLevel: System.IO.Compression.CompressionLevel);
        constructor(stream: System.IO.Stream, compressionLevel: System.IO.Compression.CompressionLevel, leaveOpen: boolean);
        BaseStream: System.IO.Stream;
        CanRead: boolean;
        CanSeek: boolean;
        CanWrite: boolean;
        Length: number;
        Position: number;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        Read(array: Byte[], offset: number, count: number): number;
        Write(array: Byte[], offset: number, count: number): void;
        Flush(): void;
        BeginRead(array: Byte[], offset: number, count: number, asyncCallback: ((ar: System.IAsyncResult) => void), asyncState: any): System.IAsyncResult;
        BeginWrite(array: Byte[], offset: number, count: number, asyncCallback: ((ar: System.IAsyncResult) => void), asyncState: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        EndWrite(asyncResult: System.IAsyncResult): void;
        Seek(offset: number, origin: System.IO.SeekOrigin): number;
        SetLength(value: number): void;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        Read(buffer: System.Span<Byte>): number;
        ReadByte(): number;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        WriteByte(value: Byte): void;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace CoreFX {
      export class FileSystemWatcher {
        constructor();
        constructor(path: string);
        constructor(path: string, filter: string);
        NotifyFilter: System.IO.NotifyFilters;
        Filters: string[];
        EnableRaisingEvents: boolean;
        Filter: string;
        IncludeSubdirectories: boolean;
        InternalBufferSize: number;
        Path: string;
        Site: System.ComponentModel.ISite;
        SynchronizingObject: System.ComponentModel.ISynchronizeInvoke;
        Container: System.ComponentModel.IContainer;
        WaitForChanged(changeType: System.IO.WatcherChangeTypes): System.IO.WaitForChangedResult;
        WaitForChanged(changeType: System.IO.WatcherChangeTypes, timeout: number): System.IO.WaitForChangedResult;
        BeginInit(): void;
        EndInit(): void;
        Dispose(): void;
        ToString(): string;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
    }
    export namespace Enumeration {
      export class FileSystemEntry {
        Directory: System.ReadOnlySpan<System.Char>;
        RootDirectory: System.ReadOnlySpan<System.Char>;
        OriginalRootDirectory: System.ReadOnlySpan<System.Char>;
        FileName: System.ReadOnlySpan<System.Char>;
        Attributes: System.IO.FileAttributes;
        Length: number;
        CreationTimeUtc: System.DateTimeOffset;
        LastAccessTimeUtc: System.DateTimeOffset;
        LastWriteTimeUtc: System.DateTimeOffset;
        IsDirectory: boolean;
        IsHidden: boolean;
        ToFileSystemInfo(): System.IO.FileSystemInfo;
        ToFullPath(): string;
        ToSpecifiedFullPath(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class FileSystemEnumerable<TResult = any> {
        constructor(directory: string, transform: ((entry: Ref<System.IO.Enumeration.FileSystemEntry>) => TResult), options?: System.IO.EnumerationOptions);
        ShouldIncludePredicate: ((entry: Ref<System.IO.Enumeration.FileSystemEntry>) => boolean);
        ShouldRecursePredicate: ((entry: Ref<System.IO.Enumeration.FileSystemEntry>) => boolean);
        GetEnumerator(): System.Collections.Generic.IEnumerator<TResult>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FileSystemEnumerator<TResult = any> {
        constructor(directory: string, options?: System.IO.EnumerationOptions);
        Current: TResult;
        MoveNext(): boolean;
        Reset(): void;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FileSystemName {
        static TranslateWin32Expression(expression: string): string;
        static MatchesWin32Expression(expression: any, name: any, ignoreCase?: boolean): boolean;
        static MatchesSimpleExpression(expression: any, name: any, ignoreCase?: boolean): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace IsolatedStorage {
      export interface INormalizeForIsolatedStorage {
        Normalize(): any;
      }
      export enum IsolatedStorageScope {
        None = 0,
        User = 1,
        Domain = 2,
        Assembly = 4,
        Roaming = 8,
        Machine = 16,
        Application = 32,
      }
      export class IsolatedStorage {
        ApplicationIdentity: any; // System.Object
        AssemblyIdentity: any; // System.Object
        CurrentSize: number;
        DomainIdentity: any; // System.Object
        MaximumSize: number;
        Scope: System.IO.IsolatedStorage.IsolatedStorageScope;
        AvailableFreeSpace: number;
        Quota: number;
        UsedSize: number;
        Remove(): void;
        IncreaseQuotaTo(newQuotaSize: number): boolean;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsolatedStorageException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class IsolatedStorageFile {
        CurrentSize: number;
        MaximumSize: number;
        AvailableFreeSpace: number;
        Quota: number;
        UsedSize: number;
        static IsEnabled: boolean;
        ApplicationIdentity: any; // System.Object
        AssemblyIdentity: any; // System.Object
        DomainIdentity: any; // System.Object
        Scope: System.IO.IsolatedStorage.IsolatedStorageScope;
        static GetEnumerator(scope: System.IO.IsolatedStorage.IsolatedStorageScope): System.Collections.IEnumerator;
        static GetStore(scope: System.IO.IsolatedStorage.IsolatedStorageScope, domainEvidence: System.Security.Policy.Evidence, domainEvidenceType: System.Type, assemblyEvidence: System.Security.Policy.Evidence, assemblyEvidenceType: System.Type): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetStore(scope: System.IO.IsolatedStorage.IsolatedStorageScope, domainIdentity: any, assemblyIdentity: any): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetStore(scope: System.IO.IsolatedStorage.IsolatedStorageScope, domainEvidenceType: System.Type, assemblyEvidenceType: System.Type): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetStore(scope: System.IO.IsolatedStorage.IsolatedStorageScope, applicationIdentity: any): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetStore(scope: System.IO.IsolatedStorage.IsolatedStorageScope, applicationEvidenceType: System.Type): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetMachineStoreForApplication(): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetMachineStoreForAssembly(): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetMachineStoreForDomain(): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetUserStoreForApplication(): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetUserStoreForAssembly(): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetUserStoreForDomain(): System.IO.IsolatedStorage.IsolatedStorageFile;
        static GetUserStoreForSite(): System.IO.IsolatedStorage.IsolatedStorageFile;
        static Remove(scope: System.IO.IsolatedStorage.IsolatedStorageScope): void;
        Close(): void;
        CreateDirectory(dir: string): void;
        CopyFile(sourceFileName: string, destinationFileName: string): void;
        CopyFile(sourceFileName: string, destinationFileName: string, overwrite: boolean): void;
        CreateFile(path: string): System.IO.IsolatedStorage.IsolatedStorageFileStream;
        DeleteDirectory(dir: string): void;
        DeleteFile(file: string): void;
        Dispose(): void;
        DirectoryExists(path: string): boolean;
        FileExists(path: string): boolean;
        GetCreationTime(path: string): System.DateTimeOffset;
        GetLastAccessTime(path: string): System.DateTimeOffset;
        GetLastWriteTime(path: string): System.DateTimeOffset;
        GetDirectoryNames(searchPattern: string): string[];
        GetDirectoryNames(): string[];
        GetFileNames(searchPattern: string): string[];
        GetFileNames(): string[];
        IncreaseQuotaTo(newQuotaSize: number): boolean;
        MoveDirectory(sourceDirectoryName: string, destinationDirectoryName: string): void;
        MoveFile(sourceFileName: string, destinationFileName: string): void;
        OpenFile(path: string, mode: System.IO.FileMode): System.IO.IsolatedStorage.IsolatedStorageFileStream;
        OpenFile(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess): System.IO.IsolatedStorage.IsolatedStorageFileStream;
        OpenFile(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare): System.IO.IsolatedStorage.IsolatedStorageFileStream;
        Remove(): void;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsolatedStorageFileStream {
        constructor(path: string, mode: System.IO.FileMode);
        constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess);
        constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare);
        constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare, bufferSize: number);
        constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare, bufferSize: number, isf: System.IO.IsolatedStorage.IsolatedStorageFile);
        constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare, isf: System.IO.IsolatedStorage.IsolatedStorageFile);
        constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, isf: System.IO.IsolatedStorage.IsolatedStorageFile);
        constructor(path: string, mode: System.IO.FileMode, isf: System.IO.IsolatedStorage.IsolatedStorageFile);
        CanRead: boolean;
        CanSeek: boolean;
        CanWrite: boolean;
        SafeFileHandle: any; // Microsoft.Win32.SafeHandles.SafeFileHandle
        Handle: System.IntPtr;
        IsAsync: boolean;
        Length: number;
        Position: number;
        Name: string;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        BeginRead(buffer: Byte[], offset: number, numBytes: number, userCallback: ((ar: System.IAsyncResult) => void), stateObject: any): System.IAsyncResult;
        BeginWrite(buffer: Byte[], offset: number, numBytes: number, userCallback: ((ar: System.IAsyncResult) => void), stateObject: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        EndWrite(asyncResult: System.IAsyncResult): void;
        Flush(): void;
        Flush(flushToDisk: boolean): void;
        Read(buffer: Byte[], offset: number, count: number): number;
        ReadByte(): number;
        Seek(offset: number, origin: System.IO.SeekOrigin): number;
        SetLength(value: number): void;
        Write(buffer: Byte[], offset: number, count: number): void;
        WriteByte(value: Byte): void;
        Lock(position: number, length: number): void;
        Unlock(position: number, length: number): void;
        GetAccessControl(): System.Security.AccessControl.FileSecurity;
        SetAccessControl(fileSecurity: System.Security.AccessControl.FileSecurity): void;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        Read(buffer: System.Span<Byte>): number;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum IsolatedStorageSecurityOptions {
        IncreaseQuotaForApplication = 4,
      }
      export class IsolatedStorageSecurityState {
        Options: System.IO.IsolatedStorage.IsolatedStorageSecurityOptions;
        Quota: number;
        UsedSize: number;
        EnsureState(): void;
        IsStateAvailable(): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace MemoryMappedFiles {
      export enum MemoryMappedFileAccess {
        ReadWrite = 0,
        Read = 1,
        Write = 2,
        CopyOnWrite = 3,
        ReadExecute = 4,
        ReadWriteExecute = 5,
      }
      export enum MemoryMappedFileOptions {
        None = 0,
        DelayAllocatePages = 67108864,
      }
      export enum MemoryMappedFileRights {
        CopyOnWrite = 1,
        Write = 2,
        Read = 4,
        Execute = 8,
        Delete = 65536,
        ReadPermissions = 131072,
        ChangePermissions = 262144,
        TakeOwnership = 524288,
        ReadWrite = 6,
        ReadExecute = 12,
        ReadWriteExecute = 14,
        FullControl = 983055,
        AccessSystemSecurity = 16777216,
      }
      export class MemoryMappedFileSecurity {
        constructor();
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AddAccessRule(rule: System.Security.AccessControl.AccessRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): void;
        RemoveAccessRule(rule: System.Security.AccessControl.AccessRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.AccessRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.AccessRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): void;
        ResetAccessRule(rule: System.Security.AccessControl.AccessRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): void;
        SetAccessRule(rule: System.Security.AccessControl.AccessRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): void;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAuditRule(rule: System.Security.AccessControl.AuditRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): void;
        RemoveAuditRule(rule: System.Security.AccessControl.AuditRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.AuditRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.AuditRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): void;
        SetAuditRule(rule: System.Security.AccessControl.AuditRule<System.IO.MemoryMappedFiles.MemoryMappedFileRights>): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MemoryMappedViewAccessor {
        SafeMemoryMappedViewHandle: any; // Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle
        PointerOffset: number;
        Capacity: number;
        CanRead: boolean;
        CanWrite: boolean;
        Flush(): void;
        Dispose(): void;
        ReadBoolean(position: number): boolean;
        ReadByte(position: number): Byte;
        ReadChar(position: number): System.Char;
        ReadInt16(position: number): number;
        ReadInt32(position: number): number;
        ReadInt64(position: number): number;
        ReadDecimal(position: number): number;
        ReadSingle(position: number): number;
        ReadDouble(position: number): number;
        ReadSByte(position: number): System.SByte;
        ReadUInt16(position: number): number;
        ReadUInt32(position: number): number;
        ReadUInt64(position: number): number;
        Write(position: number, value: boolean): void;
        Write(position: number, value: Byte): void;
        Write(position: number, value: System.Char): void;
        Write(position: number, value: number): void;
        Write(position: number, value: number): void;
        Write(position: number, value: number): void;
        Write(position: number, value: number): void;
        Write(position: number, value: number): void;
        Write(position: number, value: number): void;
        Write(position: number, value: System.SByte): void;
        Write(position: number, value: number): void;
        Write(position: number, value: number): void;
        Write(position: number, value: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MemoryMappedViewStream {
        SafeMemoryMappedViewHandle: any; // Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle
        PointerOffset: number;
        CanRead: boolean;
        CanSeek: boolean;
        CanWrite: boolean;
        Length: number;
        Capacity: number;
        Position: number;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        SetLength(value: number): void;
        Flush(): void;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        Read(buffer: Byte[], offset: number, count: number): number;
        Read(buffer: System.Span<Byte>): number;
        ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        ReadByte(): number;
        Seek(offset: number, loc: System.IO.SeekOrigin): number;
        Write(buffer: Byte[], offset: number, count: number): void;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        WriteByte(value: Byte): void;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndWrite(asyncResult: System.IAsyncResult): void;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MemoryMappedFile {
        SafeMemoryMappedFileHandle: any; // Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle
        static CreateFromFile(path: string): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateFromFile(path: string, mode: System.IO.FileMode): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateFromFile(path: string, mode: System.IO.FileMode, mapName: string): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateFromFile(path: string, mode: System.IO.FileMode, mapName: string, capacity: number): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateFromFile(path: string, mode: System.IO.FileMode, mapName: string, capacity: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateFromFile(fileStream: System.IO.FileStream, mapName: string, capacity: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess, inheritability: System.IO.HandleInheritability, leaveOpen: boolean): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateFromFile(fileStream: System.IO.FileStream, mapName: string, capacity: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess, memoryMappedFileSecurity: System.IO.MemoryMappedFiles.MemoryMappedFileSecurity, inheritability: System.IO.HandleInheritability, leaveOpen: boolean): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateNew(mapName: string, capacity: number): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateNew(mapName: string, capacity: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateNew(mapName: string, capacity: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess, options: System.IO.MemoryMappedFiles.MemoryMappedFileOptions, inheritability: System.IO.HandleInheritability): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateNew(mapName: string, capacity: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess, options: System.IO.MemoryMappedFiles.MemoryMappedFileOptions, memoryMappedFileSecurity: System.IO.MemoryMappedFiles.MemoryMappedFileSecurity, inheritability: System.IO.HandleInheritability): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateOrOpen(mapName: string, capacity: number): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateOrOpen(mapName: string, capacity: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateOrOpen(mapName: string, capacity: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess, options: System.IO.MemoryMappedFiles.MemoryMappedFileOptions, inheritability: System.IO.HandleInheritability): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static CreateOrOpen(mapName: string, capacity: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess, options: System.IO.MemoryMappedFiles.MemoryMappedFileOptions, memoryMappedFileSecurity: System.IO.MemoryMappedFiles.MemoryMappedFileSecurity, inheritability: System.IO.HandleInheritability): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static OpenExisting(mapName: string): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static OpenExisting(mapName: string, desiredAccessRights: System.IO.MemoryMappedFiles.MemoryMappedFileRights): System.IO.MemoryMappedFiles.MemoryMappedFile;
        static OpenExisting(mapName: string, desiredAccessRights: System.IO.MemoryMappedFiles.MemoryMappedFileRights, inheritability: System.IO.HandleInheritability): System.IO.MemoryMappedFiles.MemoryMappedFile;
        CreateViewStream(): System.IO.MemoryMappedFiles.MemoryMappedViewStream;
        CreateViewStream(offset: number, size: number): System.IO.MemoryMappedFiles.MemoryMappedViewStream;
        CreateViewStream(offset: number, size: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess): System.IO.MemoryMappedFiles.MemoryMappedViewStream;
        CreateViewAccessor(): System.IO.MemoryMappedFiles.MemoryMappedViewAccessor;
        CreateViewAccessor(offset: number, size: number): System.IO.MemoryMappedFiles.MemoryMappedViewAccessor;
        CreateViewAccessor(offset: number, size: number, access: System.IO.MemoryMappedFiles.MemoryMappedFileAccess): System.IO.MemoryMappedFiles.MemoryMappedViewAccessor;
        Dispose(): void;
        GetAccessControl(): System.IO.MemoryMappedFiles.MemoryMappedFileSecurity;
        SetAccessControl(memoryMappedFileSecurity: System.IO.MemoryMappedFiles.MemoryMappedFileSecurity): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace Pipes {
      export class AnonymousPipeClientStream {
        constructor(pipeHandleAsString: string);
        constructor(direction: System.IO.Pipes.PipeDirection, pipeHandleAsString: string);
        constructor(direction: System.IO.Pipes.PipeDirection, safePipeHandle: any);
        TransmissionMode: System.IO.Pipes.PipeTransmissionMode;
        ReadMode: System.IO.Pipes.PipeTransmissionMode;
        InBufferSize: number;
        OutBufferSize: number;
        IsConnected: boolean;
        IsAsync: boolean;
        IsMessageComplete: boolean;
        SafePipeHandle: any; // Microsoft.Win32.SafeHandles.SafePipeHandle
        CanRead: boolean;
        CanWrite: boolean;
        CanSeek: boolean;
        Length: number;
        Position: number;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        WaitForPipeDrain(): void;
        Read(buffer: Byte[], offset: number, count: number): number;
        Read(buffer: System.Span<Byte>): number;
        ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        Write(buffer: Byte[], offset: number, count: number): void;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndWrite(asyncResult: System.IAsyncResult): void;
        ReadByte(): number;
        WriteByte(value: Byte): void;
        Flush(): void;
        SetLength(value: number): void;
        Seek(offset: number, origin: System.IO.SeekOrigin): number;
        GetAccessControl(): System.IO.Pipes.PipeSecurity;
        SetAccessControl(pipeSecurity: System.IO.Pipes.PipeSecurity): void;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AnonymousPipeServerStream {
        constructor();
        constructor(direction: System.IO.Pipes.PipeDirection);
        constructor(direction: System.IO.Pipes.PipeDirection, inheritability: System.IO.HandleInheritability);
        constructor(direction: System.IO.Pipes.PipeDirection, serverSafePipeHandle: any, clientSafePipeHandle: any);
        constructor(direction: System.IO.Pipes.PipeDirection, inheritability: System.IO.HandleInheritability, bufferSize: number);
        constructor(direction: System.IO.Pipes.PipeDirection, inheritability: System.IO.HandleInheritability, bufferSize: number, pipeSecurity: System.IO.Pipes.PipeSecurity);
        ClientSafePipeHandle: any; // Microsoft.Win32.SafeHandles.SafePipeHandle
        TransmissionMode: System.IO.Pipes.PipeTransmissionMode;
        ReadMode: System.IO.Pipes.PipeTransmissionMode;
        InBufferSize: number;
        OutBufferSize: number;
        IsConnected: boolean;
        IsAsync: boolean;
        IsMessageComplete: boolean;
        SafePipeHandle: any; // Microsoft.Win32.SafeHandles.SafePipeHandle
        CanRead: boolean;
        CanWrite: boolean;
        CanSeek: boolean;
        Length: number;
        Position: number;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        GetClientHandleAsString(): string;
        DisposeLocalCopyOfClientHandle(): void;
        WaitForPipeDrain(): void;
        Read(buffer: Byte[], offset: number, count: number): number;
        Read(buffer: System.Span<Byte>): number;
        ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        Write(buffer: Byte[], offset: number, count: number): void;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndWrite(asyncResult: System.IAsyncResult): void;
        ReadByte(): number;
        WriteByte(value: Byte): void;
        Flush(): void;
        SetLength(value: number): void;
        Seek(offset: number, origin: System.IO.SeekOrigin): number;
        GetAccessControl(): System.IO.Pipes.PipeSecurity;
        SetAccessControl(pipeSecurity: System.IO.Pipes.PipeSecurity): void;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class NamedPipeClientStream {
        constructor(pipeName: string);
        constructor(serverName: string, pipeName: string);
        constructor(serverName: string, pipeName: string, direction: System.IO.Pipes.PipeDirection);
        constructor(serverName: string, pipeName: string, direction: System.IO.Pipes.PipeDirection, options: System.IO.Pipes.PipeOptions);
        constructor(serverName: string, pipeName: string, direction: System.IO.Pipes.PipeDirection, options: System.IO.Pipes.PipeOptions, impersonationLevel: System.Security.Principal.TokenImpersonationLevel);
        constructor(serverName: string, pipeName: string, direction: System.IO.Pipes.PipeDirection, options: System.IO.Pipes.PipeOptions, impersonationLevel: System.Security.Principal.TokenImpersonationLevel, inheritability: System.IO.HandleInheritability);
        constructor(direction: System.IO.Pipes.PipeDirection, isAsync: boolean, isConnected: boolean, safePipeHandle: any);
        constructor(serverName: string, pipeName: string, desiredAccessRights: System.IO.Pipes.PipeAccessRights, options: System.IO.Pipes.PipeOptions, impersonationLevel: System.Security.Principal.TokenImpersonationLevel, inheritability: System.IO.HandleInheritability);
        NumberOfServerInstances: number;
        TransmissionMode: System.IO.Pipes.PipeTransmissionMode;
        InBufferSize: number;
        OutBufferSize: number;
        ReadMode: System.IO.Pipes.PipeTransmissionMode;
        IsConnected: boolean;
        IsAsync: boolean;
        IsMessageComplete: boolean;
        SafePipeHandle: any; // Microsoft.Win32.SafeHandles.SafePipeHandle
        CanRead: boolean;
        CanWrite: boolean;
        CanSeek: boolean;
        Length: number;
        Position: number;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        Connect(): void;
        Connect(timeout: number): void;
        ConnectAsync(): System.Threading.Tasks.Task;
        ConnectAsync(timeout: number): System.Threading.Tasks.Task;
        ConnectAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ConnectAsync(timeout: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WaitForPipeDrain(): void;
        Read(buffer: Byte[], offset: number, count: number): number;
        Read(buffer: System.Span<Byte>): number;
        ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        Write(buffer: Byte[], offset: number, count: number): void;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndWrite(asyncResult: System.IAsyncResult): void;
        ReadByte(): number;
        WriteByte(value: Byte): void;
        Flush(): void;
        SetLength(value: number): void;
        Seek(offset: number, origin: System.IO.SeekOrigin): number;
        GetAccessControl(): System.IO.Pipes.PipeSecurity;
        SetAccessControl(pipeSecurity: System.IO.Pipes.PipeSecurity): void;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class NamedPipeServerStream {
        constructor(pipeName: string);
        constructor(pipeName: string, direction: System.IO.Pipes.PipeDirection);
        constructor(pipeName: string, direction: System.IO.Pipes.PipeDirection, maxNumberOfServerInstances: number);
        constructor(pipeName: string, direction: System.IO.Pipes.PipeDirection, maxNumberOfServerInstances: number, transmissionMode: System.IO.Pipes.PipeTransmissionMode);
        constructor(pipeName: string, direction: System.IO.Pipes.PipeDirection, maxNumberOfServerInstances: number, transmissionMode: System.IO.Pipes.PipeTransmissionMode, options: System.IO.Pipes.PipeOptions);
        constructor(pipeName: string, direction: System.IO.Pipes.PipeDirection, maxNumberOfServerInstances: number, transmissionMode: System.IO.Pipes.PipeTransmissionMode, options: System.IO.Pipes.PipeOptions, inBufferSize: number, outBufferSize: number);
        constructor(direction: System.IO.Pipes.PipeDirection, isAsync: boolean, isConnected: boolean, safePipeHandle: any);
        constructor(pipeName: string, direction: System.IO.Pipes.PipeDirection, maxNumberOfServerInstances: number, transmissionMode: System.IO.Pipes.PipeTransmissionMode, options: System.IO.Pipes.PipeOptions, inBufferSize: number, outBufferSize: number, pipeSecurity: System.IO.Pipes.PipeSecurity);
        constructor(pipeName: string, direction: System.IO.Pipes.PipeDirection, maxNumberOfServerInstances: number, transmissionMode: System.IO.Pipes.PipeTransmissionMode, options: System.IO.Pipes.PipeOptions, inBufferSize: number, outBufferSize: number, pipeSecurity: System.IO.Pipes.PipeSecurity, inheritability: System.IO.HandleInheritability);
        constructor(pipeName: string, direction: System.IO.Pipes.PipeDirection, maxNumberOfServerInstances: number, transmissionMode: System.IO.Pipes.PipeTransmissionMode, options: System.IO.Pipes.PipeOptions, inBufferSize: number, outBufferSize: number, pipeSecurity: System.IO.Pipes.PipeSecurity, inheritability: System.IO.HandleInheritability, additionalAccessRights: System.IO.Pipes.PipeAccessRights);
        TransmissionMode: System.IO.Pipes.PipeTransmissionMode;
        InBufferSize: number;
        OutBufferSize: number;
        ReadMode: System.IO.Pipes.PipeTransmissionMode;
        IsConnected: boolean;
        IsAsync: boolean;
        IsMessageComplete: boolean;
        SafePipeHandle: any; // Microsoft.Win32.SafeHandles.SafePipeHandle
        CanRead: boolean;
        CanWrite: boolean;
        CanSeek: boolean;
        Length: number;
        Position: number;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        static MaxAllowedServerInstances: number;
        WaitForConnection(): void;
        WaitForConnectionAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        Disconnect(): void;
        GetImpersonationUserName(): string;
        RunAsClient(impersonationWorker: (() => void)): void;
        WaitForConnectionAsync(): System.Threading.Tasks.Task;
        BeginWaitForConnection(callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndWaitForConnection(asyncResult: System.IAsyncResult): void;
        WaitForPipeDrain(): void;
        Read(buffer: Byte[], offset: number, count: number): number;
        Read(buffer: System.Span<Byte>): number;
        ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        Write(buffer: Byte[], offset: number, count: number): void;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndWrite(asyncResult: System.IAsyncResult): void;
        ReadByte(): number;
        WriteByte(value: Byte): void;
        Flush(): void;
        SetLength(value: number): void;
        Seek(offset: number, origin: System.IO.SeekOrigin): number;
        GetAccessControl(): System.IO.Pipes.PipeSecurity;
        SetAccessControl(pipeSecurity: System.IO.Pipes.PipeSecurity): void;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class PipeStreamImpersonationWorker {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(): void;
        BeginInvoke(callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum PipeAccessRights {
        ReadData = 1,
        WriteData = 2,
        ReadAttributes = 128,
        WriteAttributes = 256,
        ReadExtendedAttributes = 8,
        WriteExtendedAttributes = 16,
        CreateNewInstance = 4,
        Delete = 65536,
        ReadPermissions = 131072,
        ChangePermissions = 262144,
        TakeOwnership = 524288,
        Synchronize = 1048576,
        FullControl = 2032031,
        Read = 131209,
        Write = 274,
        ReadWrite = 131483,
        AccessSystemSecurity = 16777216,
      }
      export class PipeAccessRule {
        constructor(identity: string, rights: System.IO.Pipes.PipeAccessRights, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: System.Security.Principal.IdentityReference, rights: System.IO.Pipes.PipeAccessRights, type: System.Security.AccessControl.AccessControlType);
        PipeAccessRights: System.IO.Pipes.PipeAccessRights;
        AccessControlType: System.Security.AccessControl.AccessControlType;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class PipeAuditRule {
        constructor(identity: System.Security.Principal.IdentityReference, rights: System.IO.Pipes.PipeAccessRights, flags: System.Security.AccessControl.AuditFlags);
        constructor(identity: string, rights: System.IO.Pipes.PipeAccessRights, flags: System.Security.AccessControl.AuditFlags);
        PipeAccessRights: System.IO.Pipes.PipeAccessRights;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum PipeDirection {
        In = 1,
        Out = 2,
        InOut = 3,
      }
      export enum PipeOptions {
        None = 0,
        WriteThrough = -2147483648,
        Asynchronous = 1073741824,
        CurrentUserOnly = 536870912,
      }
      export class PipeSecurity {
        constructor();
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AddAccessRule(rule: System.IO.Pipes.PipeAccessRule): void;
        SetAccessRule(rule: System.IO.Pipes.PipeAccessRule): void;
        ResetAccessRule(rule: System.IO.Pipes.PipeAccessRule): void;
        RemoveAccessRule(rule: System.IO.Pipes.PipeAccessRule): boolean;
        RemoveAccessRuleSpecific(rule: System.IO.Pipes.PipeAccessRule): void;
        AddAuditRule(rule: System.IO.Pipes.PipeAuditRule): void;
        SetAuditRule(rule: System.IO.Pipes.PipeAuditRule): void;
        RemoveAuditRule(rule: System.IO.Pipes.PipeAuditRule): boolean;
        RemoveAuditRuleAll(rule: System.IO.Pipes.PipeAuditRule): void;
        RemoveAuditRuleSpecific(rule: System.IO.Pipes.PipeAuditRule): void;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class PipeStream {
        TransmissionMode: System.IO.Pipes.PipeTransmissionMode;
        InBufferSize: number;
        OutBufferSize: number;
        ReadMode: System.IO.Pipes.PipeTransmissionMode;
        IsConnected: boolean;
        IsAsync: boolean;
        IsMessageComplete: boolean;
        SafePipeHandle: any; // Microsoft.Win32.SafeHandles.SafePipeHandle
        CanRead: boolean;
        CanWrite: boolean;
        CanSeek: boolean;
        Length: number;
        Position: number;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        WaitForPipeDrain(): void;
        Read(buffer: Byte[], offset: number, count: number): number;
        Read(buffer: System.Span<Byte>): number;
        ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        Write(buffer: Byte[], offset: number, count: number): void;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndWrite(asyncResult: System.IAsyncResult): void;
        ReadByte(): number;
        WriteByte(value: Byte): void;
        Flush(): void;
        SetLength(value: number): void;
        Seek(offset: number, origin: System.IO.SeekOrigin): number;
        GetAccessControl(): System.IO.Pipes.PipeSecurity;
        SetAccessControl(pipeSecurity: System.IO.Pipes.PipeSecurity): void;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum PipeTransmissionMode {
        Byte = 0,
        Message = 1,
      }
    }
    export namespace Ports {
      export enum Handshake {
        None = 0,
        XOnXOff = 1,
        RequestToSend = 2,
        RequestToSendXOnXOff = 3,
      }
      export enum Parity {
        None = 0,
        Odd = 1,
        Even = 2,
        Mark = 3,
        Space = 4,
      }
      export enum SerialData {
        Chars = 1,
        Eof = 2,
      }
      export enum SerialError {
        RXOver = 1,
        Overrun = 2,
        RXParity = 4,
        Frame = 8,
        TXFull = 256,
      }
      export class SerialErrorReceivedEventArgs {
        EventType: System.IO.Ports.SerialError;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum SerialPinChange {
        CtsChanged = 8,
        DsrChanged = 16,
        CDChanged = 32,
        Break = 64,
        Ring = 256,
      }
      export class SerialPinChangedEventArgs {
        EventType: System.IO.Ports.SerialPinChange;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SerialPort {
        constructor();
        constructor(container: System.ComponentModel.IContainer);
        constructor(portName: string);
        constructor(portName: string, baudRate: number);
        constructor(portName: string, baudRate: number, parity: System.IO.Ports.Parity);
        constructor(portName: string, baudRate: number, parity: System.IO.Ports.Parity, dataBits: number);
        constructor(portName: string, baudRate: number, parity: System.IO.Ports.Parity, dataBits: number, stopBits: System.IO.Ports.StopBits);
        BaseStream: System.IO.Stream;
        BaudRate: number;
        BreakState: boolean;
        BytesToRead: number;
        BytesToWrite: number;
        CDHolding: boolean;
        CtsHolding: boolean;
        DataBits: number;
        DiscardNull: boolean;
        DsrHolding: boolean;
        DtrEnable: boolean;
        Encoding: System.Text.Encoding;
        Handshake: System.IO.Ports.Handshake;
        IsOpen: boolean;
        NewLine: string;
        Parity: System.IO.Ports.Parity;
        ParityReplace: Byte;
        PortName: string;
        ReadBufferSize: number;
        ReadTimeout: number;
        ReceivedBytesThreshold: number;
        RtsEnable: boolean;
        StopBits: System.IO.Ports.StopBits;
        WriteBufferSize: number;
        WriteTimeout: number;
        Site: System.ComponentModel.ISite;
        Container: System.ComponentModel.IContainer;
        static InfiniteTimeout: number;
        Close(): void;
        DiscardInBuffer(): void;
        DiscardOutBuffer(): void;
        static GetPortNames(): string[];
        Open(): void;
        Read(buffer: Byte[], offset: number, count: number): number;
        Read(buffer: System.Char[], offset: number, count: number): number;
        ReadByte(): number;
        ReadChar(): number;
        ReadExisting(): string;
        ReadLine(): string;
        ReadTo(value: string): string;
        Write(text: string): void;
        Write(buffer: Byte[], offset: number, count: number): void;
        Write(buffer: System.Char[], offset: number, count: number): void;
        WriteLine(text: string): void;
        Dispose(): void;
        ToString(): string;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class SerialDataReceivedEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.IO.Ports.SerialDataReceivedEventArgs): void;
        BeginInvoke(sender: any, e: System.IO.Ports.SerialDataReceivedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SerialPinChangedEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.IO.Ports.SerialPinChangedEventArgs): void;
        BeginInvoke(sender: any, e: System.IO.Ports.SerialPinChangedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SerialErrorReceivedEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(sender: any, e: System.IO.Ports.SerialErrorReceivedEventArgs): void;
        BeginInvoke(sender: any, e: System.IO.Ports.SerialErrorReceivedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SerialDataReceivedEventArgs {
        EventType: System.IO.Ports.SerialData;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum StopBits {
        None = 0,
        One = 1,
        Two = 2,
        OnePointFive = 3,
      }
    }
  }
  export namespace Linq {
    export interface IQueryable<T = any> {
    }
    export interface IQueryProvider {
      CreateQuery(expression: System.Linq.Expressions.Expression): System.Linq.IQueryable;
      Execute(expression: System.Linq.Expressions.Expression): any;
    }
    export interface IOrderedQueryable<T = any> {
    }
    export class OrderedParallelQuery<TSource = any> {
      GetEnumerator(): System.Collections.Generic.IEnumerator<TSource>;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ParallelQuery<TSource = any> {
      GetEnumerator(): System.Collections.Generic.IEnumerator<TSource>;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ParallelEnumerable {
      static AsOrdered(source: System.Linq.ParallelQuery): System.Linq.ParallelQuery;
      static AsParallel(source: System.Collections.IEnumerable): System.Linq.ParallelQuery;
      static Range(start: number, count: number): any;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum ParallelExecutionMode {
      Default = 0,
      ForceParallelism = 1,
    }
    export enum ParallelMergeOptions {
      Default = 0,
      NotBuffered = 1,
      AutoBuffered = 2,
      FullyBuffered = 3,
    }
    export class EnumerableExecutor<T = any> {
      constructor(expression: System.Linq.Expressions.Expression);
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EnumerableQuery<T = any> {
      constructor(enumerable: System.Collections.Generic.IEnumerable<T>);
      constructor(expression: System.Linq.Expressions.Expression);
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class Queryable {
      static AsQueryable(source: System.Collections.IEnumerable): System.Linq.IQueryable;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Enumerable {
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Average(source: any): number;
      static Average(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Max(source: any): number;
      static Max(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Min(source: any): number;
      static Min(source: any): number | undefined;
      static Range(start: number, count: number): any;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      static Sum(source: any): number;
      static Sum(source: any): number | undefined;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IGrouping<TKey = any, TElement = any> {
      Key: TKey;
    }
    export interface ILookup<TKey = any, TElement = any> {
      Count: number;
      Contains(key: TKey): boolean;
    }
    export class Lookup<TKey = any, TElement = any> {
      Count: number;
      Contains(key: TKey): boolean;
      GetEnumerator(): System.Collections.Generic.IEnumerator<System.Linq.IGrouping<TKey, TElement>>;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface IOrderedEnumerable<TElement = any> {
    }
    export namespace Expressions {
      export class BinaryExpression {
        CanReduce: boolean;
        Right: System.Linq.Expressions.Expression;
        Left: System.Linq.Expressions.Expression;
        Method: System.Reflection.MethodInfo;
        Conversion: System.Linq.Expressions.LambdaExpression;
        IsLifted: boolean;
        IsLiftedToNull: boolean;
        NodeType: System.Linq.Expressions.ExpressionType;
        Type: System.Type;
        Update(left: System.Linq.Expressions.Expression, conversion: System.Linq.Expressions.LambdaExpression, right: System.Linq.Expressions.Expression): System.Linq.Expressions.BinaryExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class Expression<TDelegate = any> {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Parameters: System.Linq.Expressions.ParameterExpression[];
        Name: string;
        Body: System.Linq.Expressions.Expression;
        ReturnType: System.Type;
        TailCall: boolean;
        CanReduce: boolean;
        Compile(): TDelegate;
        Compile(preferInterpretation: boolean): TDelegate;
        Update(body: System.Linq.Expressions.Expression, parameters: System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>): System.Linq.Expressions.Expression<TDelegate>;
        Compile(debugInfoGenerator: System.Runtime.CompilerServices.DebugInfoGenerator): TDelegate;
        Compile(): System.Delegate;
        Compile(preferInterpretation: boolean): System.Delegate;
        CompileToMethod(method: System.Reflection.Emit.MethodBuilder): void;
        Compile(debugInfoGenerator: System.Runtime.CompilerServices.DebugInfoGenerator): System.Delegate;
        CompileToMethod(method: System.Reflection.Emit.MethodBuilder, debugInfoGenerator: System.Runtime.CompilerServices.DebugInfoGenerator): void;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class BlockExpression {
        Expressions: System.Linq.Expressions.Expression[];
        Variables: System.Linq.Expressions.ParameterExpression[];
        Result: System.Linq.Expressions.Expression;
        NodeType: System.Linq.Expressions.ExpressionType;
        Type: System.Type;
        CanReduce: boolean;
        Update(variables: System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>, expressions: System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>): System.Linq.Expressions.BlockExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class CatchBlock {
        Variable: System.Linq.Expressions.ParameterExpression;
        Test: System.Type;
        Body: System.Linq.Expressions.Expression;
        Filter: System.Linq.Expressions.Expression;
        ToString(): string;
        Update(variable: System.Linq.Expressions.ParameterExpression, filter: System.Linq.Expressions.Expression, body: System.Linq.Expressions.Expression): System.Linq.Expressions.CatchBlock;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class ConditionalExpression {
        NodeType: System.Linq.Expressions.ExpressionType;
        Type: System.Type;
        Test: System.Linq.Expressions.Expression;
        IfTrue: System.Linq.Expressions.Expression;
        IfFalse: System.Linq.Expressions.Expression;
        CanReduce: boolean;
        Update(test: System.Linq.Expressions.Expression, ifTrue: System.Linq.Expressions.Expression, ifFalse: System.Linq.Expressions.Expression): System.Linq.Expressions.ConditionalExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class ConstantExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Value: any; // System.Object
        CanReduce: boolean;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class DebugInfoExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        StartLine: number;
        StartColumn: number;
        EndLine: number;
        EndColumn: number;
        Document: System.Linq.Expressions.SymbolDocumentInfo;
        IsClear: boolean;
        CanReduce: boolean;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class DefaultExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        CanReduce: boolean;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class DynamicExpression {
        CanReduce: boolean;
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Binder: System.Runtime.CompilerServices.CallSiteBinder;
        DelegateType: System.Type;
        Arguments: System.Linq.Expressions.Expression[];
        Reduce(): System.Linq.Expressions.Expression;
        Update(argumentsCS: System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>): System.Linq.Expressions.DynamicExpression;
        static Dynamic(binder: System.Runtime.CompilerServices.CallSiteBinder, returnType: System.Type, ...argumentsCS: System.Linq.Expressions.Expression[]): System.Linq.Expressions.DynamicExpression;
        static Dynamic(binder: System.Runtime.CompilerServices.CallSiteBinder, returnType: System.Type, argumentsCS: any): System.Linq.Expressions.DynamicExpression;
        static Dynamic(binder: System.Runtime.CompilerServices.CallSiteBinder, returnType: System.Type, arg0: System.Linq.Expressions.Expression): System.Linq.Expressions.DynamicExpression;
        static Dynamic(binder: System.Runtime.CompilerServices.CallSiteBinder, returnType: System.Type, arg0: System.Linq.Expressions.Expression, arg1: System.Linq.Expressions.Expression): System.Linq.Expressions.DynamicExpression;
        static Dynamic(binder: System.Runtime.CompilerServices.CallSiteBinder, returnType: System.Type, arg0: System.Linq.Expressions.Expression, arg1: System.Linq.Expressions.Expression, arg2: System.Linq.Expressions.Expression): System.Linq.Expressions.DynamicExpression;
        static Dynamic(binder: System.Runtime.CompilerServices.CallSiteBinder, returnType: System.Type, arg0: System.Linq.Expressions.Expression, arg1: System.Linq.Expressions.Expression, arg2: System.Linq.Expressions.Expression, arg3: System.Linq.Expressions.Expression): System.Linq.Expressions.DynamicExpression;
        static MakeDynamic(delegateType: System.Type, binder: System.Runtime.CompilerServices.CallSiteBinder, argumentsCS: any): System.Linq.Expressions.DynamicExpression;
        static MakeDynamic(delegateType: System.Type, binder: System.Runtime.CompilerServices.CallSiteBinder, ...argumentsCS: System.Linq.Expressions.Expression[]): System.Linq.Expressions.DynamicExpression;
        static MakeDynamic(delegateType: System.Type, binder: System.Runtime.CompilerServices.CallSiteBinder, arg0: System.Linq.Expressions.Expression): System.Linq.Expressions.DynamicExpression;
        static MakeDynamic(delegateType: System.Type, binder: System.Runtime.CompilerServices.CallSiteBinder, arg0: System.Linq.Expressions.Expression, arg1: System.Linq.Expressions.Expression): System.Linq.Expressions.DynamicExpression;
        static MakeDynamic(delegateType: System.Type, binder: System.Runtime.CompilerServices.CallSiteBinder, arg0: System.Linq.Expressions.Expression, arg1: System.Linq.Expressions.Expression, arg2: System.Linq.Expressions.Expression): System.Linq.Expressions.DynamicExpression;
        static MakeDynamic(delegateType: System.Type, binder: System.Runtime.CompilerServices.CallSiteBinder, arg0: System.Linq.Expressions.Expression, arg1: System.Linq.Expressions.Expression, arg2: System.Linq.Expressions.Expression, arg3: System.Linq.Expressions.Expression): System.Linq.Expressions.DynamicExpression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class DynamicExpressionVisitor {
        constructor();
        Visit(node: System.Linq.Expressions.Expression): System.Linq.Expressions.Expression;
        Visit(nodes: System.Linq.Expressions.Expression[]): System.Linq.Expressions.Expression[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ElementInit {
        AddMethod: System.Reflection.MethodInfo;
        Arguments: System.Linq.Expressions.Expression[];
        ArgumentCount: number;
        GetArgument(index: number): System.Linq.Expressions.Expression;
        ToString(): string;
        Update(argumentsCS: System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>): System.Linq.Expressions.ElementInit;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum ExpressionType {
        Add = 0,
        AddChecked = 1,
        And = 2,
        AndAlso = 3,
        ArrayLength = 4,
        ArrayIndex = 5,
        Call = 6,
        Coalesce = 7,
        Conditional = 8,
        Constant = 9,
        Convert = 10,
        ConvertChecked = 11,
        Divide = 12,
        Equal = 13,
        ExclusiveOr = 14,
        GreaterThan = 15,
        GreaterThanOrEqual = 16,
        Invoke = 17,
        Lambda = 18,
        LeftShift = 19,
        LessThan = 20,
        LessThanOrEqual = 21,
        ListInit = 22,
        MemberAccess = 23,
        MemberInit = 24,
        Modulo = 25,
        Multiply = 26,
        MultiplyChecked = 27,
        Negate = 28,
        UnaryPlus = 29,
        NegateChecked = 30,
        New = 31,
        NewArrayInit = 32,
        NewArrayBounds = 33,
        Not = 34,
        NotEqual = 35,
        Or = 36,
        OrElse = 37,
        Parameter = 38,
        Power = 39,
        Quote = 40,
        RightShift = 41,
        Subtract = 42,
        SubtractChecked = 43,
        TypeAs = 44,
        TypeIs = 45,
        Assign = 46,
        Block = 47,
        DebugInfo = 48,
        Decrement = 49,
        Dynamic = 50,
        Default = 51,
        Extension = 52,
        Goto = 53,
        Increment = 54,
        Index = 55,
        Label = 56,
        RuntimeVariables = 57,
        Loop = 58,
        Switch = 59,
        Throw = 60,
        Try = 61,
        Unbox = 62,
        AddAssign = 63,
        AndAssign = 64,
        DivideAssign = 65,
        ExclusiveOrAssign = 66,
        LeftShiftAssign = 67,
        ModuloAssign = 68,
        MultiplyAssign = 69,
        OrAssign = 70,
        PowerAssign = 71,
        RightShiftAssign = 72,
        SubtractAssign = 73,
        AddAssignChecked = 74,
        MultiplyAssignChecked = 75,
        SubtractAssignChecked = 76,
        PreIncrementAssign = 77,
        PreDecrementAssign = 78,
        PostIncrementAssign = 79,
        PostDecrementAssign = 80,
        TypeEqual = 81,
        OnesComplement = 82,
        IsTrue = 83,
        IsFalse = 84,
      }
      export class ExpressionVisitor {
        Visit(node: System.Linq.Expressions.Expression): System.Linq.Expressions.Expression;
        Visit(nodes: System.Linq.Expressions.Expression[]): System.Linq.Expressions.Expression[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum GotoExpressionKind {
        Goto = 0,
        Return = 1,
        Break = 2,
        Continue = 3,
      }
      export class GotoExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Value: System.Linq.Expressions.Expression;
        Target: System.Linq.Expressions.LabelTarget;
        Kind: System.Linq.Expressions.GotoExpressionKind;
        CanReduce: boolean;
        Update(target: System.Linq.Expressions.LabelTarget, value: System.Linq.Expressions.Expression): System.Linq.Expressions.GotoExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export interface IArgumentProvider {
        ArgumentCount: number;
        GetArgument(index: number): System.Linq.Expressions.Expression;
      }
      export interface IDynamicExpression {
        DelegateType: System.Type;
        Rewrite(args: System.Linq.Expressions.Expression[]): System.Linq.Expressions.Expression;
        CreateCallSite(): any;
      }
      export class IndexExpression {
        NodeType: System.Linq.Expressions.ExpressionType;
        Type: System.Type;
        Object: System.Linq.Expressions.Expression;
        Indexer: System.Reflection.PropertyInfo;
        Arguments: System.Linq.Expressions.Expression[];
        ArgumentCount: number;
        CanReduce: boolean;
        Update(object: System.Linq.Expressions.Expression, argumentsCS: System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>): System.Linq.Expressions.IndexExpression;
        GetArgument(index: number): System.Linq.Expressions.Expression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class InvocationExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Expression: System.Linq.Expressions.Expression;
        Arguments: System.Linq.Expressions.Expression[];
        ArgumentCount: number;
        CanReduce: boolean;
        Update(expression: System.Linq.Expressions.Expression, argumentsCS: System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>): System.Linq.Expressions.InvocationExpression;
        GetArgument(index: number): System.Linq.Expressions.Expression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class LabelExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Target: System.Linq.Expressions.LabelTarget;
        DefaultValue: System.Linq.Expressions.Expression;
        CanReduce: boolean;
        Update(target: System.Linq.Expressions.LabelTarget, defaultValue: System.Linq.Expressions.Expression): System.Linq.Expressions.LabelExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class LabelTarget {
        Name: string;
        Type: System.Type;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class LambdaExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Parameters: System.Linq.Expressions.ParameterExpression[];
        Name: string;
        Body: System.Linq.Expressions.Expression;
        ReturnType: System.Type;
        TailCall: boolean;
        CanReduce: boolean;
        Compile(): System.Delegate;
        Compile(preferInterpretation: boolean): System.Delegate;
        CompileToMethod(method: System.Reflection.Emit.MethodBuilder): void;
        Compile(debugInfoGenerator: System.Runtime.CompilerServices.DebugInfoGenerator): System.Delegate;
        CompileToMethod(method: System.Reflection.Emit.MethodBuilder, debugInfoGenerator: System.Runtime.CompilerServices.DebugInfoGenerator): void;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class ListInitExpression {
        NodeType: System.Linq.Expressions.ExpressionType;
        Type: System.Type;
        CanReduce: boolean;
        NewExpression: System.Linq.Expressions.NewExpression;
        Initializers: System.Linq.Expressions.ElementInit[];
        Reduce(): System.Linq.Expressions.Expression;
        Update(newExpression: System.Linq.Expressions.NewExpression, initializers: System.Collections.Generic.IEnumerable<System.Linq.Expressions.ElementInit>): System.Linq.Expressions.ListInitExpression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class LoopExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Body: System.Linq.Expressions.Expression;
        BreakLabel: System.Linq.Expressions.LabelTarget;
        ContinueLabel: System.Linq.Expressions.LabelTarget;
        CanReduce: boolean;
        Update(breakLabel: System.Linq.Expressions.LabelTarget, continueLabel: System.Linq.Expressions.LabelTarget, body: System.Linq.Expressions.Expression): System.Linq.Expressions.LoopExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MemberAssignment {
        Expression: System.Linq.Expressions.Expression;
        BindingType: System.Linq.Expressions.MemberBindingType;
        Member: System.Reflection.MemberInfo;
        Update(expression: System.Linq.Expressions.Expression): System.Linq.Expressions.MemberAssignment;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum MemberBindingType {
        Assignment = 0,
        MemberBinding = 1,
        ListBinding = 2,
      }
      export class MemberBinding {
        BindingType: System.Linq.Expressions.MemberBindingType;
        Member: System.Reflection.MemberInfo;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MemberExpression {
        Member: System.Reflection.MemberInfo;
        Expression: System.Linq.Expressions.Expression;
        NodeType: System.Linq.Expressions.ExpressionType;
        Type: System.Type;
        CanReduce: boolean;
        Update(expression: System.Linq.Expressions.Expression): System.Linq.Expressions.MemberExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MemberInitExpression {
        Type: System.Type;
        CanReduce: boolean;
        NodeType: System.Linq.Expressions.ExpressionType;
        NewExpression: System.Linq.Expressions.NewExpression;
        Bindings: System.Linq.Expressions.MemberBinding[];
        Reduce(): System.Linq.Expressions.Expression;
        Update(newExpression: System.Linq.Expressions.NewExpression, bindings: System.Collections.Generic.IEnumerable<System.Linq.Expressions.MemberBinding>): System.Linq.Expressions.MemberInitExpression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MemberListBinding {
        Initializers: System.Linq.Expressions.ElementInit[];
        BindingType: System.Linq.Expressions.MemberBindingType;
        Member: System.Reflection.MemberInfo;
        Update(initializers: System.Collections.Generic.IEnumerable<System.Linq.Expressions.ElementInit>): System.Linq.Expressions.MemberListBinding;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MemberMemberBinding {
        Bindings: System.Linq.Expressions.MemberBinding[];
        BindingType: System.Linq.Expressions.MemberBindingType;
        Member: System.Reflection.MemberInfo;
        Update(bindings: System.Collections.Generic.IEnumerable<System.Linq.Expressions.MemberBinding>): System.Linq.Expressions.MemberMemberBinding;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MethodCallExpression {
        NodeType: System.Linq.Expressions.ExpressionType;
        Type: System.Type;
        Method: System.Reflection.MethodInfo;
        Object: System.Linq.Expressions.Expression;
        Arguments: System.Linq.Expressions.Expression[];
        ArgumentCount: number;
        CanReduce: boolean;
        Update(object: System.Linq.Expressions.Expression, argumentsCS: System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>): System.Linq.Expressions.MethodCallExpression;
        GetArgument(index: number): System.Linq.Expressions.Expression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class NewArrayExpression {
        Type: System.Type;
        Expressions: System.Linq.Expressions.Expression[];
        NodeType: System.Linq.Expressions.ExpressionType;
        CanReduce: boolean;
        Update(expressions: System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>): System.Linq.Expressions.NewArrayExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class NewExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Constructor: System.Reflection.ConstructorInfo;
        Arguments: System.Linq.Expressions.Expression[];
        ArgumentCount: number;
        Members: System.Reflection.MemberInfo[];
        CanReduce: boolean;
        GetArgument(index: number): System.Linq.Expressions.Expression;
        Update(argumentsCS: System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>): System.Linq.Expressions.NewExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class ParameterExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Name: string;
        IsByRef: boolean;
        CanReduce: boolean;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class RuntimeVariablesExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Variables: System.Linq.Expressions.ParameterExpression[];
        CanReduce: boolean;
        Update(variables: System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>): System.Linq.Expressions.RuntimeVariablesExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class SwitchCase {
        TestValues: System.Linq.Expressions.Expression[];
        Body: System.Linq.Expressions.Expression;
        ToString(): string;
        Update(testValues: System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>, body: System.Linq.Expressions.Expression): System.Linq.Expressions.SwitchCase;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class SwitchExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        SwitchValue: System.Linq.Expressions.Expression;
        Cases: System.Linq.Expressions.SwitchCase[];
        DefaultBody: System.Linq.Expressions.Expression;
        Comparison: System.Reflection.MethodInfo;
        CanReduce: boolean;
        Update(switchValue: System.Linq.Expressions.Expression, cases: System.Collections.Generic.IEnumerable<System.Linq.Expressions.SwitchCase>, defaultBody: System.Linq.Expressions.Expression): System.Linq.Expressions.SwitchExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class SymbolDocumentInfo {
        FileName: string;
        Language: System.Guid;
        LanguageVendor: System.Guid;
        DocumentType: System.Guid;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class TryExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Body: System.Linq.Expressions.Expression;
        Handlers: System.Linq.Expressions.CatchBlock[];
        Finally: System.Linq.Expressions.Expression;
        Fault: System.Linq.Expressions.Expression;
        CanReduce: boolean;
        Update(body: System.Linq.Expressions.Expression, handlers: System.Collections.Generic.IEnumerable<System.Linq.Expressions.CatchBlock>, finallyCS: System.Linq.Expressions.Expression, fault: System.Linq.Expressions.Expression): System.Linq.Expressions.TryExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class TypeBinaryExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Expression: System.Linq.Expressions.Expression;
        TypeOperand: System.Type;
        CanReduce: boolean;
        Update(expression: System.Linq.Expressions.Expression): System.Linq.Expressions.TypeBinaryExpression;
        Reduce(): System.Linq.Expressions.Expression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class UnaryExpression {
        Type: System.Type;
        NodeType: System.Linq.Expressions.ExpressionType;
        Operand: System.Linq.Expressions.Expression;
        Method: System.Reflection.MethodInfo;
        IsLifted: boolean;
        IsLiftedToNull: boolean;
        CanReduce: boolean;
        Reduce(): System.Linq.Expressions.Expression;
        Update(operand: System.Linq.Expressions.Expression): System.Linq.Expressions.UnaryExpression;
        ReduceAndCheck(): System.Linq.Expressions.Expression;
        ReduceExtensions(): System.Linq.Expressions.Expression;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
    }
  }
  export namespace Management {
    export namespace Instrumentation {
      export class InstanceNotFoundException {
        constructor();
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class InstrumentationException {
        constructor();
        constructor(innerException: System.Exception);
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class InstrumentationBaseException {
        constructor();
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum ManagementConfigurationType {
        Apply = 0,
        OnCommit = 1,
      }
      export enum ManagementHostingModel {
        Decoupled = 0,
        LocalService = 2,
        LocalSystem = 3,
        NetworkService = 1,
      }
    }
  }
  export namespace Media {
    export class SoundPlayer {
      constructor();
      constructor(stream: System.IO.Stream);
      constructor(soundLocation: string);
      IsLoadCompleted: boolean;
      LoadTimeout: number;
      SoundLocation: string;
      Stream: System.IO.Stream;
      Tag: any; // System.Object
      Site: System.ComponentModel.ISite;
      Container: System.ComponentModel.IContainer;
      Load(): void;
      LoadAsync(): void;
      Play(): void;
      PlayLooping(): void;
      PlaySync(): void;
      Stop(): void;
      Dispose(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class SystemSound {
      Play(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SystemSounds {
      static Asterisk: System.Media.SystemSound;
      static Beep: System.Media.SystemSound;
      static Exclamation: System.Media.SystemSound;
      static Hand: System.Media.SystemSound;
      static Question: System.Media.SystemSound;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
  }
  export namespace Numerics {
    export class Vector<T = any> {
      constructor(value: T);
      constructor(values: T[]);
      constructor(values: System.Span<T>);
      constructor(values: T[], index: number);
      static Count: number;
      static Zero: any; // System.Numerics.Vector`1[T]
      static One: any; // System.Numerics.Vector`1[T]
      CopyTo(destination: T[]): void;
      CopyTo(destination: T[], startIndex: number): void;
      Equals(obj: any): boolean;
      Equals(other: System.Numerics.Vector<T>): boolean;
      GetHashCode(): number;
      ToString(): string;
      ToString(format: string): string;
      ToString(format: string, formatProvider: System.IFormatProvider): string;
      GetType(): System.Type;
    }
  }
  export namespace Reflection {
    export class AmbiguousMatchException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum AssemblyContentType {
      Default = 0,
      WindowsRuntime = 1,
    }
    export enum AssemblyNameFlags {
      None = 0,
      PublicKey = 1,
      EnableJITcompileOptimizer = 16384,
      EnableJITcompileTracking = 32768,
      Retargetable = 256,
    }
    export class Binder {
      BindToField(bindingAttr: System.Reflection.BindingFlags, match: System.Reflection.FieldInfo[], value: any, culture: System.Globalization.CultureInfo): System.Reflection.FieldInfo;
      ChangeType(value: any, type: System.Type, culture: System.Globalization.CultureInfo): any;
      SelectMethod(bindingAttr: System.Reflection.BindingFlags, match: System.Reflection.MethodBase[], types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodBase;
      SelectProperty(bindingAttr: System.Reflection.BindingFlags, match: System.Reflection.PropertyInfo[], returnType: System.Type, indexes: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
      CanChangeType(value: any, type: System.Type, culture: System.Globalization.CultureInfo): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum BindingFlags {
      Default = 0,
      IgnoreCase = 1,
      DeclaredOnly = 2,
      Instance = 4,
      Static = 8,
      Public = 16,
      NonPublic = 32,
      FlattenHierarchy = 64,
      InvokeMethod = 256,
      CreateInstance = 512,
      GetField = 1024,
      SetField = 2048,
      GetProperty = 4096,
      SetProperty = 8192,
      PutDispProperty = 16384,
      PutRefDispProperty = 32768,
      ExactBinding = 65536,
      SuppressChangeType = 131072,
      OptionalParamBinding = 262144,
      IgnoreReturn = 16777216,
      DoNotWrapExceptions = 33554432,
    }
    export enum CallingConventions {
      Standard = 1,
      VarArgs = 2,
      Any = 3,
      HasThis = 32,
      ExplicitThis = 64,
    }
    export class ConstructorInfo {
      MemberType: System.Reflection.MemberTypes;
      Attributes: System.Reflection.MethodAttributes;
      MethodImplementationFlags: System.Reflection.MethodImplAttributes;
      CallingConvention: System.Reflection.CallingConventions;
      IsAbstract: boolean;
      IsConstructor: boolean;
      IsFinal: boolean;
      IsHideBySig: boolean;
      IsSpecialName: boolean;
      IsStatic: boolean;
      IsVirtual: boolean;
      IsAssembly: boolean;
      IsFamily: boolean;
      IsFamilyAndAssembly: boolean;
      IsFamilyOrAssembly: boolean;
      IsPrivate: boolean;
      IsPublic: boolean;
      IsConstructedGenericMethod: boolean;
      IsGenericMethod: boolean;
      IsGenericMethodDefinition: boolean;
      ContainsGenericParameters: boolean;
      MethodHandle: System.RuntimeMethodHandle;
      IsSecurityCritical: boolean;
      IsSecuritySafeCritical: boolean;
      IsSecurityTransparent: boolean;
      Name: string;
      DeclaringType: System.Type;
      ReflectedType: System.Type;
      Module: System.Reflection.Module;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      static ConstructorName: string;
      static TypeConstructorName: string;
      Invoke(parameters: any[]): any;
      Invoke(invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetParameters(): System.Reflection.ParameterInfo[];
      GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;
      GetMethodBody(): System.Reflection.MethodBody;
      GetGenericArguments(): System.Type[];
      Invoke(obj: any, parameters: any[]): any;
      Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
      HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetType(): System.Type;
      ToString(): string;
    }
    export class CustomAttributeFormatException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum EventAttributes {
      None = 0,
      SpecialName = 512,
      RTSpecialName = 1024,
      ReservedMask = 1024,
    }
    export class EventInfo {
      MemberType: System.Reflection.MemberTypes;
      Attributes: System.Reflection.EventAttributes;
      IsSpecialName: boolean;
      AddMethod: System.Reflection.MethodInfo;
      RemoveMethod: System.Reflection.MethodInfo;
      RaiseMethod: System.Reflection.MethodInfo;
      IsMulticast: boolean;
      EventHandlerType: System.Type;
      Name: string;
      DeclaringType: System.Type;
      ReflectedType: System.Type;
      Module: System.Reflection.Module;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      GetOtherMethods(): System.Reflection.MethodInfo[];
      GetOtherMethods(nonPublic: boolean): System.Reflection.MethodInfo[];
      GetAddMethod(): System.Reflection.MethodInfo;
      GetRemoveMethod(): System.Reflection.MethodInfo;
      GetRaiseMethod(): System.Reflection.MethodInfo;
      GetAddMethod(nonPublic: boolean): System.Reflection.MethodInfo;
      GetRemoveMethod(nonPublic: boolean): System.Reflection.MethodInfo;
      GetRaiseMethod(nonPublic: boolean): System.Reflection.MethodInfo;
      RemoveEventHandler(target: any, handler: System.Delegate): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      AddEventHandler(target: any, handler: System.Delegate): void;
      HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetType(): System.Type;
      ToString(): string;
    }
    export enum ExceptionHandlingClauseOptions {
      Clause = 0,
      Filter = 1,
      Finally = 2,
      Fault = 4,
    }
    export enum FieldAttributes {
      FieldAccessMask = 7,
      PrivateScope = 0,
      Private = 1,
      FamANDAssem = 2,
      Assembly = 3,
      Family = 4,
      FamORAssem = 5,
      Public = 6,
      Static = 16,
      InitOnly = 32,
      Literal = 64,
      NotSerialized = 128,
      SpecialName = 512,
      PinvokeImpl = 8192,
      RTSpecialName = 1024,
      HasFieldMarshal = 4096,
      HasDefault = 32768,
      HasFieldRVA = 256,
      ReservedMask = 38144,
    }
    export class FieldInfo {
      MemberType: System.Reflection.MemberTypes;
      Attributes: System.Reflection.FieldAttributes;
      FieldType: System.Type;
      IsInitOnly: boolean;
      IsLiteral: boolean;
      IsNotSerialized: boolean;
      IsPinvokeImpl: boolean;
      IsSpecialName: boolean;
      IsStatic: boolean;
      IsAssembly: boolean;
      IsFamily: boolean;
      IsFamilyAndAssembly: boolean;
      IsFamilyOrAssembly: boolean;
      IsPrivate: boolean;
      IsPublic: boolean;
      IsSecurityCritical: boolean;
      IsSecuritySafeCritical: boolean;
      IsSecurityTransparent: boolean;
      FieldHandle: System.RuntimeFieldHandle;
      Name: string;
      DeclaringType: System.Type;
      ReflectedType: System.Type;
      Module: System.Reflection.Module;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetValue(obj: any): any;
      SetValue(obj: any, value: any): void;
      SetValue(obj: any, value: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, culture: System.Globalization.CultureInfo): void;
      SetValueDirect(obj: System.TypedReference, value: any): void;
      GetValueDirect(obj: System.TypedReference): any;
      GetRawConstantValue(): any;
      GetOptionalCustomModifiers(): System.Type[];
      GetRequiredCustomModifiers(): System.Type[];
      static GetFieldFromHandle(handle: System.RuntimeFieldHandle): System.Reflection.FieldInfo;
      static GetFieldFromHandle(handle: System.RuntimeFieldHandle, declaringType: System.RuntimeTypeHandle): System.Reflection.FieldInfo;
      HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetType(): System.Type;
      ToString(): string;
    }
    export enum GenericParameterAttributes {
      None = 0,
      VarianceMask = 3,
      Covariant = 1,
      Contravariant = 2,
      SpecialConstraintMask = 28,
      ReferenceTypeConstraint = 4,
      NotNullableValueTypeConstraint = 8,
      DefaultConstructorConstraint = 16,
    }
    export interface ICustomAttributeProvider {
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
    }
    export interface IReflect {
      UnderlyingSystemType: System.Type;
      GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo;
      GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
      GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
      GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
      GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo;
      GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
      GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];
      GetMember(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], modifiers: System.Reflection.ParameterModifier[], culture: System.Globalization.CultureInfo, namedParameters: string[]): any;
    }
    export interface IReflectableType {
      GetTypeInfo(): System.Reflection.TypeInfo;
    }
    export enum ImageFileMachine {
      I386 = 332,
      IA64 = 512,
      AMD64 = 34404,
      ARM = 452,
    }
    export class InterfaceMapping {
      TargetType: System.Type;
      InterfaceType: System.Type;
      TargetMethods: System.Reflection.MethodInfo[];
      InterfaceMethods: System.Reflection.MethodInfo[];
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class IntrospectionExtensions {
      static GetTypeInfo(type: System.Type): System.Reflection.TypeInfo;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class InvalidFilterCriteriaException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ManifestResourceInfo {
      constructor(containingAssembly: System.Reflection.Assembly, containingFileName: string, resourceLocation: System.Reflection.ResourceLocation);
      ReferencedAssembly: System.Reflection.Assembly;
      FileName: string;
      ResourceLocation: System.Reflection.ResourceLocation;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class MemberFilter {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(m: System.Reflection.MemberInfo, filterCriteria: any): boolean;
      BeginInvoke(m: System.Reflection.MemberInfo, filterCriteria: any, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): boolean;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class MemberInfo {
      MemberType: System.Reflection.MemberTypes;
      Name: string;
      DeclaringType: System.Type;
      ReflectedType: System.Type;
      Module: System.Reflection.Module;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum MemberTypes {
      Constructor = 1,
      Event = 2,
      Field = 4,
      Method = 8,
      Property = 16,
      TypeInfo = 32,
      Custom = 64,
      NestedType = 128,
      All = 191,
    }
    export enum MethodAttributes {
      MemberAccessMask = 7,
      PrivateScope = 0,
      Private = 1,
      FamANDAssem = 2,
      Assembly = 3,
      Family = 4,
      FamORAssem = 5,
      Public = 6,
      Static = 16,
      Final = 32,
      Virtual = 64,
      HideBySig = 128,
      CheckAccessOnOverride = 512,
      VtableLayoutMask = 256,
      ReuseSlot = 0,
      NewSlot = 256,
      Abstract = 1024,
      SpecialName = 2048,
      PinvokeImpl = 8192,
      UnmanagedExport = 8,
      RTSpecialName = 4096,
      HasSecurity = 16384,
      RequireSecObject = 32768,
      ReservedMask = 53248,
    }
    export class MethodBase {
      Attributes: System.Reflection.MethodAttributes;
      MethodImplementationFlags: System.Reflection.MethodImplAttributes;
      CallingConvention: System.Reflection.CallingConventions;
      IsAbstract: boolean;
      IsConstructor: boolean;
      IsFinal: boolean;
      IsHideBySig: boolean;
      IsSpecialName: boolean;
      IsStatic: boolean;
      IsVirtual: boolean;
      IsAssembly: boolean;
      IsFamily: boolean;
      IsFamilyAndAssembly: boolean;
      IsFamilyOrAssembly: boolean;
      IsPrivate: boolean;
      IsPublic: boolean;
      IsConstructedGenericMethod: boolean;
      IsGenericMethod: boolean;
      IsGenericMethodDefinition: boolean;
      ContainsGenericParameters: boolean;
      MethodHandle: System.RuntimeMethodHandle;
      IsSecurityCritical: boolean;
      IsSecuritySafeCritical: boolean;
      IsSecurityTransparent: boolean;
      MemberType: System.Reflection.MemberTypes;
      Name: string;
      DeclaringType: System.Type;
      ReflectedType: System.Type;
      Module: System.Reflection.Module;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      GetParameters(): System.Reflection.ParameterInfo[];
      GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;
      GetMethodBody(): System.Reflection.MethodBody;
      GetGenericArguments(): System.Type[];
      Invoke(obj: any, parameters: any[]): any;
      Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      static GetMethodFromHandle(handle: System.RuntimeMethodHandle): System.Reflection.MethodBase;
      static GetMethodFromHandle(handle: System.RuntimeMethodHandle, declaringType: System.RuntimeTypeHandle): System.Reflection.MethodBase;
      static GetCurrentMethod(): System.Reflection.MethodBase;
      HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetType(): System.Type;
      ToString(): string;
    }
    export enum MethodImplAttributes {
      CodeTypeMask = 3,
      IL = 0,
      Native = 1,
      OPTIL = 2,
      Runtime = 3,
      ManagedMask = 4,
      Unmanaged = 4,
      Managed = 0,
      ForwardRef = 16,
      PreserveSig = 128,
      InternalCall = 4096,
      Synchronized = 32,
      NoInlining = 8,
      AggressiveInlining = 256,
      NoOptimization = 64,
      MaxMethodImplVal = 65535,
      SecurityMitigations = 1024,
    }
    export class MethodInfo {
      MemberType: System.Reflection.MemberTypes;
      ReturnParameter: System.Reflection.ParameterInfo;
      ReturnType: System.Type;
      ReturnTypeCustomAttributes: System.Reflection.ICustomAttributeProvider;
      Attributes: System.Reflection.MethodAttributes;
      MethodImplementationFlags: System.Reflection.MethodImplAttributes;
      CallingConvention: System.Reflection.CallingConventions;
      IsAbstract: boolean;
      IsConstructor: boolean;
      IsFinal: boolean;
      IsHideBySig: boolean;
      IsSpecialName: boolean;
      IsStatic: boolean;
      IsVirtual: boolean;
      IsAssembly: boolean;
      IsFamily: boolean;
      IsFamilyAndAssembly: boolean;
      IsFamilyOrAssembly: boolean;
      IsPrivate: boolean;
      IsPublic: boolean;
      IsConstructedGenericMethod: boolean;
      IsGenericMethod: boolean;
      IsGenericMethodDefinition: boolean;
      ContainsGenericParameters: boolean;
      MethodHandle: System.RuntimeMethodHandle;
      IsSecurityCritical: boolean;
      IsSecuritySafeCritical: boolean;
      IsSecurityTransparent: boolean;
      Name: string;
      DeclaringType: System.Type;
      ReflectedType: System.Type;
      Module: System.Reflection.Module;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      GetGenericArguments(): System.Type[];
      GetGenericMethodDefinition(): System.Reflection.MethodInfo;
      MakeGenericMethod(...typeArguments: System.Type[]): System.Reflection.MethodInfo;
      GetBaseDefinition(): System.Reflection.MethodInfo;
      CreateDelegate(delegateType: System.Type): System.Delegate;
      CreateDelegate(delegateType: System.Type, target: any): System.Delegate;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetParameters(): System.Reflection.ParameterInfo[];
      GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;
      GetMethodBody(): System.Reflection.MethodBody;
      Invoke(obj: any, parameters: any[]): any;
      Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
      HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetType(): System.Type;
      ToString(): string;
    }
    export class Missing {
      static Value: System.Reflection.Missing;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Module {
      Assembly: System.Reflection.Assembly;
      FullyQualifiedName: string;
      Name: string;
      MDStreamVersion: number;
      ModuleVersionId: System.Guid;
      ScopeName: string;
      ModuleHandle: System.ModuleHandle;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      static FilterTypeName: ((m: System.Type, filterCriteria: any) => boolean);
      static FilterTypeNameIgnoreCase: ((m: System.Type, filterCriteria: any) => boolean);
      IsResource(): boolean;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetMethod(name: string): System.Reflection.MethodInfo;
      GetMethod(name: string, types: System.Type[]): System.Reflection.MethodInfo;
      GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethods(): System.Reflection.MethodInfo[];
      GetMethods(bindingFlags: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
      GetField(name: string): System.Reflection.FieldInfo;
      GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
      GetFields(): System.Reflection.FieldInfo[];
      GetFields(bindingFlags: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
      GetTypes(): System.Type[];
      GetType(className: string): System.Type;
      GetType(className: string, ignoreCase: boolean): System.Type;
      GetType(className: string, throwOnError: boolean, ignoreCase: boolean): System.Type;
      FindTypes(filter: ((m: System.Type, filterCriteria: any) => boolean), filterCriteria: any): System.Type[];
      ResolveField(metadataToken: number): System.Reflection.FieldInfo;
      ResolveField(metadataToken: number, genericTypeArguments: System.Type[], genericMethodArguments: System.Type[]): System.Reflection.FieldInfo;
      ResolveMember(metadataToken: number): System.Reflection.MemberInfo;
      ResolveMember(metadataToken: number, genericTypeArguments: System.Type[], genericMethodArguments: System.Type[]): System.Reflection.MemberInfo;
      ResolveMethod(metadataToken: number): System.Reflection.MethodBase;
      ResolveMethod(metadataToken: number, genericTypeArguments: System.Type[], genericMethodArguments: System.Type[]): System.Reflection.MethodBase;
      ResolveSignature(metadataToken: number): Byte[];
      ResolveString(metadataToken: number): string;
      ResolveType(metadataToken: number): System.Type;
      ResolveType(metadataToken: number, genericTypeArguments: System.Type[], genericMethodArguments: System.Type[]): System.Type;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(o: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetSignerCertificate(): System.Security.Cryptography.X509Certificates.X509Certificate;
      GetType(): System.Type;
    }
    export class ModuleResolveEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.ResolveEventArgs): System.Reflection.Module;
      BeginInvoke(sender: any, e: System.ResolveEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): System.Reflection.Module;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum ParameterAttributes {
      None = 0,
      In = 1,
      Out = 2,
      Lcid = 4,
      Retval = 8,
      Optional = 16,
      HasDefault = 4096,
      HasFieldMarshal = 8192,
      Reserved3 = 16384,
      Reserved4 = 32768,
      ReservedMask = 61440,
    }
    export class ParameterInfo {
      Attributes: System.Reflection.ParameterAttributes;
      Member: System.Reflection.MemberInfo;
      Name: string;
      ParameterType: System.Type;
      Position: number;
      IsIn: boolean;
      IsLcid: boolean;
      IsOptional: boolean;
      IsOut: boolean;
      IsRetval: boolean;
      DefaultValue: any; // System.Object
      RawDefaultValue: any; // System.Object
      HasDefaultValue: boolean;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetOptionalCustomModifiers(): System.Type[];
      GetRequiredCustomModifiers(): System.Type[];
      GetRealObject(context: System.Runtime.Serialization.StreamingContext): any;
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ParameterModifier {
      constructor(parameterCount: number);
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class Pointer {
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum PortableExecutableKinds {
      NotAPortableExecutableImage = 0,
      ILOnly = 1,
      Required32Bit = 2,
      PE32Plus = 4,
      Unmanaged32Bit = 8,
      Preferred32Bit = 16,
    }
    export enum ProcessorArchitecture {
      None = 0,
      MSIL = 1,
      X86 = 2,
      IA64 = 3,
      Amd64 = 4,
      Arm = 5,
    }
    export enum PropertyAttributes {
      None = 0,
      SpecialName = 512,
      RTSpecialName = 1024,
      HasDefault = 4096,
      Reserved2 = 8192,
      Reserved3 = 16384,
      Reserved4 = 32768,
      ReservedMask = 62464,
    }
    export class PropertyInfo {
      MemberType: System.Reflection.MemberTypes;
      PropertyType: System.Type;
      Attributes: System.Reflection.PropertyAttributes;
      IsSpecialName: boolean;
      CanRead: boolean;
      CanWrite: boolean;
      GetMethod: System.Reflection.MethodInfo;
      SetMethod: System.Reflection.MethodInfo;
      Name: string;
      DeclaringType: System.Type;
      ReflectedType: System.Type;
      Module: System.Reflection.Module;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      GetIndexParameters(): System.Reflection.ParameterInfo[];
      GetAccessors(): System.Reflection.MethodInfo[];
      GetAccessors(nonPublic: boolean): System.Reflection.MethodInfo[];
      GetGetMethod(): System.Reflection.MethodInfo;
      GetGetMethod(nonPublic: boolean): System.Reflection.MethodInfo;
      GetSetMethod(): System.Reflection.MethodInfo;
      GetSetMethod(nonPublic: boolean): System.Reflection.MethodInfo;
      GetOptionalCustomModifiers(): System.Type[];
      GetRequiredCustomModifiers(): System.Type[];
      GetValue(obj: any): any;
      GetValue(obj: any, index: any[]): any;
      GetValue(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, index: any[], culture: System.Globalization.CultureInfo): any;
      GetConstantValue(): any;
      GetRawConstantValue(): any;
      SetValue(obj: any, value: any): void;
      SetValue(obj: any, value: any, index: any[]): void;
      SetValue(obj: any, value: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, index: any[], culture: System.Globalization.CultureInfo): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetType(): System.Type;
      ToString(): string;
    }
    export class ReflectionContext {
      MapAssembly(assembly: System.Reflection.Assembly): System.Reflection.Assembly;
      MapType(type: System.Reflection.TypeInfo): System.Reflection.TypeInfo;
      GetTypeForObject(value: any): System.Reflection.TypeInfo;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ReflectionTypeLoadException {
      constructor(classes: System.Type[], exceptions: System.Exception[]);
      constructor(classes: System.Type[], exceptions: System.Exception[], message: string);
      Types: System.Type[];
      LoaderExceptions: System.Exception[];
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      ToString(): string;
      GetBaseException(): System.Exception;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum ResourceAttributes {
      Public = 1,
      Private = 2,
    }
    export enum ResourceLocation {
      ContainedInAnotherAssembly = 2,
      ContainedInManifestFile = 4,
      Embedded = 1,
    }
    export class TargetException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class TargetInvocationException {
      constructor(inner: System.Exception);
      constructor(message: string, inner: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class TargetParameterCountException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum TypeAttributes {
      VisibilityMask = 7,
      NotPublic = 0,
      Public = 1,
      NestedPublic = 2,
      NestedPrivate = 3,
      NestedFamily = 4,
      NestedAssembly = 5,
      NestedFamANDAssem = 6,
      NestedFamORAssem = 7,
      LayoutMask = 24,
      AutoLayout = 0,
      SequentialLayout = 8,
      ExplicitLayout = 16,
      ClassSemanticsMask = 32,
      Class = 0,
      Interface = 32,
      Abstract = 128,
      Sealed = 256,
      SpecialName = 1024,
      Import = 4096,
      Serializable = 8192,
      WindowsRuntime = 16384,
      StringFormatMask = 196608,
      AnsiClass = 0,
      UnicodeClass = 65536,
      AutoClass = 131072,
      CustomFormatClass = 196608,
      CustomFormatMask = 12582912,
      BeforeFieldInit = 1048576,
      RTSpecialName = 2048,
      HasSecurity = 262144,
      ReservedMask = 264192,
    }
    export class TypeDelegator {
      constructor(delegatingType: System.Type);
      GUID: System.Guid;
      MetadataToken: number;
      Module: System.Reflection.Module;
      Assembly: System.Reflection.Assembly;
      TypeHandle: System.RuntimeTypeHandle;
      Name: string;
      FullName: string;
      Namespace: string;
      AssemblyQualifiedName: string;
      BaseType: System.Type;
      IsTypeDefinition: boolean;
      IsSZArray: boolean;
      IsGenericTypeParameter: boolean;
      IsGenericMethodParameter: boolean;
      IsByRefLike: boolean;
      IsConstructedGenericType: boolean;
      IsCollectible: boolean;
      UnderlyingSystemType: System.Type;
      GenericTypeParameters: System.Type[];
      DeclaredConstructors: System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo>;
      DeclaredEvents: System.Collections.Generic.IEnumerable<System.Reflection.EventInfo>;
      DeclaredFields: System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo>;
      DeclaredMembers: System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo>;
      DeclaredMethods: System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
      DeclaredNestedTypes: System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>;
      DeclaredProperties: System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>;
      ImplementedInterfaces: System.Collections.Generic.IEnumerable<System.Type>;
      IsSerializable: boolean;
      ContainsGenericParameters: boolean;
      IsVisible: boolean;
      MemberType: System.Reflection.MemberTypes;
      IsNested: boolean;
      DeclaringType: System.Type;
      DeclaringMethod: System.Reflection.MethodBase;
      ReflectedType: System.Type;
      IsArray: boolean;
      IsByRef: boolean;
      IsPointer: boolean;
      IsGenericParameter: boolean;
      IsGenericType: boolean;
      IsGenericTypeDefinition: boolean;
      IsVariableBoundArray: boolean;
      HasElementType: boolean;
      GenericTypeArguments: System.Type[];
      GenericParameterPosition: number;
      GenericParameterAttributes: System.Reflection.GenericParameterAttributes;
      Attributes: System.Reflection.TypeAttributes;
      IsAbstract: boolean;
      IsImport: boolean;
      IsSealed: boolean;
      IsSpecialName: boolean;
      IsClass: boolean;
      IsNestedAssembly: boolean;
      IsNestedFamANDAssem: boolean;
      IsNestedFamily: boolean;
      IsNestedFamORAssem: boolean;
      IsNestedPrivate: boolean;
      IsNestedPublic: boolean;
      IsNotPublic: boolean;
      IsPublic: boolean;
      IsAutoLayout: boolean;
      IsExplicitLayout: boolean;
      IsLayoutSequential: boolean;
      IsAnsiClass: boolean;
      IsAutoClass: boolean;
      IsUnicodeClass: boolean;
      IsCOMObject: boolean;
      IsContextful: boolean;
      IsEnum: boolean;
      IsMarshalByRef: boolean;
      IsPrimitive: boolean;
      IsValueType: boolean;
      IsSignatureType: boolean;
      IsSecurityCritical: boolean;
      IsSecuritySafeCritical: boolean;
      IsSecurityTransparent: boolean;
      StructLayoutAttribute: any; // System.Runtime.InteropServices.StructLayoutAttribute
      TypeInitializer: System.Reflection.ConstructorInfo;
      IsInterface: boolean;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      IsAssignableFrom(typeInfo: System.Reflection.TypeInfo): boolean;
      InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], modifiers: System.Reflection.ParameterModifier[], culture: System.Globalization.CultureInfo, namedParameters: string[]): any;
      GetConstructors(bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];
      GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
      GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
      GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
      GetInterface(name: string, ignoreCase: boolean): System.Type;
      GetInterfaces(): System.Type[];
      GetEvent(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo;
      GetEvents(): System.Reflection.EventInfo[];
      GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];
      GetEvents(bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];
      GetNestedTypes(bindingAttr: System.Reflection.BindingFlags): System.Type[];
      GetNestedType(name: string, bindingAttr: System.Reflection.BindingFlags): System.Type;
      GetMember(name: string, type: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      GetElementType(): System.Type;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;
      AsType(): System.Type;
      GetDeclaredEvent(name: string): System.Reflection.EventInfo;
      GetDeclaredField(name: string): System.Reflection.FieldInfo;
      GetDeclaredMethod(name: string): System.Reflection.MethodInfo;
      GetDeclaredNestedType(name: string): System.Reflection.TypeInfo;
      GetDeclaredProperty(name: string): System.Reflection.PropertyInfo;
      GetDeclaredMethods(name: string): System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
      IsEnumDefined(value: any): boolean;
      GetEnumName(value: any): string;
      GetEnumNames(): string[];
      FindInterfaces(filter: ((m: System.Type, filterCriteria: any) => boolean), filterCriteria: any): System.Type[];
      FindMembers(memberType: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags, filter: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean), filterCriteria: any): System.Reflection.MemberInfo[];
      IsSubclassOf(c: System.Type): boolean;
      IsAssignableFrom(c: System.Type): boolean;
      GetType(): System.Type;
      GetArrayRank(): number;
      GetGenericTypeDefinition(): System.Type;
      GetGenericArguments(): System.Type[];
      GetGenericParameterConstraints(): System.Type[];
      GetConstructor(types: System.Type[]): System.Reflection.ConstructorInfo;
      GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
      GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
      GetConstructors(): System.Reflection.ConstructorInfo[];
      GetEvent(name: string): System.Reflection.EventInfo;
      GetField(name: string): System.Reflection.FieldInfo;
      GetFields(): System.Reflection.FieldInfo[];
      GetMember(name: string): System.Reflection.MemberInfo[];
      GetMember(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      GetMembers(): System.Reflection.MemberInfo[];
      GetMethod(name: string): System.Reflection.MethodInfo;
      GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo;
      GetMethod(name: string, types: System.Type[]): System.Reflection.MethodInfo;
      GetMethod(name: string, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, genericParameterCount: number, types: System.Type[]): System.Reflection.MethodInfo;
      GetMethod(name: string, genericParameterCount: number, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethods(): System.Reflection.MethodInfo[];
      GetNestedType(name: string): System.Type;
      GetNestedTypes(): System.Type[];
      GetProperty(name: string): System.Reflection.PropertyInfo;
      GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo;
      GetProperty(name: string, returnType: System.Type): System.Reflection.PropertyInfo;
      GetProperty(name: string, types: System.Type[]): System.Reflection.PropertyInfo;
      GetProperty(name: string, returnType: System.Type, types: System.Type[]): System.Reflection.PropertyInfo;
      GetProperty(name: string, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
      GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
      GetProperties(): System.Reflection.PropertyInfo[];
      GetDefaultMembers(): System.Reflection.MemberInfo[];
      InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[]): any;
      InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], culture: System.Globalization.CultureInfo): any;
      GetInterface(name: string): System.Type;
      IsInstanceOfType(o: any): boolean;
      IsEquivalentTo(other: System.Type): boolean;
      GetEnumUnderlyingType(): System.Type;
      GetEnumValues(): System.Array;
      MakeArrayType(): System.Type;
      MakeArrayType(rank: number): System.Type;
      MakeByRefType(): System.Type;
      MakeGenericType(...typeArguments: System.Type[]): System.Type;
      MakePointerType(): System.Type;
      ToString(): string;
      Equals(o: any): boolean;
      GetHashCode(): number;
      Equals(o: System.Type): boolean;
      HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetType(): System.Type;
    }
    export class TypeFilter {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(m: System.Type, filterCriteria: any): boolean;
      BeginInvoke(m: System.Type, filterCriteria: any, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): boolean;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TypeInfo {
      GenericTypeParameters: System.Type[];
      DeclaredConstructors: System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo>;
      DeclaredEvents: System.Collections.Generic.IEnumerable<System.Reflection.EventInfo>;
      DeclaredFields: System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo>;
      DeclaredMembers: System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo>;
      DeclaredMethods: System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
      DeclaredNestedTypes: System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>;
      DeclaredProperties: System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>;
      ImplementedInterfaces: System.Collections.Generic.IEnumerable<System.Type>;
      IsSerializable: boolean;
      ContainsGenericParameters: boolean;
      IsVisible: boolean;
      MemberType: System.Reflection.MemberTypes;
      Namespace: string;
      AssemblyQualifiedName: string;
      FullName: string;
      Assembly: System.Reflection.Assembly;
      Module: System.Reflection.Module;
      IsNested: boolean;
      DeclaringType: System.Type;
      DeclaringMethod: System.Reflection.MethodBase;
      ReflectedType: System.Type;
      UnderlyingSystemType: System.Type;
      IsTypeDefinition: boolean;
      IsArray: boolean;
      IsByRef: boolean;
      IsPointer: boolean;
      IsConstructedGenericType: boolean;
      IsGenericParameter: boolean;
      IsGenericTypeParameter: boolean;
      IsGenericMethodParameter: boolean;
      IsGenericType: boolean;
      IsGenericTypeDefinition: boolean;
      IsSZArray: boolean;
      IsVariableBoundArray: boolean;
      IsByRefLike: boolean;
      HasElementType: boolean;
      GenericTypeArguments: System.Type[];
      GenericParameterPosition: number;
      GenericParameterAttributes: System.Reflection.GenericParameterAttributes;
      Attributes: System.Reflection.TypeAttributes;
      IsAbstract: boolean;
      IsImport: boolean;
      IsSealed: boolean;
      IsSpecialName: boolean;
      IsClass: boolean;
      IsNestedAssembly: boolean;
      IsNestedFamANDAssem: boolean;
      IsNestedFamily: boolean;
      IsNestedFamORAssem: boolean;
      IsNestedPrivate: boolean;
      IsNestedPublic: boolean;
      IsNotPublic: boolean;
      IsPublic: boolean;
      IsAutoLayout: boolean;
      IsExplicitLayout: boolean;
      IsLayoutSequential: boolean;
      IsAnsiClass: boolean;
      IsAutoClass: boolean;
      IsUnicodeClass: boolean;
      IsCOMObject: boolean;
      IsContextful: boolean;
      IsCollectible: boolean;
      IsEnum: boolean;
      IsMarshalByRef: boolean;
      IsPrimitive: boolean;
      IsValueType: boolean;
      IsSignatureType: boolean;
      IsSecurityCritical: boolean;
      IsSecuritySafeCritical: boolean;
      IsSecurityTransparent: boolean;
      StructLayoutAttribute: any; // System.Runtime.InteropServices.StructLayoutAttribute
      TypeInitializer: System.Reflection.ConstructorInfo;
      TypeHandle: System.RuntimeTypeHandle;
      GUID: System.Guid;
      BaseType: System.Type;
      IsInterface: boolean;
      Name: string;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      MetadataToken: number;
      AsType(): System.Type;
      GetDeclaredEvent(name: string): System.Reflection.EventInfo;
      GetDeclaredField(name: string): System.Reflection.FieldInfo;
      GetDeclaredMethod(name: string): System.Reflection.MethodInfo;
      GetDeclaredNestedType(name: string): System.Reflection.TypeInfo;
      GetDeclaredProperty(name: string): System.Reflection.PropertyInfo;
      GetDeclaredMethods(name: string): System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
      IsAssignableFrom(typeInfo: System.Reflection.TypeInfo): boolean;
      IsEnumDefined(value: any): boolean;
      GetEnumName(value: any): string;
      GetEnumNames(): string[];
      FindInterfaces(filter: ((m: System.Type, filterCriteria: any) => boolean), filterCriteria: any): System.Type[];
      FindMembers(memberType: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags, filter: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean), filterCriteria: any): System.Reflection.MemberInfo[];
      IsSubclassOf(c: System.Type): boolean;
      IsAssignableFrom(c: System.Type): boolean;
      GetType(): System.Type;
      GetElementType(): System.Type;
      GetArrayRank(): number;
      GetGenericTypeDefinition(): System.Type;
      GetGenericArguments(): System.Type[];
      GetGenericParameterConstraints(): System.Type[];
      GetConstructor(types: System.Type[]): System.Reflection.ConstructorInfo;
      GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
      GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
      GetConstructors(): System.Reflection.ConstructorInfo[];
      GetConstructors(bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];
      GetEvent(name: string): System.Reflection.EventInfo;
      GetEvent(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo;
      GetEvents(): System.Reflection.EventInfo[];
      GetEvents(bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];
      GetField(name: string): System.Reflection.FieldInfo;
      GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
      GetFields(): System.Reflection.FieldInfo[];
      GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
      GetMember(name: string): System.Reflection.MemberInfo[];
      GetMember(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      GetMember(name: string, type: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      GetMembers(): System.Reflection.MemberInfo[];
      GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      GetMethod(name: string): System.Reflection.MethodInfo;
      GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo;
      GetMethod(name: string, types: System.Type[]): System.Reflection.MethodInfo;
      GetMethod(name: string, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, genericParameterCount: number, types: System.Type[]): System.Reflection.MethodInfo;
      GetMethod(name: string, genericParameterCount: number, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
      GetMethods(): System.Reflection.MethodInfo[];
      GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
      GetNestedType(name: string): System.Type;
      GetNestedType(name: string, bindingAttr: System.Reflection.BindingFlags): System.Type;
      GetNestedTypes(): System.Type[];
      GetNestedTypes(bindingAttr: System.Reflection.BindingFlags): System.Type[];
      GetProperty(name: string): System.Reflection.PropertyInfo;
      GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo;
      GetProperty(name: string, returnType: System.Type): System.Reflection.PropertyInfo;
      GetProperty(name: string, types: System.Type[]): System.Reflection.PropertyInfo;
      GetProperty(name: string, returnType: System.Type, types: System.Type[]): System.Reflection.PropertyInfo;
      GetProperty(name: string, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
      GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
      GetProperties(): System.Reflection.PropertyInfo[];
      GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];
      GetDefaultMembers(): System.Reflection.MemberInfo[];
      InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[]): any;
      InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], culture: System.Globalization.CultureInfo): any;
      InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], modifiers: System.Reflection.ParameterModifier[], culture: System.Globalization.CultureInfo, namedParameters: string[]): any;
      GetInterface(name: string): System.Type;
      GetInterface(name: string, ignoreCase: boolean): System.Type;
      GetInterfaces(): System.Type[];
      GetInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;
      IsInstanceOfType(o: any): boolean;
      IsEquivalentTo(other: System.Type): boolean;
      GetEnumUnderlyingType(): System.Type;
      GetEnumValues(): System.Array;
      MakeArrayType(): System.Type;
      MakeArrayType(rank: number): System.Type;
      MakeByRefType(): System.Type;
      MakeGenericType(...typeArguments: System.Type[]): System.Type;
      MakePointerType(): System.Type;
      ToString(): string;
      Equals(o: any): boolean;
      GetHashCode(): number;
      Equals(o: System.Type): boolean;
      HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetType(): System.Type;
    }
    export class TypeExtensions {
      static GetConstructor(type: System.Type, types: System.Type[]): System.Reflection.ConstructorInfo;
      static GetConstructors(type: System.Type): System.Reflection.ConstructorInfo[];
      static GetConstructors(type: System.Type, bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];
      static GetDefaultMembers(type: System.Type): System.Reflection.MemberInfo[];
      static GetEvent(type: System.Type, name: string): System.Reflection.EventInfo;
      static GetEvent(type: System.Type, name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo;
      static GetEvents(type: System.Type): System.Reflection.EventInfo[];
      static GetEvents(type: System.Type, bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];
      static GetField(type: System.Type, name: string): System.Reflection.FieldInfo;
      static GetField(type: System.Type, name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
      static GetFields(type: System.Type): System.Reflection.FieldInfo[];
      static GetFields(type: System.Type, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
      static GetGenericArguments(type: System.Type): System.Type[];
      static GetInterfaces(type: System.Type): System.Type[];
      static GetMember(type: System.Type, name: string): System.Reflection.MemberInfo[];
      static GetMember(type: System.Type, name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      static GetMembers(type: System.Type): System.Reflection.MemberInfo[];
      static GetMembers(type: System.Type, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
      static GetMethod(type: System.Type, name: string): System.Reflection.MethodInfo;
      static GetMethod(type: System.Type, name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo;
      static GetMethod(type: System.Type, name: string, types: System.Type[]): System.Reflection.MethodInfo;
      static GetMethods(type: System.Type): System.Reflection.MethodInfo[];
      static GetMethods(type: System.Type, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
      static GetNestedType(type: System.Type, name: string, bindingAttr: System.Reflection.BindingFlags): System.Type;
      static GetNestedTypes(type: System.Type, bindingAttr: System.Reflection.BindingFlags): System.Type[];
      static GetProperties(type: System.Type): System.Reflection.PropertyInfo[];
      static GetProperties(type: System.Type, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];
      static GetProperty(type: System.Type, name: string): System.Reflection.PropertyInfo;
      static GetProperty(type: System.Type, name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo;
      static GetProperty(type: System.Type, name: string, returnType: System.Type): System.Reflection.PropertyInfo;
      static GetProperty(type: System.Type, name: string, returnType: System.Type, types: System.Type[]): System.Reflection.PropertyInfo;
      static IsAssignableFrom(type: System.Type, c: System.Type): boolean;
      static IsInstanceOfType(type: System.Type, o: any): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AssemblyExtensions {
      static GetExportedTypes(assembly: System.Reflection.Assembly): System.Type[];
      static GetModules(assembly: System.Reflection.Assembly): System.Reflection.Module[];
      static GetTypes(assembly: System.Reflection.Assembly): System.Type[];
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EventInfoExtensions {
      static GetAddMethod(eventInfo: System.Reflection.EventInfo): System.Reflection.MethodInfo;
      static GetAddMethod(eventInfo: System.Reflection.EventInfo, nonPublic: boolean): System.Reflection.MethodInfo;
      static GetRaiseMethod(eventInfo: System.Reflection.EventInfo): System.Reflection.MethodInfo;
      static GetRaiseMethod(eventInfo: System.Reflection.EventInfo, nonPublic: boolean): System.Reflection.MethodInfo;
      static GetRemoveMethod(eventInfo: System.Reflection.EventInfo): System.Reflection.MethodInfo;
      static GetRemoveMethod(eventInfo: System.Reflection.EventInfo, nonPublic: boolean): System.Reflection.MethodInfo;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class MemberInfoExtensions {
      static HasMetadataToken(member: System.Reflection.MemberInfo): boolean;
      static GetMetadataToken(member: System.Reflection.MemberInfo): number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class MethodInfoExtensions {
      static GetBaseDefinition(method: System.Reflection.MethodInfo): System.Reflection.MethodInfo;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ModuleExtensions {
      static HasModuleVersionId(module: System.Reflection.Module): boolean;
      static GetModuleVersionId(module: System.Reflection.Module): System.Guid;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PropertyInfoExtensions {
      static GetAccessors(property: System.Reflection.PropertyInfo): System.Reflection.MethodInfo[];
      static GetAccessors(property: System.Reflection.PropertyInfo, nonPublic: boolean): System.Reflection.MethodInfo[];
      static GetGetMethod(property: System.Reflection.PropertyInfo): System.Reflection.MethodInfo;
      static GetGetMethod(property: System.Reflection.PropertyInfo, nonPublic: boolean): System.Reflection.MethodInfo;
      static GetSetMethod(property: System.Reflection.PropertyInfo): System.Reflection.MethodInfo;
      static GetSetMethod(property: System.Reflection.PropertyInfo, nonPublic: boolean): System.Reflection.MethodInfo;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AssemblyNameProxy {
      constructor();
      GetAssemblyName(assemblyFile: string): System.Reflection.AssemblyName;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RuntimeReflectionExtensions {
      static GetRuntimeFields(type: System.Type): any;
      static GetRuntimeMethods(type: System.Type): any;
      static GetRuntimeProperties(type: System.Type): any;
      static GetRuntimeEvents(type: System.Type): any;
      static GetRuntimeField(type: System.Type, name: string): System.Reflection.FieldInfo;
      static GetRuntimeMethod(type: System.Type, name: string, parameters: System.Type[]): System.Reflection.MethodInfo;
      static GetRuntimeProperty(type: System.Type, name: string): System.Reflection.PropertyInfo;
      static GetRuntimeEvent(type: System.Type, name: string): System.Reflection.EventInfo;
      static GetRuntimeBaseDefinition(method: System.Reflection.MethodInfo): System.Reflection.MethodInfo;
      static GetRuntimeInterfaceMap(typeInfo: System.Reflection.TypeInfo, interfaceType: System.Type): System.Reflection.InterfaceMapping;
      static GetMethodInfo(del: System.Delegate): System.Reflection.MethodInfo;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CustomAttributeNamedArgument {
      constructor(memberInfo: System.Reflection.MemberInfo, value: any);
      constructor(memberInfo: System.Reflection.MemberInfo, typedArgument: System.Reflection.CustomAttributeTypedArgument);
      TypedValue: System.Reflection.CustomAttributeTypedArgument;
      IsField: boolean;
      MemberName: string;
      MemberInfo: System.Reflection.MemberInfo;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class CustomAttributeTypedArgument {
      constructor(value: any);
      constructor(argumentType: System.Type, value: any);
      ArgumentType: System.Type;
      Value: any; // System.Object
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class MissingMetadataException {
      constructor();
      constructor(message: string);
      Message: string;
      TypeName: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class CustomAttributeExtensions {
      static GetCustomAttribute(element: System.Reflection.Assembly, attributeType: System.Type): any;
      static GetCustomAttribute(element: System.Reflection.Module, attributeType: System.Type): any;
      static GetCustomAttribute(element: System.Reflection.MemberInfo, attributeType: System.Type): any;
      static GetCustomAttribute(element: System.Reflection.ParameterInfo, attributeType: System.Type): any;
      static GetCustomAttribute(element: System.Reflection.MemberInfo, attributeType: System.Type, inherit: boolean): any;
      static GetCustomAttribute(element: System.Reflection.ParameterInfo, attributeType: System.Type, inherit: boolean): any;
      static GetCustomAttributes(element: System.Reflection.Assembly): any;
      static GetCustomAttributes(element: System.Reflection.Module): any;
      static GetCustomAttributes(element: System.Reflection.MemberInfo): any;
      static GetCustomAttributes(element: System.Reflection.ParameterInfo): any;
      static GetCustomAttributes(element: System.Reflection.MemberInfo, inherit: boolean): any;
      static GetCustomAttributes(element: System.Reflection.ParameterInfo, inherit: boolean): any;
      static GetCustomAttributes(element: System.Reflection.Assembly, attributeType: System.Type): any;
      static GetCustomAttributes(element: System.Reflection.Module, attributeType: System.Type): any;
      static GetCustomAttributes(element: System.Reflection.MemberInfo, attributeType: System.Type): any;
      static GetCustomAttributes(element: System.Reflection.ParameterInfo, attributeType: System.Type): any;
      static GetCustomAttributes(element: System.Reflection.MemberInfo, attributeType: System.Type, inherit: boolean): any;
      static GetCustomAttributes(element: System.Reflection.ParameterInfo, attributeType: System.Type, inherit: boolean): any;
      static IsDefined(element: System.Reflection.Assembly, attributeType: System.Type): boolean;
      static IsDefined(element: System.Reflection.Module, attributeType: System.Type): boolean;
      static IsDefined(element: System.Reflection.MemberInfo, attributeType: System.Type): boolean;
      static IsDefined(element: System.Reflection.ParameterInfo, attributeType: System.Type): boolean;
      static IsDefined(element: System.Reflection.MemberInfo, attributeType: System.Type, inherit: boolean): boolean;
      static IsDefined(element: System.Reflection.ParameterInfo, attributeType: System.Type, inherit: boolean): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Assembly {
      CodeBase: string;
      EscapedCodeBase: string;
      FullName: string;
      EntryPoint: System.Reflection.MethodInfo;
      Evidence: System.Security.Policy.Evidence;
      Location: string;
      ImageRuntimeVersion: string;
      HostContext: number;
      ReflectionOnly: boolean;
      PermissionSet: System.Security.PermissionSet;
      SecurityRuleSet: System.Security.SecurityRuleSet;
      IsFullyTrusted: boolean;
      ManifestModule: System.Reflection.Module;
      GlobalAssemblyCache: boolean;
      IsDynamic: boolean;
      DefinedTypes: System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>;
      ExportedTypes: System.Collections.Generic.IEnumerable<System.Type>;
      Modules: System.Collections.Generic.IEnumerable<System.Reflection.Module>;
      CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      IsDefined(attributeType: System.Type, inherit: boolean): boolean;
      GetCustomAttributes(inherit: boolean): any[];
      GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
      GetFiles(): System.IO.FileStream[];
      GetFiles(getResourceModules: boolean): System.IO.FileStream[];
      GetFile(name: string): System.IO.FileStream;
      GetManifestResourceStream(name: string): System.IO.Stream;
      GetManifestResourceStream(type: System.Type, name: string): System.IO.Stream;
      GetTypes(): System.Type[];
      GetExportedTypes(): System.Type[];
      GetType(name: string, throwOnError: boolean): System.Type;
      GetType(name: string): System.Type;
      GetName(copiedName: boolean): System.Reflection.AssemblyName;
      GetName(): System.Reflection.AssemblyName;
      ToString(): string;
      static CreateQualifiedName(assemblyName: string, typeName: string): string;
      static GetAssembly(type: System.Type): System.Reflection.Assembly;
      static GetEntryAssembly(): System.Reflection.Assembly;
      static LoadFrom(assemblyFile: string): System.Reflection.Assembly;
      static LoadFrom(assemblyFile: string, securityEvidence: System.Security.Policy.Evidence): System.Reflection.Assembly;
      static LoadFrom(assemblyFile: string, securityEvidence: System.Security.Policy.Evidence, hashValue: Byte[], hashAlgorithm: any): System.Reflection.Assembly;
      static LoadFrom(assemblyFile: string, hashValue: Byte[], hashAlgorithm: any): System.Reflection.Assembly;
      static UnsafeLoadFrom(assemblyFile: string): System.Reflection.Assembly;
      static LoadFile(path: string, securityEvidence: System.Security.Policy.Evidence): System.Reflection.Assembly;
      static LoadFile(path: string): System.Reflection.Assembly;
      static Load(assemblyString: string): System.Reflection.Assembly;
      static Load(assemblyString: string, assemblySecurity: System.Security.Policy.Evidence): System.Reflection.Assembly;
      static Load(assemblyRef: System.Reflection.AssemblyName): System.Reflection.Assembly;
      static Load(assemblyRef: System.Reflection.AssemblyName, assemblySecurity: System.Security.Policy.Evidence): System.Reflection.Assembly;
      static Load(rawAssembly: Byte[]): System.Reflection.Assembly;
      static Load(rawAssembly: Byte[], rawSymbolStore: Byte[]): System.Reflection.Assembly;
      static Load(rawAssembly: Byte[], rawSymbolStore: Byte[], securityEvidence: System.Security.Policy.Evidence): System.Reflection.Assembly;
      static Load(rawAssembly: Byte[], rawSymbolStore: Byte[], securityContextSource: System.Security.SecurityContextSource): System.Reflection.Assembly;
      static ReflectionOnlyLoad(rawAssembly: Byte[]): System.Reflection.Assembly;
      static ReflectionOnlyLoad(assemblyString: string): System.Reflection.Assembly;
      static ReflectionOnlyLoadFrom(assemblyFile: string): System.Reflection.Assembly;
      static LoadWithPartialName(partialName: string): System.Reflection.Assembly;
      LoadModule(moduleName: string, rawModule: Byte[]): System.Reflection.Module;
      LoadModule(moduleName: string, rawModule: Byte[], rawSymbolStore: Byte[]): System.Reflection.Module;
      static LoadWithPartialName(partialName: string, securityEvidence: System.Security.Policy.Evidence): System.Reflection.Assembly;
      CreateInstance(typeName: string): any;
      CreateInstance(typeName: string, ignoreCase: boolean): any;
      CreateInstance(typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): any;
      GetLoadedModules(): System.Reflection.Module[];
      GetModules(): System.Reflection.Module[];
      static GetExecutingAssembly(): System.Reflection.Assembly;
      static GetCallingAssembly(): System.Reflection.Assembly;
      GetManifestResourceNames(): string[];
      GetManifestResourceInfo(resourceName: string): System.Reflection.ManifestResourceInfo;
      GetHashCode(): number;
      Equals(o: any): boolean;
      GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
      GetType(name: string, throwOnError: boolean, ignoreCase: boolean): System.Type;
      GetModule(name: string): System.Reflection.Module;
      GetReferencedAssemblies(): System.Reflection.AssemblyName[];
      GetModules(getResourceModules: boolean): System.Reflection.Module[];
      GetLoadedModules(getResourceModules: boolean): System.Reflection.Module[];
      GetSatelliteAssembly(culture: System.Globalization.CultureInfo): System.Reflection.Assembly;
      GetSatelliteAssembly(culture: System.Globalization.CultureInfo, version: System.Version): System.Reflection.Assembly;
      GetForwardedTypes(): System.Type[];
      GetType(): System.Type;
    }
    export class AssemblyName {
      constructor();
      constructor(assemblyName: string);
      ProcessorArchitecture: System.Reflection.ProcessorArchitecture;
      Name: string;
      CodeBase: string;
      EscapedCodeBase: string;
      CultureInfo: System.Globalization.CultureInfo;
      Flags: System.Reflection.AssemblyNameFlags;
      FullName: string;
      HashAlgorithm: any; // System.Configuration.Assemblies.AssemblyHashAlgorithm
      KeyPair: System.Reflection.StrongNameKeyPair;
      Version: System.Version;
      VersionCompatibility: any; // System.Configuration.Assemblies.AssemblyVersionCompatibility
      CultureName: string;
      ContentType: System.Reflection.AssemblyContentType;
      ToString(): string;
      GetPublicKey(): Byte[];
      GetPublicKeyToken(): Byte[];
      static ReferenceMatchesDefinition(reference: System.Reflection.AssemblyName, definition: System.Reflection.AssemblyName): boolean;
      SetPublicKey(publicKey: Byte[]): void;
      SetPublicKeyToken(publicKeyToken: Byte[]): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Clone(): any;
      OnDeserialization(sender: any): void;
      static GetAssemblyName(assemblyFile: string): System.Reflection.AssemblyName;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class CustomAttributeData {
      Constructor: System.Reflection.ConstructorInfo;
      ConstructorArguments: System.Reflection.CustomAttributeTypedArgument[];
      NamedArguments: System.Reflection.CustomAttributeNamedArgument[];
      AttributeType: System.Type;
      static GetCustomAttributes(target: System.Reflection.Assembly): System.Reflection.CustomAttributeData[];
      static GetCustomAttributes(target: System.Reflection.MemberInfo): System.Reflection.CustomAttributeData[];
      static GetCustomAttributes(target: System.Reflection.Module): System.Reflection.CustomAttributeData[];
      static GetCustomAttributes(target: System.Reflection.ParameterInfo): System.Reflection.CustomAttributeData[];
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ExceptionHandlingClause {
      CatchType: System.Type;
      FilterOffset: number;
      Flags: System.Reflection.ExceptionHandlingClauseOptions;
      HandlerLength: number;
      HandlerOffset: number;
      TryLength: number;
      TryOffset: number;
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class LocalVariableInfo {
      IsPinned: boolean;
      LocalIndex: number;
      LocalType: System.Type;
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class MethodBody {
      ExceptionHandlingClauses: System.Reflection.ExceptionHandlingClause[];
      LocalVariables: System.Reflection.LocalVariableInfo[];
      InitLocals: boolean;
      LocalSignatureMetadataToken: number;
      MaxStackSize: number;
      GetILAsByteArray(): Byte[];
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class StrongNameKeyPair {
      constructor(keyPairArray: Byte[]);
      constructor(keyPairFile: System.IO.FileStream);
      constructor(keyPairContainer: string);
      PublicKey: Byte[];
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DispatchProxy {
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export interface ICustomTypeProvider {
      GetCustomType(): System.Type;
    }
    export namespace Emit {
      export enum OpCodeType {
        Annotation = 0,
        Macro = 1,
        Nternal = 2,
        Objmodel = 3,
        Prefix = 4,
        Primitive = 5,
      }
      export enum OperandType {
        InlineBrTarget = 0,
        InlineField = 1,
        InlineI = 2,
        InlineI8 = 3,
        InlineMethod = 4,
        InlineNone = 5,
        InlinePhi = 6,
        InlineR = 7,
        InlineSig = 9,
        InlineString = 10,
        InlineSwitch = 11,
        InlineTok = 12,
        InlineType = 13,
        InlineVar = 14,
        ShortInlineBrTarget = 15,
        ShortInlineI = 16,
        ShortInlineR = 17,
        ShortInlineVar = 18,
      }
      export enum PackingSize {
        Unspecified = 0,
        Size1 = 1,
        Size2 = 2,
        Size4 = 4,
        Size8 = 8,
        Size16 = 16,
        Size32 = 32,
        Size64 = 64,
        Size128 = 128,
      }
      export enum StackBehaviour {
        Pop0 = 0,
        Pop1 = 1,
        Pop1_pop1 = 2,
        Popi = 3,
        Popi_pop1 = 4,
        Popi_popi = 5,
        Popi_popi8 = 6,
        Popi_popi_popi = 7,
        Popi_popr4 = 8,
        Popi_popr8 = 9,
        Popref = 10,
        Popref_pop1 = 11,
        Popref_popi = 12,
        Popref_popi_popi = 13,
        Popref_popi_popi8 = 14,
        Popref_popi_popr4 = 15,
        Popref_popi_popr8 = 16,
        Popref_popi_popref = 17,
        Push0 = 18,
        Push1 = 19,
        Push1_push1 = 20,
        Pushi = 21,
        Pushi8 = 22,
        Pushr4 = 23,
        Pushr8 = 24,
        Pushref = 25,
        Varpop = 26,
        Varpush = 27,
        Popref_popi_pop1 = 28,
      }
      export class ExceptionHandler {
        constructor(tryOffset: number, tryLength: number, filterOffset: number, handlerOffset: number, handlerLength: number, kind: System.Reflection.ExceptionHandlingClauseOptions, exceptionTypeToken: number);
        ExceptionTypeToken: number;
        TryOffset: number;
        TryLength: number;
        FilterOffset: number;
        HandlerOffset: number;
        HandlerLength: number;
        Kind: System.Reflection.ExceptionHandlingClauseOptions;
        GetHashCode(): number;
        Equals(obj: any): boolean;
        Equals(other: System.Reflection.Emit.ExceptionHandler): boolean;
        ToString(): string;
        GetType(): System.Type;
      }
      export class AssemblyBuilder {
        CodeBase: string;
        EscapedCodeBase: string;
        EntryPoint: System.Reflection.MethodInfo;
        Location: string;
        ImageRuntimeVersion: string;
        ReflectionOnly: boolean;
        ManifestModule: System.Reflection.Module;
        GlobalAssemblyCache: boolean;
        IsDynamic: boolean;
        FullName: string;
        Evidence: System.Security.Policy.Evidence;
        HostContext: number;
        PermissionSet: System.Security.PermissionSet;
        SecurityRuleSet: System.Security.SecurityRuleSet;
        IsFullyTrusted: boolean;
        DefinedTypes: System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>;
        ExportedTypes: System.Collections.Generic.IEnumerable<System.Type>;
        Modules: System.Collections.Generic.IEnumerable<System.Reflection.Module>;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        AddResourceFile(name: string, fileName: string): void;
        AddResourceFile(name: string, fileName: string, attribute: System.Reflection.ResourceAttributes): void;
        static DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess): System.Reflection.Emit.AssemblyBuilder;
        static DefineDynamicAssembly(name: System.Reflection.AssemblyName, access: System.Reflection.Emit.AssemblyBuilderAccess, assemblyAttributes: any): System.Reflection.Emit.AssemblyBuilder;
        DefineDynamicModule(name: string): System.Reflection.Emit.ModuleBuilder;
        DefineDynamicModule(name: string, emitSymbolInfo: boolean): System.Reflection.Emit.ModuleBuilder;
        DefineDynamicModule(name: string, fileName: string): System.Reflection.Emit.ModuleBuilder;
        DefineDynamicModule(name: string, fileName: string, emitSymbolInfo: boolean): System.Reflection.Emit.ModuleBuilder;
        DefineResource(name: string, description: string, fileName: string): System.Resources.IResourceWriter;
        DefineResource(name: string, description: string, fileName: string, attribute: System.Reflection.ResourceAttributes): System.Resources.IResourceWriter;
        DefineUnmanagedResource(resource: Byte[]): void;
        DefineUnmanagedResource(resourceFileName: string): void;
        DefineVersionInfoResource(): void;
        DefineVersionInfoResource(product: string, productVersion: string, company: string, copyright: string, trademark: string): void;
        GetDynamicModule(name: string): System.Reflection.Emit.ModuleBuilder;
        GetExportedTypes(): System.Type[];
        GetFile(name: string): System.IO.FileStream;
        GetFiles(getResourceModules: boolean): System.IO.FileStream[];
        GetManifestResourceInfo(resourceName: string): System.Reflection.ManifestResourceInfo;
        GetManifestResourceNames(): string[];
        GetManifestResourceStream(name: string): System.IO.Stream;
        GetManifestResourceStream(type: System.Type, name: string): System.IO.Stream;
        Save(assemblyFileName: string, portableExecutableKind: System.Reflection.PortableExecutableKinds, imageFileMachine: System.Reflection.ImageFileMachine): void;
        Save(assemblyFileName: string): void;
        SetEntryPoint(entryMethod: System.Reflection.MethodInfo): void;
        SetEntryPoint(entryMethod: System.Reflection.MethodInfo, fileKind: System.Reflection.Emit.PEFileKinds): void;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        GetType(name: string, throwOnError: boolean, ignoreCase: boolean): System.Type;
        GetModule(name: string): System.Reflection.Module;
        GetModules(getResourceModules: boolean): System.Reflection.Module[];
        GetName(copiedName: boolean): System.Reflection.AssemblyName;
        GetReferencedAssemblies(): System.Reflection.AssemblyName[];
        GetLoadedModules(getResourceModules: boolean): System.Reflection.Module[];
        GetSatelliteAssembly(culture: System.Globalization.CultureInfo): System.Reflection.Assembly;
        GetSatelliteAssembly(culture: System.Globalization.CultureInfo, version: System.Version): System.Reflection.Assembly;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetFiles(): System.IO.FileStream[];
        GetTypes(): System.Type[];
        GetType(name: string, throwOnError: boolean): System.Type;
        GetType(name: string): System.Type;
        GetName(): System.Reflection.AssemblyName;
        LoadModule(moduleName: string, rawModule: Byte[]): System.Reflection.Module;
        LoadModule(moduleName: string, rawModule: Byte[], rawSymbolStore: Byte[]): System.Reflection.Module;
        CreateInstance(typeName: string): any;
        CreateInstance(typeName: string, ignoreCase: boolean): any;
        CreateInstance(typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): any;
        GetLoadedModules(): System.Reflection.Module[];
        GetModules(): System.Reflection.Module[];
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetForwardedTypes(): System.Type[];
        GetType(): System.Type;
      }
      export enum AssemblyBuilderAccess {
        Run = 1,
        Save = 2,
        RunAndSave = 3,
        ReflectionOnly = 6,
        RunAndCollect = 9,
      }
      export class ConstructorBuilder {
        CallingConvention: System.Reflection.CallingConventions;
        InitLocals: boolean;
        MethodHandle: System.RuntimeMethodHandle;
        Attributes: System.Reflection.MethodAttributes;
        ReflectedType: System.Type;
        DeclaringType: System.Type;
        ReturnType: System.Type;
        Name: string;
        Signature: string;
        Module: System.Reflection.Module;
        MemberType: System.Reflection.MemberTypes;
        MethodImplementationFlags: System.Reflection.MethodImplAttributes;
        IsAbstract: boolean;
        IsConstructor: boolean;
        IsFinal: boolean;
        IsHideBySig: boolean;
        IsSpecialName: boolean;
        IsStatic: boolean;
        IsVirtual: boolean;
        IsAssembly: boolean;
        IsFamily: boolean;
        IsFamilyAndAssembly: boolean;
        IsFamilyOrAssembly: boolean;
        IsPrivate: boolean;
        IsPublic: boolean;
        IsConstructedGenericMethod: boolean;
        IsGenericMethod: boolean;
        IsGenericMethodDefinition: boolean;
        ContainsGenericParameters: boolean;
        IsSecurityCritical: boolean;
        IsSecuritySafeCritical: boolean;
        IsSecurityTransparent: boolean;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        MetadataToken: number;
        GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;
        GetParameters(): System.Reflection.ParameterInfo[];
        Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
        Invoke(invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
        AddDeclarativeSecurity(action: System.Security.Permissions.SecurityAction, pset: System.Security.PermissionSet): void;
        DefineParameter(iSequence: number, attributes: System.Reflection.ParameterAttributes, strParamName: string): System.Reflection.Emit.ParameterBuilder;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetILGenerator(): System.Reflection.Emit.ILGenerator;
        GetILGenerator(streamSize: number): System.Reflection.Emit.ILGenerator;
        SetMethodBody(il: Byte[], maxStack: number, localSignature: Byte[], exceptionHandlers: System.Collections.Generic.IEnumerable<System.Reflection.Emit.ExceptionHandler>, tokenFixups: System.Collections.Generic.IEnumerable<number>): void;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        SetImplementationFlags(attributes: System.Reflection.MethodImplAttributes): void;
        GetModule(): System.Reflection.Module;
        GetToken(): System.Reflection.Emit.MethodToken;
        SetSymCustomAttribute(name: string, data: Byte[]): void;
        ToString(): string;
        Invoke(parameters: any[]): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetMethodBody(): System.Reflection.MethodBody;
        GetGenericArguments(): System.Type[];
        Invoke(obj: any, parameters: any[]): any;
        HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetType(): System.Type;
      }
      export class CustomAttributeBuilder {
        constructor(con: System.Reflection.ConstructorInfo, constructorArgs: any[]);
        constructor(con: System.Reflection.ConstructorInfo, constructorArgs: any[], namedFields: System.Reflection.FieldInfo[], fieldValues: any[]);
        constructor(con: System.Reflection.ConstructorInfo, constructorArgs: any[], namedProperties: System.Reflection.PropertyInfo[], propertyValues: any[]);
        constructor(con: System.Reflection.ConstructorInfo, constructorArgs: any[], namedProperties: System.Reflection.PropertyInfo[], propertyValues: any[], namedFields: System.Reflection.FieldInfo[], fieldValues: any[]);
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DynamicILInfo {
        DynamicMethod: System.Reflection.Emit.DynamicMethod;
        GetTokenFor(signature: Byte[]): number;
        GetTokenFor(method: System.Reflection.Emit.DynamicMethod): number;
        GetTokenFor(field: System.RuntimeFieldHandle): number;
        GetTokenFor(method: System.RuntimeMethodHandle): number;
        GetTokenFor(type: System.RuntimeTypeHandle): number;
        GetTokenFor(literal: string): number;
        GetTokenFor(method: System.RuntimeMethodHandle, contextType: System.RuntimeTypeHandle): number;
        GetTokenFor(field: System.RuntimeFieldHandle, contextType: System.RuntimeTypeHandle): number;
        SetCode(code: Byte[], maxStackSize: number): void;
        SetExceptions(exceptions: Byte[]): void;
        SetLocalSignature(localSignature: Byte[]): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DynamicMethod {
        constructor(name: string, returnType: System.Type, parameterTypes: System.Type[], m: System.Reflection.Module);
        constructor(name: string, returnType: System.Type, parameterTypes: System.Type[], owner: System.Type);
        constructor(name: string, returnType: System.Type, parameterTypes: System.Type[], m: System.Reflection.Module, skipVisibility: boolean);
        constructor(name: string, returnType: System.Type, parameterTypes: System.Type[], owner: System.Type, skipVisibility: boolean);
        constructor(name: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[], owner: System.Type, skipVisibility: boolean);
        constructor(name: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[], m: System.Reflection.Module, skipVisibility: boolean);
        constructor(name: string, returnType: System.Type, parameterTypes: System.Type[]);
        constructor(name: string, returnType: System.Type, parameterTypes: System.Type[], restrictedSkipVisibility: boolean);
        Attributes: System.Reflection.MethodAttributes;
        CallingConvention: System.Reflection.CallingConventions;
        DeclaringType: System.Type;
        InitLocals: boolean;
        MethodHandle: System.RuntimeMethodHandle;
        Module: System.Reflection.Module;
        Name: string;
        ReflectedType: System.Type;
        ReturnParameter: System.Reflection.ParameterInfo;
        ReturnType: System.Type;
        ReturnTypeCustomAttributes: System.Reflection.ICustomAttributeProvider;
        MemberType: System.Reflection.MemberTypes;
        MethodImplementationFlags: System.Reflection.MethodImplAttributes;
        IsAbstract: boolean;
        IsConstructor: boolean;
        IsFinal: boolean;
        IsHideBySig: boolean;
        IsSpecialName: boolean;
        IsStatic: boolean;
        IsVirtual: boolean;
        IsAssembly: boolean;
        IsFamily: boolean;
        IsFamilyAndAssembly: boolean;
        IsFamilyOrAssembly: boolean;
        IsPrivate: boolean;
        IsPublic: boolean;
        IsConstructedGenericMethod: boolean;
        IsGenericMethod: boolean;
        IsGenericMethodDefinition: boolean;
        ContainsGenericParameters: boolean;
        IsSecurityCritical: boolean;
        IsSecuritySafeCritical: boolean;
        IsSecurityTransparent: boolean;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        MetadataToken: number;
        CreateDelegate(delegateType: System.Type): System.Delegate;
        CreateDelegate(delegateType: System.Type, target: any): System.Delegate;
        DefineParameter(position: number, attributes: System.Reflection.ParameterAttributes, parameterName: string): System.Reflection.Emit.ParameterBuilder;
        GetBaseDefinition(): System.Reflection.MethodInfo;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetDynamicILInfo(): System.Reflection.Emit.DynamicILInfo;
        GetILGenerator(): System.Reflection.Emit.ILGenerator;
        GetILGenerator(streamSize: number): System.Reflection.Emit.ILGenerator;
        GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;
        GetParameters(): System.Reflection.ParameterInfo[];
        Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        ToString(): string;
        GetGenericArguments(): System.Type[];
        GetGenericMethodDefinition(): System.Reflection.MethodInfo;
        MakeGenericMethod(...typeArguments: System.Type[]): System.Reflection.MethodInfo;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetMethodBody(): System.Reflection.MethodBody;
        Invoke(obj: any, parameters: any[]): any;
        HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetType(): System.Type;
      }
      export class EnumBuilder {
        Assembly: System.Reflection.Assembly;
        AssemblyQualifiedName: string;
        BaseType: System.Type;
        DeclaringType: System.Type;
        FullName: string;
        GUID: System.Guid;
        Module: System.Reflection.Module;
        Name: string;
        Namespace: string;
        ReflectedType: System.Type;
        TypeHandle: System.RuntimeTypeHandle;
        TypeToken: System.Reflection.Emit.TypeToken;
        UnderlyingField: System.Reflection.Emit.FieldBuilder;
        UnderlyingSystemType: System.Type;
        IsConstructedGenericType: boolean;
        IsTypeDefinition: boolean;
        GenericTypeParameters: System.Type[];
        DeclaredConstructors: System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo>;
        DeclaredEvents: System.Collections.Generic.IEnumerable<System.Reflection.EventInfo>;
        DeclaredFields: System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo>;
        DeclaredMembers: System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo>;
        DeclaredMethods: System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
        DeclaredNestedTypes: System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>;
        DeclaredProperties: System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>;
        ImplementedInterfaces: System.Collections.Generic.IEnumerable<System.Type>;
        IsSerializable: boolean;
        ContainsGenericParameters: boolean;
        IsVisible: boolean;
        MemberType: System.Reflection.MemberTypes;
        IsNested: boolean;
        DeclaringMethod: System.Reflection.MethodBase;
        IsArray: boolean;
        IsByRef: boolean;
        IsPointer: boolean;
        IsGenericParameter: boolean;
        IsGenericTypeParameter: boolean;
        IsGenericMethodParameter: boolean;
        IsGenericType: boolean;
        IsGenericTypeDefinition: boolean;
        IsSZArray: boolean;
        IsVariableBoundArray: boolean;
        IsByRefLike: boolean;
        HasElementType: boolean;
        GenericTypeArguments: System.Type[];
        GenericParameterPosition: number;
        GenericParameterAttributes: System.Reflection.GenericParameterAttributes;
        Attributes: System.Reflection.TypeAttributes;
        IsAbstract: boolean;
        IsImport: boolean;
        IsSealed: boolean;
        IsSpecialName: boolean;
        IsClass: boolean;
        IsNestedAssembly: boolean;
        IsNestedFamANDAssem: boolean;
        IsNestedFamily: boolean;
        IsNestedFamORAssem: boolean;
        IsNestedPrivate: boolean;
        IsNestedPublic: boolean;
        IsNotPublic: boolean;
        IsPublic: boolean;
        IsAutoLayout: boolean;
        IsExplicitLayout: boolean;
        IsLayoutSequential: boolean;
        IsAnsiClass: boolean;
        IsAutoClass: boolean;
        IsUnicodeClass: boolean;
        IsCOMObject: boolean;
        IsContextful: boolean;
        IsCollectible: boolean;
        IsEnum: boolean;
        IsMarshalByRef: boolean;
        IsPrimitive: boolean;
        IsValueType: boolean;
        IsSignatureType: boolean;
        IsSecurityCritical: boolean;
        IsSecuritySafeCritical: boolean;
        IsSecurityTransparent: boolean;
        StructLayoutAttribute: any; // System.Runtime.InteropServices.StructLayoutAttribute
        TypeInitializer: System.Reflection.ConstructorInfo;
        IsInterface: boolean;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        MetadataToken: number;
        CreateType(): System.Type;
        CreateTypeInfo(): System.Reflection.TypeInfo;
        GetEnumUnderlyingType(): System.Type;
        DefineLiteral(literalName: string, literalValue: any): System.Reflection.Emit.FieldBuilder;
        GetConstructors(bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetElementType(): System.Type;
        GetEvent(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo;
        GetEvents(): System.Reflection.EventInfo[];
        GetEvents(bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];
        GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
        GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
        GetInterface(name: string, ignoreCase: boolean): System.Type;
        GetInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;
        GetInterfaces(): System.Type[];
        GetMember(name: string, type: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
        GetNestedType(name: string, bindingAttr: System.Reflection.BindingFlags): System.Type;
        GetNestedTypes(bindingAttr: System.Reflection.BindingFlags): System.Type[];
        GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], modifiers: System.Reflection.ParameterModifier[], culture: System.Globalization.CultureInfo, namedParameters: string[]): any;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        MakeArrayType(): System.Type;
        MakeArrayType(rank: number): System.Type;
        MakeByRefType(): System.Type;
        MakePointerType(): System.Type;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        IsAssignableFrom(typeInfo: System.Reflection.TypeInfo): boolean;
        AsType(): System.Type;
        GetDeclaredEvent(name: string): System.Reflection.EventInfo;
        GetDeclaredField(name: string): System.Reflection.FieldInfo;
        GetDeclaredMethod(name: string): System.Reflection.MethodInfo;
        GetDeclaredNestedType(name: string): System.Reflection.TypeInfo;
        GetDeclaredProperty(name: string): System.Reflection.PropertyInfo;
        GetDeclaredMethods(name: string): System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
        IsEnumDefined(value: any): boolean;
        GetEnumName(value: any): string;
        GetEnumNames(): string[];
        FindInterfaces(filter: ((m: System.Type, filterCriteria: any) => boolean), filterCriteria: any): System.Type[];
        FindMembers(memberType: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags, filter: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean), filterCriteria: any): System.Reflection.MemberInfo[];
        IsSubclassOf(c: System.Type): boolean;
        IsAssignableFrom(c: System.Type): boolean;
        GetType(): System.Type;
        GetArrayRank(): number;
        GetGenericTypeDefinition(): System.Type;
        GetGenericArguments(): System.Type[];
        GetGenericParameterConstraints(): System.Type[];
        GetConstructor(types: System.Type[]): System.Reflection.ConstructorInfo;
        GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
        GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
        GetConstructors(): System.Reflection.ConstructorInfo[];
        GetEvent(name: string): System.Reflection.EventInfo;
        GetField(name: string): System.Reflection.FieldInfo;
        GetFields(): System.Reflection.FieldInfo[];
        GetMember(name: string): System.Reflection.MemberInfo[];
        GetMember(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMembers(): System.Reflection.MemberInfo[];
        GetMethod(name: string): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo;
        GetMethod(name: string, types: System.Type[]): System.Reflection.MethodInfo;
        GetMethod(name: string, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, types: System.Type[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethods(): System.Reflection.MethodInfo[];
        GetNestedType(name: string): System.Type;
        GetNestedTypes(): System.Type[];
        GetProperty(name: string): System.Reflection.PropertyInfo;
        GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type): System.Reflection.PropertyInfo;
        GetProperty(name: string, types: System.Type[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type, types: System.Type[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
        GetProperties(): System.Reflection.PropertyInfo[];
        GetDefaultMembers(): System.Reflection.MemberInfo[];
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[]): any;
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], culture: System.Globalization.CultureInfo): any;
        GetInterface(name: string): System.Type;
        IsInstanceOfType(o: any): boolean;
        IsEquivalentTo(other: System.Type): boolean;
        GetEnumValues(): System.Array;
        MakeGenericType(...typeArguments: System.Type[]): System.Type;
        ToString(): string;
        Equals(o: any): boolean;
        GetHashCode(): number;
        Equals(o: System.Type): boolean;
        HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetType(): System.Type;
      }
      export class EventBuilder {
        AddOtherMethod(mdBuilder: System.Reflection.Emit.MethodBuilder): void;
        GetEventToken(): System.Reflection.Emit.EventToken;
        SetAddOnMethod(mdBuilder: System.Reflection.Emit.MethodBuilder): void;
        SetRaiseMethod(mdBuilder: System.Reflection.Emit.MethodBuilder): void;
        SetRemoveOnMethod(mdBuilder: System.Reflection.Emit.MethodBuilder): void;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class EventToken {
        Token: number;
        static Empty: System.Reflection.Emit.EventToken;
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.EventToken): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class FieldBuilder {
        Attributes: System.Reflection.FieldAttributes;
        DeclaringType: System.Type;
        FieldHandle: System.RuntimeFieldHandle;
        FieldType: System.Type;
        Name: string;
        ReflectedType: System.Type;
        MetadataToken: number;
        Module: System.Reflection.Module;
        MemberType: System.Reflection.MemberTypes;
        IsInitOnly: boolean;
        IsLiteral: boolean;
        IsNotSerialized: boolean;
        IsPinvokeImpl: boolean;
        IsSpecialName: boolean;
        IsStatic: boolean;
        IsAssembly: boolean;
        IsFamily: boolean;
        IsFamilyAndAssembly: boolean;
        IsFamilyOrAssembly: boolean;
        IsPrivate: boolean;
        IsPublic: boolean;
        IsSecurityCritical: boolean;
        IsSecuritySafeCritical: boolean;
        IsSecurityTransparent: boolean;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetToken(): System.Reflection.Emit.FieldToken;
        GetValue(obj: any): any;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        SetConstant(defaultValue: any): void;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        SetMarshal(unmanagedMarshal: System.Reflection.Emit.UnmanagedMarshal): void;
        SetOffset(iOffset: number): void;
        SetValue(obj: any, val: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, culture: System.Globalization.CultureInfo): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        SetValue(obj: any, value: any): void;
        SetValueDirect(obj: System.TypedReference, value: any): void;
        GetValueDirect(obj: System.TypedReference): any;
        GetRawConstantValue(): any;
        GetOptionalCustomModifiers(): System.Type[];
        GetRequiredCustomModifiers(): System.Type[];
        HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetType(): System.Type;
        ToString(): string;
      }
      export class FieldToken {
        Token: number;
        static Empty: System.Reflection.Emit.FieldToken;
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.FieldToken): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum FlowControl {
        Branch = 0,
        Break = 1,
        Call = 2,
        Cond_Branch = 3,
        Meta = 4,
        Next = 5,
        Phi = 6,
        Return = 7,
        Throw = 8,
      }
      export class GenericTypeParameterBuilder {
        UnderlyingSystemType: System.Type;
        Assembly: System.Reflection.Assembly;
        AssemblyQualifiedName: string;
        BaseType: System.Type;
        FullName: string;
        GUID: System.Guid;
        Name: string;
        Namespace: string;
        Module: System.Reflection.Module;
        DeclaringType: System.Type;
        ReflectedType: System.Type;
        TypeHandle: System.RuntimeTypeHandle;
        ContainsGenericParameters: boolean;
        IsGenericParameter: boolean;
        IsGenericType: boolean;
        IsGenericTypeDefinition: boolean;
        GenericParameterAttributes: System.Reflection.GenericParameterAttributes;
        GenericParameterPosition: number;
        DeclaringMethod: System.Reflection.MethodBase;
        GenericTypeParameters: System.Type[];
        DeclaredConstructors: System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo>;
        DeclaredEvents: System.Collections.Generic.IEnumerable<System.Reflection.EventInfo>;
        DeclaredFields: System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo>;
        DeclaredMembers: System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo>;
        DeclaredMethods: System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
        DeclaredNestedTypes: System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>;
        DeclaredProperties: System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>;
        ImplementedInterfaces: System.Collections.Generic.IEnumerable<System.Type>;
        IsSerializable: boolean;
        IsVisible: boolean;
        MemberType: System.Reflection.MemberTypes;
        IsNested: boolean;
        IsTypeDefinition: boolean;
        IsArray: boolean;
        IsByRef: boolean;
        IsPointer: boolean;
        IsConstructedGenericType: boolean;
        IsGenericTypeParameter: boolean;
        IsGenericMethodParameter: boolean;
        IsSZArray: boolean;
        IsVariableBoundArray: boolean;
        IsByRefLike: boolean;
        HasElementType: boolean;
        GenericTypeArguments: System.Type[];
        Attributes: System.Reflection.TypeAttributes;
        IsAbstract: boolean;
        IsImport: boolean;
        IsSealed: boolean;
        IsSpecialName: boolean;
        IsClass: boolean;
        IsNestedAssembly: boolean;
        IsNestedFamANDAssem: boolean;
        IsNestedFamily: boolean;
        IsNestedFamORAssem: boolean;
        IsNestedPrivate: boolean;
        IsNestedPublic: boolean;
        IsNotPublic: boolean;
        IsPublic: boolean;
        IsAutoLayout: boolean;
        IsExplicitLayout: boolean;
        IsLayoutSequential: boolean;
        IsAnsiClass: boolean;
        IsAutoClass: boolean;
        IsUnicodeClass: boolean;
        IsCOMObject: boolean;
        IsContextful: boolean;
        IsCollectible: boolean;
        IsEnum: boolean;
        IsMarshalByRef: boolean;
        IsPrimitive: boolean;
        IsValueType: boolean;
        IsSignatureType: boolean;
        IsSecurityCritical: boolean;
        IsSecuritySafeCritical: boolean;
        IsSecurityTransparent: boolean;
        StructLayoutAttribute: any; // System.Runtime.InteropServices.StructLayoutAttribute
        TypeInitializer: System.Reflection.ConstructorInfo;
        IsInterface: boolean;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        MetadataToken: number;
        SetBaseTypeConstraint(baseTypeConstraint: System.Type): void;
        SetInterfaceConstraints(...interfaceConstraints: System.Type[]): void;
        SetGenericParameterAttributes(genericParameterAttributes: System.Reflection.GenericParameterAttributes): void;
        IsSubclassOf(c: System.Type): boolean;
        GetConstructors(bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];
        GetEvent(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo;
        GetEvents(): System.Reflection.EventInfo[];
        GetEvents(bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];
        GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
        GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
        GetInterface(name: string, ignoreCase: boolean): System.Type;
        GetInterfaces(): System.Type[];
        GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMember(name: string, type: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
        GetNestedType(name: string, bindingAttr: System.Reflection.BindingFlags): System.Type;
        GetNestedTypes(bindingAttr: System.Reflection.BindingFlags): System.Type[];
        GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];
        IsAssignableFrom(c: System.Type): boolean;
        IsAssignableFrom(typeInfo: System.Reflection.TypeInfo): boolean;
        IsInstanceOfType(o: any): boolean;
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], modifiers: System.Reflection.ParameterModifier[], culture: System.Globalization.CultureInfo, namedParameters: string[]): any;
        GetElementType(): System.Type;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;
        GetGenericArguments(): System.Type[];
        GetGenericTypeDefinition(): System.Type;
        GetGenericParameterConstraints(): System.Type[];
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        ToString(): string;
        Equals(o: any): boolean;
        GetHashCode(): number;
        MakeArrayType(): System.Type;
        MakeArrayType(rank: number): System.Type;
        MakeByRefType(): System.Type;
        MakeGenericType(...typeArguments: System.Type[]): System.Type;
        MakePointerType(): System.Type;
        AsType(): System.Type;
        GetDeclaredEvent(name: string): System.Reflection.EventInfo;
        GetDeclaredField(name: string): System.Reflection.FieldInfo;
        GetDeclaredMethod(name: string): System.Reflection.MethodInfo;
        GetDeclaredNestedType(name: string): System.Reflection.TypeInfo;
        GetDeclaredProperty(name: string): System.Reflection.PropertyInfo;
        GetDeclaredMethods(name: string): System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
        IsEnumDefined(value: any): boolean;
        GetEnumName(value: any): string;
        GetEnumNames(): string[];
        FindInterfaces(filter: ((m: System.Type, filterCriteria: any) => boolean), filterCriteria: any): System.Type[];
        FindMembers(memberType: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags, filter: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean), filterCriteria: any): System.Reflection.MemberInfo[];
        GetType(): System.Type;
        GetArrayRank(): number;
        GetConstructor(types: System.Type[]): System.Reflection.ConstructorInfo;
        GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
        GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
        GetConstructors(): System.Reflection.ConstructorInfo[];
        GetEvent(name: string): System.Reflection.EventInfo;
        GetField(name: string): System.Reflection.FieldInfo;
        GetFields(): System.Reflection.FieldInfo[];
        GetMember(name: string): System.Reflection.MemberInfo[];
        GetMember(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMembers(): System.Reflection.MemberInfo[];
        GetMethod(name: string): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo;
        GetMethod(name: string, types: System.Type[]): System.Reflection.MethodInfo;
        GetMethod(name: string, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, types: System.Type[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethods(): System.Reflection.MethodInfo[];
        GetNestedType(name: string): System.Type;
        GetNestedTypes(): System.Type[];
        GetProperty(name: string): System.Reflection.PropertyInfo;
        GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type): System.Reflection.PropertyInfo;
        GetProperty(name: string, types: System.Type[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type, types: System.Type[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
        GetProperties(): System.Reflection.PropertyInfo[];
        GetDefaultMembers(): System.Reflection.MemberInfo[];
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[]): any;
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], culture: System.Globalization.CultureInfo): any;
        GetInterface(name: string): System.Type;
        IsEquivalentTo(other: System.Type): boolean;
        GetEnumUnderlyingType(): System.Type;
        GetEnumValues(): System.Array;
        Equals(o: System.Type): boolean;
        HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetType(): System.Type;
      }
      export class ILGenerator {
        ILOffset: number;
        BeginCatchBlock(exceptionType: System.Type): void;
        BeginExceptFilterBlock(): void;
        BeginExceptionBlock(): System.Reflection.Emit.Label;
        BeginFaultBlock(): void;
        BeginFinallyBlock(): void;
        BeginScope(): void;
        DeclareLocal(localType: System.Type): System.Reflection.Emit.LocalBuilder;
        DeclareLocal(localType: System.Type, pinned: boolean): System.Reflection.Emit.LocalBuilder;
        DefineLabel(): System.Reflection.Emit.Label;
        Emit(opcode: System.Reflection.Emit.OpCode): void;
        Emit(opcode: System.Reflection.Emit.OpCode, arg: Byte): void;
        Emit(opcode: System.Reflection.Emit.OpCode, con: System.Reflection.ConstructorInfo): void;
        Emit(opcode: System.Reflection.Emit.OpCode, arg: number): void;
        Emit(opcode: System.Reflection.Emit.OpCode, field: System.Reflection.FieldInfo): void;
        Emit(opcode: System.Reflection.Emit.OpCode, arg: number): void;
        Emit(opcode: System.Reflection.Emit.OpCode, arg: number): void;
        Emit(opcode: System.Reflection.Emit.OpCode, arg: number): void;
        Emit(opcode: System.Reflection.Emit.OpCode, label: System.Reflection.Emit.Label): void;
        Emit(opcode: System.Reflection.Emit.OpCode, labels: System.Reflection.Emit.Label[]): void;
        Emit(opcode: System.Reflection.Emit.OpCode, local: System.Reflection.Emit.LocalBuilder): void;
        Emit(opcode: System.Reflection.Emit.OpCode, meth: System.Reflection.MethodInfo): void;
        Emit(opcode: System.Reflection.Emit.OpCode, arg: System.SByte): void;
        Emit(opcode: System.Reflection.Emit.OpCode, signature: System.Reflection.Emit.SignatureHelper): void;
        Emit(opcode: System.Reflection.Emit.OpCode, arg: number): void;
        Emit(opcode: System.Reflection.Emit.OpCode, str: string): void;
        Emit(opcode: System.Reflection.Emit.OpCode, cls: System.Type): void;
        EmitCall(opcode: System.Reflection.Emit.OpCode, methodInfo: System.Reflection.MethodInfo, optionalParameterTypes: System.Type[]): void;
        EmitCalli(opcode: System.Reflection.Emit.OpCode, unmanagedCallConv: System.Runtime.InteropServices.CallingConvention, returnType: System.Type, parameterTypes: System.Type[]): void;
        EmitCalli(opcode: System.Reflection.Emit.OpCode, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[], optionalParameterTypes: System.Type[]): void;
        EmitWriteLine(fld: System.Reflection.FieldInfo): void;
        EmitWriteLine(localBuilder: System.Reflection.Emit.LocalBuilder): void;
        EmitWriteLine(value: string): void;
        EndExceptionBlock(): void;
        EndScope(): void;
        MarkLabel(loc: System.Reflection.Emit.Label): void;
        MarkSequencePoint(document: System.Diagnostics.SymbolStore.ISymbolDocumentWriter, startLine: number, startColumn: number, endLine: number, endColumn: number): void;
        ThrowException(excType: System.Type): void;
        UsingNamespace(usingNamespace: string): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Label {
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.Label): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class LocalBuilder {
        LocalType: System.Type;
        IsPinned: boolean;
        LocalIndex: number;
        SetLocalSymInfo(name: string, startOffset: number, endOffset: number): void;
        SetLocalSymInfo(name: string): void;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MethodBuilder {
        ContainsGenericParameters: boolean;
        InitLocals: boolean;
        MethodHandle: System.RuntimeMethodHandle;
        ReturnType: System.Type;
        ReflectedType: System.Type;
        DeclaringType: System.Type;
        Name: string;
        Attributes: System.Reflection.MethodAttributes;
        ReturnTypeCustomAttributes: System.Reflection.ICustomAttributeProvider;
        CallingConvention: System.Reflection.CallingConventions;
        Signature: string;
        IsGenericMethodDefinition: boolean;
        IsGenericMethod: boolean;
        Module: System.Reflection.Module;
        ReturnParameter: System.Reflection.ParameterInfo;
        MemberType: System.Reflection.MemberTypes;
        MethodImplementationFlags: System.Reflection.MethodImplAttributes;
        IsAbstract: boolean;
        IsConstructor: boolean;
        IsFinal: boolean;
        IsHideBySig: boolean;
        IsSpecialName: boolean;
        IsStatic: boolean;
        IsVirtual: boolean;
        IsAssembly: boolean;
        IsFamily: boolean;
        IsFamilyAndAssembly: boolean;
        IsFamilyOrAssembly: boolean;
        IsPrivate: boolean;
        IsPublic: boolean;
        IsConstructedGenericMethod: boolean;
        IsSecurityCritical: boolean;
        IsSecuritySafeCritical: boolean;
        IsSecurityTransparent: boolean;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        MetadataToken: number;
        GetToken(): System.Reflection.Emit.MethodToken;
        GetBaseDefinition(): System.Reflection.MethodInfo;
        GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;
        GetParameters(): System.Reflection.ParameterInfo[];
        GetModule(): System.Reflection.Module;
        CreateMethodBody(il: Byte[], count: number): void;
        SetMethodBody(il: Byte[], maxStack: number, localSignature: Byte[], exceptionHandlers: System.Collections.Generic.IEnumerable<System.Reflection.Emit.ExceptionHandler>, tokenFixups: System.Collections.Generic.IEnumerable<number>): void;
        Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetILGenerator(): System.Reflection.Emit.ILGenerator;
        GetILGenerator(size: number): System.Reflection.Emit.ILGenerator;
        DefineParameter(position: number, attributes: System.Reflection.ParameterAttributes, strParamName: string): System.Reflection.Emit.ParameterBuilder;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        SetImplementationFlags(attributes: System.Reflection.MethodImplAttributes): void;
        AddDeclarativeSecurity(action: System.Security.Permissions.SecurityAction, pset: System.Security.PermissionSet): void;
        SetMarshal(unmanagedMarshal: System.Reflection.Emit.UnmanagedMarshal): void;
        SetSymCustomAttribute(name: string, data: Byte[]): void;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        MakeGenericMethod(...typeArguments: System.Type[]): System.Reflection.MethodInfo;
        GetGenericMethodDefinition(): System.Reflection.MethodInfo;
        GetGenericArguments(): System.Type[];
        DefineGenericParameters(...names: string[]): System.Reflection.Emit.GenericTypeParameterBuilder[];
        SetReturnType(returnType: System.Type): void;
        SetParameters(...parameterTypes: System.Type[]): void;
        SetSignature(returnType: System.Type, returnTypeRequiredCustomModifiers: System.Type[], returnTypeOptionalCustomModifiers: System.Type[], parameterTypes: System.Type[], parameterTypeRequiredCustomModifiers: System.Type[][], parameterTypeOptionalCustomModifiers: System.Type[][]): void;
        CreateDelegate(delegateType: System.Type): System.Delegate;
        CreateDelegate(delegateType: System.Type, target: any): System.Delegate;
        GetMethodBody(): System.Reflection.MethodBody;
        Invoke(obj: any, parameters: any[]): any;
        HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetType(): System.Type;
      }
      export class MethodRental {
        static JitImmediate: number;
        static JitOnDemand: number;
        static SwapMethodBody(cls: System.Type, methodtoken: number, rgIL: System.IntPtr, methodSize: number, flags: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MethodToken {
        Token: number;
        static Empty: System.Reflection.Emit.MethodToken;
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.MethodToken): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ModuleBuilder {
        FullyQualifiedName: string;
        Assembly: System.Reflection.Assembly;
        Name: string;
        ScopeName: string;
        ModuleVersionId: System.Guid;
        MetadataToken: number;
        MDStreamVersion: number;
        ModuleHandle: System.ModuleHandle;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        IsTransient(): boolean;
        CreateGlobalFunctions(): void;
        DefineInitializedData(name: string, data: Byte[], attributes: System.Reflection.FieldAttributes): System.Reflection.Emit.FieldBuilder;
        DefineUninitializedData(name: string, size: number, attributes: System.Reflection.FieldAttributes): System.Reflection.Emit.FieldBuilder;
        DefineGlobalMethod(name: string, attributes: System.Reflection.MethodAttributes, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.Emit.MethodBuilder;
        DefineGlobalMethod(name: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.Emit.MethodBuilder;
        DefineGlobalMethod(name: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, requiredReturnTypeCustomModifiers: System.Type[], optionalReturnTypeCustomModifiers: System.Type[], parameterTypes: System.Type[], requiredParameterTypeCustomModifiers: System.Type[][], optionalParameterTypeCustomModifiers: System.Type[][]): System.Reflection.Emit.MethodBuilder;
        DefinePInvokeMethod(name: string, dllName: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[], nativeCallConv: System.Runtime.InteropServices.CallingConvention, nativeCharSet: System.Runtime.InteropServices.CharSet): System.Reflection.Emit.MethodBuilder;
        DefinePInvokeMethod(name: string, dllName: string, entryName: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[], nativeCallConv: System.Runtime.InteropServices.CallingConvention, nativeCharSet: System.Runtime.InteropServices.CharSet): System.Reflection.Emit.MethodBuilder;
        DefineType(name: string): System.Reflection.Emit.TypeBuilder;
        DefineType(name: string, attr: System.Reflection.TypeAttributes): System.Reflection.Emit.TypeBuilder;
        DefineType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type): System.Reflection.Emit.TypeBuilder;
        DefineType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type, interfaces: System.Type[]): System.Reflection.Emit.TypeBuilder;
        DefineType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type, typesize: number): System.Reflection.Emit.TypeBuilder;
        DefineType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type, packsize: System.Reflection.Emit.PackingSize): System.Reflection.Emit.TypeBuilder;
        DefineType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type, packingSize: System.Reflection.Emit.PackingSize, typesize: number): System.Reflection.Emit.TypeBuilder;
        GetArrayMethod(arrayClass: System.Type, methodName: string, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.MethodInfo;
        DefineEnum(name: string, visibility: System.Reflection.TypeAttributes, underlyingType: System.Type): System.Reflection.Emit.EnumBuilder;
        GetType(className: string): System.Type;
        GetType(className: string, ignoreCase: boolean): System.Type;
        GetType(className: string, throwOnError: boolean, ignoreCase: boolean): System.Type;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        GetSymWriter(): System.Diagnostics.SymbolStore.ISymbolWriter;
        DefineDocument(url: string, language: System.Guid, languageVendor: System.Guid, documentType: System.Guid): System.Diagnostics.SymbolStore.ISymbolDocumentWriter;
        GetTypes(): System.Type[];
        DefineResource(name: string, description: string, attribute: System.Reflection.ResourceAttributes): System.Resources.IResourceWriter;
        DefineResource(name: string, description: string): System.Resources.IResourceWriter;
        DefineUnmanagedResource(resource: Byte[]): void;
        DefineUnmanagedResource(resourceFileName: string): void;
        DefineManifestResource(name: string, stream: System.IO.Stream, attribute: System.Reflection.ResourceAttributes): void;
        SetSymCustomAttribute(name: string, data: Byte[]): void;
        SetUserEntryPoint(entryPoint: System.Reflection.MethodInfo): void;
        GetMethodToken(method: System.Reflection.MethodInfo): System.Reflection.Emit.MethodToken;
        GetMethodToken(method: System.Reflection.MethodInfo, optionalParameterTypes: System.Collections.Generic.IEnumerable<System.Type>): System.Reflection.Emit.MethodToken;
        GetArrayMethodToken(arrayClass: System.Type, methodName: string, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.Emit.MethodToken;
        GetConstructorToken(con: System.Reflection.ConstructorInfo): System.Reflection.Emit.MethodToken;
        GetConstructorToken(constructor: System.Reflection.ConstructorInfo, optionalParameterTypes: System.Collections.Generic.IEnumerable<System.Type>): System.Reflection.Emit.MethodToken;
        GetFieldToken(field: System.Reflection.FieldInfo): System.Reflection.Emit.FieldToken;
        GetSignatureToken(sigBytes: Byte[], sigLength: number): System.Reflection.Emit.SignatureToken;
        GetSignatureToken(sigHelper: System.Reflection.Emit.SignatureHelper): System.Reflection.Emit.SignatureToken;
        GetStringConstant(str: string): System.Reflection.Emit.StringToken;
        GetTypeToken(type: System.Type): System.Reflection.Emit.TypeToken;
        GetTypeToken(name: string): System.Reflection.Emit.TypeToken;
        IsResource(): boolean;
        ResolveField(metadataToken: number, genericTypeArguments: System.Type[], genericMethodArguments: System.Type[]): System.Reflection.FieldInfo;
        ResolveMember(metadataToken: number, genericTypeArguments: System.Type[], genericMethodArguments: System.Type[]): System.Reflection.MemberInfo;
        ResolveMethod(metadataToken: number, genericTypeArguments: System.Type[], genericMethodArguments: System.Type[]): System.Reflection.MethodBase;
        ResolveString(metadataToken: number): string;
        ResolveSignature(metadataToken: number): Byte[];
        ResolveType(metadataToken: number, genericTypeArguments: System.Type[], genericMethodArguments: System.Type[]): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
        GetFields(bindingFlags: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
        GetMethods(bindingFlags: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetMethod(name: string): System.Reflection.MethodInfo;
        GetMethod(name: string, types: System.Type[]): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethods(): System.Reflection.MethodInfo[];
        GetField(name: string): System.Reflection.FieldInfo;
        GetFields(): System.Reflection.FieldInfo[];
        FindTypes(filter: ((m: System.Type, filterCriteria: any) => boolean), filterCriteria: any): System.Type[];
        ResolveField(metadataToken: number): System.Reflection.FieldInfo;
        ResolveMember(metadataToken: number): System.Reflection.MemberInfo;
        ResolveMethod(metadataToken: number): System.Reflection.MethodBase;
        ResolveType(metadataToken: number): System.Type;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        ToString(): string;
        GetSignerCertificate(): System.Security.Cryptography.X509Certificates.X509Certificate;
        GetType(): System.Type;
      }
      export class OpCode {
        Name: string;
        Size: number;
        OpCodeType: System.Reflection.Emit.OpCodeType;
        OperandType: System.Reflection.Emit.OperandType;
        FlowControl: System.Reflection.Emit.FlowControl;
        StackBehaviourPop: System.Reflection.Emit.StackBehaviour;
        StackBehaviourPush: System.Reflection.Emit.StackBehaviour;
        Value: number;
        GetHashCode(): number;
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.OpCode): boolean;
        ToString(): string;
        GetType(): System.Type;
      }
      export class OpCodes {
        static Nop: System.Reflection.Emit.OpCode;
        static Break: System.Reflection.Emit.OpCode;
        static Ldarg_0: System.Reflection.Emit.OpCode;
        static Ldarg_1: System.Reflection.Emit.OpCode;
        static Ldarg_2: System.Reflection.Emit.OpCode;
        static Ldarg_3: System.Reflection.Emit.OpCode;
        static Ldloc_0: System.Reflection.Emit.OpCode;
        static Ldloc_1: System.Reflection.Emit.OpCode;
        static Ldloc_2: System.Reflection.Emit.OpCode;
        static Ldloc_3: System.Reflection.Emit.OpCode;
        static Stloc_0: System.Reflection.Emit.OpCode;
        static Stloc_1: System.Reflection.Emit.OpCode;
        static Stloc_2: System.Reflection.Emit.OpCode;
        static Stloc_3: System.Reflection.Emit.OpCode;
        static Ldarg_S: System.Reflection.Emit.OpCode;
        static Ldarga_S: System.Reflection.Emit.OpCode;
        static Starg_S: System.Reflection.Emit.OpCode;
        static Ldloc_S: System.Reflection.Emit.OpCode;
        static Ldloca_S: System.Reflection.Emit.OpCode;
        static Stloc_S: System.Reflection.Emit.OpCode;
        static Ldnull: System.Reflection.Emit.OpCode;
        static Ldc_I4_M1: System.Reflection.Emit.OpCode;
        static Ldc_I4_0: System.Reflection.Emit.OpCode;
        static Ldc_I4_1: System.Reflection.Emit.OpCode;
        static Ldc_I4_2: System.Reflection.Emit.OpCode;
        static Ldc_I4_3: System.Reflection.Emit.OpCode;
        static Ldc_I4_4: System.Reflection.Emit.OpCode;
        static Ldc_I4_5: System.Reflection.Emit.OpCode;
        static Ldc_I4_6: System.Reflection.Emit.OpCode;
        static Ldc_I4_7: System.Reflection.Emit.OpCode;
        static Ldc_I4_8: System.Reflection.Emit.OpCode;
        static Ldc_I4_S: System.Reflection.Emit.OpCode;
        static Ldc_I4: System.Reflection.Emit.OpCode;
        static Ldc_I8: System.Reflection.Emit.OpCode;
        static Ldc_R4: System.Reflection.Emit.OpCode;
        static Ldc_R8: System.Reflection.Emit.OpCode;
        static Dup: System.Reflection.Emit.OpCode;
        static Pop: System.Reflection.Emit.OpCode;
        static Jmp: System.Reflection.Emit.OpCode;
        static Call: System.Reflection.Emit.OpCode;
        static Calli: System.Reflection.Emit.OpCode;
        static Ret: System.Reflection.Emit.OpCode;
        static Br_S: System.Reflection.Emit.OpCode;
        static Brfalse_S: System.Reflection.Emit.OpCode;
        static Brtrue_S: System.Reflection.Emit.OpCode;
        static Beq_S: System.Reflection.Emit.OpCode;
        static Bge_S: System.Reflection.Emit.OpCode;
        static Bgt_S: System.Reflection.Emit.OpCode;
        static Ble_S: System.Reflection.Emit.OpCode;
        static Blt_S: System.Reflection.Emit.OpCode;
        static Bne_Un_S: System.Reflection.Emit.OpCode;
        static Bge_Un_S: System.Reflection.Emit.OpCode;
        static Bgt_Un_S: System.Reflection.Emit.OpCode;
        static Ble_Un_S: System.Reflection.Emit.OpCode;
        static Blt_Un_S: System.Reflection.Emit.OpCode;
        static Br: System.Reflection.Emit.OpCode;
        static Brfalse: System.Reflection.Emit.OpCode;
        static Brtrue: System.Reflection.Emit.OpCode;
        static Beq: System.Reflection.Emit.OpCode;
        static Bge: System.Reflection.Emit.OpCode;
        static Bgt: System.Reflection.Emit.OpCode;
        static Ble: System.Reflection.Emit.OpCode;
        static Blt: System.Reflection.Emit.OpCode;
        static Bne_Un: System.Reflection.Emit.OpCode;
        static Bge_Un: System.Reflection.Emit.OpCode;
        static Bgt_Un: System.Reflection.Emit.OpCode;
        static Ble_Un: System.Reflection.Emit.OpCode;
        static Blt_Un: System.Reflection.Emit.OpCode;
        static Switch: System.Reflection.Emit.OpCode;
        static Ldind_I1: System.Reflection.Emit.OpCode;
        static Ldind_U1: System.Reflection.Emit.OpCode;
        static Ldind_I2: System.Reflection.Emit.OpCode;
        static Ldind_U2: System.Reflection.Emit.OpCode;
        static Ldind_I4: System.Reflection.Emit.OpCode;
        static Ldind_U4: System.Reflection.Emit.OpCode;
        static Ldind_I8: System.Reflection.Emit.OpCode;
        static Ldind_I: System.Reflection.Emit.OpCode;
        static Ldind_R4: System.Reflection.Emit.OpCode;
        static Ldind_R8: System.Reflection.Emit.OpCode;
        static Ldind_Ref: System.Reflection.Emit.OpCode;
        static Stind_Ref: System.Reflection.Emit.OpCode;
        static Stind_I1: System.Reflection.Emit.OpCode;
        static Stind_I2: System.Reflection.Emit.OpCode;
        static Stind_I4: System.Reflection.Emit.OpCode;
        static Stind_I8: System.Reflection.Emit.OpCode;
        static Stind_R4: System.Reflection.Emit.OpCode;
        static Stind_R8: System.Reflection.Emit.OpCode;
        static Add: System.Reflection.Emit.OpCode;
        static Sub: System.Reflection.Emit.OpCode;
        static Mul: System.Reflection.Emit.OpCode;
        static Div: System.Reflection.Emit.OpCode;
        static Div_Un: System.Reflection.Emit.OpCode;
        static Rem: System.Reflection.Emit.OpCode;
        static Rem_Un: System.Reflection.Emit.OpCode;
        static And: System.Reflection.Emit.OpCode;
        static Or: System.Reflection.Emit.OpCode;
        static Xor: System.Reflection.Emit.OpCode;
        static Shl: System.Reflection.Emit.OpCode;
        static Shr: System.Reflection.Emit.OpCode;
        static Shr_Un: System.Reflection.Emit.OpCode;
        static Neg: System.Reflection.Emit.OpCode;
        static Not: System.Reflection.Emit.OpCode;
        static Conv_I1: System.Reflection.Emit.OpCode;
        static Conv_I2: System.Reflection.Emit.OpCode;
        static Conv_I4: System.Reflection.Emit.OpCode;
        static Conv_I8: System.Reflection.Emit.OpCode;
        static Conv_R4: System.Reflection.Emit.OpCode;
        static Conv_R8: System.Reflection.Emit.OpCode;
        static Conv_U4: System.Reflection.Emit.OpCode;
        static Conv_U8: System.Reflection.Emit.OpCode;
        static Callvirt: System.Reflection.Emit.OpCode;
        static Cpobj: System.Reflection.Emit.OpCode;
        static Ldobj: System.Reflection.Emit.OpCode;
        static Ldstr: System.Reflection.Emit.OpCode;
        static Newobj: System.Reflection.Emit.OpCode;
        static Castclass: System.Reflection.Emit.OpCode;
        static Isinst: System.Reflection.Emit.OpCode;
        static Conv_R_Un: System.Reflection.Emit.OpCode;
        static Unbox: System.Reflection.Emit.OpCode;
        static Throw: System.Reflection.Emit.OpCode;
        static Ldfld: System.Reflection.Emit.OpCode;
        static Ldflda: System.Reflection.Emit.OpCode;
        static Stfld: System.Reflection.Emit.OpCode;
        static Ldsfld: System.Reflection.Emit.OpCode;
        static Ldsflda: System.Reflection.Emit.OpCode;
        static Stsfld: System.Reflection.Emit.OpCode;
        static Stobj: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I1_Un: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I2_Un: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I4_Un: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I8_Un: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U1_Un: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U2_Un: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U4_Un: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U8_Un: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I_Un: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U_Un: System.Reflection.Emit.OpCode;
        static Box: System.Reflection.Emit.OpCode;
        static Newarr: System.Reflection.Emit.OpCode;
        static Ldlen: System.Reflection.Emit.OpCode;
        static Ldelema: System.Reflection.Emit.OpCode;
        static Ldelem_I1: System.Reflection.Emit.OpCode;
        static Ldelem_U1: System.Reflection.Emit.OpCode;
        static Ldelem_I2: System.Reflection.Emit.OpCode;
        static Ldelem_U2: System.Reflection.Emit.OpCode;
        static Ldelem_I4: System.Reflection.Emit.OpCode;
        static Ldelem_U4: System.Reflection.Emit.OpCode;
        static Ldelem_I8: System.Reflection.Emit.OpCode;
        static Ldelem_I: System.Reflection.Emit.OpCode;
        static Ldelem_R4: System.Reflection.Emit.OpCode;
        static Ldelem_R8: System.Reflection.Emit.OpCode;
        static Ldelem_Ref: System.Reflection.Emit.OpCode;
        static Stelem_I: System.Reflection.Emit.OpCode;
        static Stelem_I1: System.Reflection.Emit.OpCode;
        static Stelem_I2: System.Reflection.Emit.OpCode;
        static Stelem_I4: System.Reflection.Emit.OpCode;
        static Stelem_I8: System.Reflection.Emit.OpCode;
        static Stelem_R4: System.Reflection.Emit.OpCode;
        static Stelem_R8: System.Reflection.Emit.OpCode;
        static Stelem_Ref: System.Reflection.Emit.OpCode;
        static Ldelem: System.Reflection.Emit.OpCode;
        static Stelem: System.Reflection.Emit.OpCode;
        static Unbox_Any: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I1: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U1: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I2: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U2: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I4: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U4: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I8: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U8: System.Reflection.Emit.OpCode;
        static Refanyval: System.Reflection.Emit.OpCode;
        static Ckfinite: System.Reflection.Emit.OpCode;
        static Mkrefany: System.Reflection.Emit.OpCode;
        static Ldtoken: System.Reflection.Emit.OpCode;
        static Conv_U2: System.Reflection.Emit.OpCode;
        static Conv_U1: System.Reflection.Emit.OpCode;
        static Conv_I: System.Reflection.Emit.OpCode;
        static Conv_Ovf_I: System.Reflection.Emit.OpCode;
        static Conv_Ovf_U: System.Reflection.Emit.OpCode;
        static Add_Ovf: System.Reflection.Emit.OpCode;
        static Add_Ovf_Un: System.Reflection.Emit.OpCode;
        static Mul_Ovf: System.Reflection.Emit.OpCode;
        static Mul_Ovf_Un: System.Reflection.Emit.OpCode;
        static Sub_Ovf: System.Reflection.Emit.OpCode;
        static Sub_Ovf_Un: System.Reflection.Emit.OpCode;
        static Endfinally: System.Reflection.Emit.OpCode;
        static Leave: System.Reflection.Emit.OpCode;
        static Leave_S: System.Reflection.Emit.OpCode;
        static Stind_I: System.Reflection.Emit.OpCode;
        static Conv_U: System.Reflection.Emit.OpCode;
        static Prefix7: System.Reflection.Emit.OpCode;
        static Prefix6: System.Reflection.Emit.OpCode;
        static Prefix5: System.Reflection.Emit.OpCode;
        static Prefix4: System.Reflection.Emit.OpCode;
        static Prefix3: System.Reflection.Emit.OpCode;
        static Prefix2: System.Reflection.Emit.OpCode;
        static Prefix1: System.Reflection.Emit.OpCode;
        static Prefixref: System.Reflection.Emit.OpCode;
        static Arglist: System.Reflection.Emit.OpCode;
        static Ceq: System.Reflection.Emit.OpCode;
        static Cgt: System.Reflection.Emit.OpCode;
        static Cgt_Un: System.Reflection.Emit.OpCode;
        static Clt: System.Reflection.Emit.OpCode;
        static Clt_Un: System.Reflection.Emit.OpCode;
        static Ldftn: System.Reflection.Emit.OpCode;
        static Ldvirtftn: System.Reflection.Emit.OpCode;
        static Ldarg: System.Reflection.Emit.OpCode;
        static Ldarga: System.Reflection.Emit.OpCode;
        static Starg: System.Reflection.Emit.OpCode;
        static Ldloc: System.Reflection.Emit.OpCode;
        static Ldloca: System.Reflection.Emit.OpCode;
        static Stloc: System.Reflection.Emit.OpCode;
        static Localloc: System.Reflection.Emit.OpCode;
        static Endfilter: System.Reflection.Emit.OpCode;
        static Unaligned: System.Reflection.Emit.OpCode;
        static Volatile: System.Reflection.Emit.OpCode;
        static Tailcall: System.Reflection.Emit.OpCode;
        static Initobj: System.Reflection.Emit.OpCode;
        static Constrained: System.Reflection.Emit.OpCode;
        static Cpblk: System.Reflection.Emit.OpCode;
        static Initblk: System.Reflection.Emit.OpCode;
        static Rethrow: System.Reflection.Emit.OpCode;
        static Sizeof: System.Reflection.Emit.OpCode;
        static Refanytype: System.Reflection.Emit.OpCode;
        static Readonly: System.Reflection.Emit.OpCode;
        static TakesSingleByteArgument(inst: System.Reflection.Emit.OpCode): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum PEFileKinds {
        Dll = 1,
        ConsoleApplication = 2,
        WindowApplication = 3,
      }
      export class ParameterBuilder {
        Attributes: number;
        IsIn: boolean;
        IsOut: boolean;
        IsOptional: boolean;
        Name: string;
        Position: number;
        GetToken(): System.Reflection.Emit.ParameterToken;
        SetConstant(defaultValue: any): void;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        SetMarshal(unmanagedMarshal: System.Reflection.Emit.UnmanagedMarshal): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ParameterToken {
        Token: number;
        static Empty: System.Reflection.Emit.ParameterToken;
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.ParameterToken): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class PropertyBuilder {
        Attributes: System.Reflection.PropertyAttributes;
        CanRead: boolean;
        CanWrite: boolean;
        DeclaringType: System.Type;
        Name: string;
        PropertyToken: System.Reflection.Emit.PropertyToken;
        PropertyType: System.Type;
        ReflectedType: System.Type;
        Module: System.Reflection.Module;
        MemberType: System.Reflection.MemberTypes;
        IsSpecialName: boolean;
        GetMethod: System.Reflection.MethodInfo;
        SetMethod: System.Reflection.MethodInfo;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        MetadataToken: number;
        AddOtherMethod(mdBuilder: System.Reflection.Emit.MethodBuilder): void;
        GetAccessors(nonPublic: boolean): System.Reflection.MethodInfo[];
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetGetMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetIndexParameters(): System.Reflection.ParameterInfo[];
        GetSetMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetValue(obj: any, index: any[]): any;
        GetValue(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, index: any[], culture: System.Globalization.CultureInfo): any;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        SetConstant(defaultValue: any): void;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        SetGetMethod(mdBuilder: System.Reflection.Emit.MethodBuilder): void;
        SetSetMethod(mdBuilder: System.Reflection.Emit.MethodBuilder): void;
        SetValue(obj: any, value: any, index: any[]): void;
        SetValue(obj: any, value: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, index: any[], culture: System.Globalization.CultureInfo): void;
        GetAccessors(): System.Reflection.MethodInfo[];
        GetGetMethod(): System.Reflection.MethodInfo;
        GetSetMethod(): System.Reflection.MethodInfo;
        GetOptionalCustomModifiers(): System.Type[];
        GetRequiredCustomModifiers(): System.Type[];
        GetValue(obj: any): any;
        GetConstantValue(): any;
        GetRawConstantValue(): any;
        SetValue(obj: any, value: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetType(): System.Type;
        ToString(): string;
      }
      export class PropertyToken {
        Token: number;
        static Empty: System.Reflection.Emit.PropertyToken;
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.PropertyToken): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class SignatureHelper {
        static GetFieldSigHelper(mod: System.Reflection.Module): System.Reflection.Emit.SignatureHelper;
        static GetLocalVarSigHelper(mod: System.Reflection.Module): System.Reflection.Emit.SignatureHelper;
        static GetLocalVarSigHelper(): System.Reflection.Emit.SignatureHelper;
        static GetMethodSigHelper(callingConvention: System.Reflection.CallingConventions, returnType: System.Type): System.Reflection.Emit.SignatureHelper;
        static GetMethodSigHelper(unmanagedCallingConvention: System.Runtime.InteropServices.CallingConvention, returnType: System.Type): System.Reflection.Emit.SignatureHelper;
        static GetMethodSigHelper(mod: System.Reflection.Module, callingConvention: System.Reflection.CallingConventions, returnType: System.Type): System.Reflection.Emit.SignatureHelper;
        static GetMethodSigHelper(mod: System.Reflection.Module, unmanagedCallConv: System.Runtime.InteropServices.CallingConvention, returnType: System.Type): System.Reflection.Emit.SignatureHelper;
        static GetMethodSigHelper(mod: System.Reflection.Module, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.Emit.SignatureHelper;
        static GetPropertySigHelper(mod: System.Reflection.Module, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.Emit.SignatureHelper;
        static GetPropertySigHelper(mod: System.Reflection.Module, returnType: System.Type, requiredReturnTypeCustomModifiers: System.Type[], optionalReturnTypeCustomModifiers: System.Type[], parameterTypes: System.Type[], requiredParameterTypeCustomModifiers: System.Type[][], optionalParameterTypeCustomModifiers: System.Type[][]): System.Reflection.Emit.SignatureHelper;
        static GetPropertySigHelper(mod: System.Reflection.Module, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, requiredReturnTypeCustomModifiers: System.Type[], optionalReturnTypeCustomModifiers: System.Type[], parameterTypes: System.Type[], requiredParameterTypeCustomModifiers: System.Type[][], optionalParameterTypeCustomModifiers: System.Type[][]): System.Reflection.Emit.SignatureHelper;
        AddArguments(argumentsCS: System.Type[], requiredCustomModifiers: System.Type[][], optionalCustomModifiers: System.Type[][]): void;
        AddArgument(argument: System.Type, pinned: boolean): void;
        AddArgument(argument: System.Type, requiredCustomModifiers: System.Type[], optionalCustomModifiers: System.Type[]): void;
        AddArgument(clsArgument: System.Type): void;
        AddSentinel(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetSignature(): Byte[];
        ToString(): string;
        GetType(): System.Type;
      }
      export class SignatureToken {
        Token: number;
        static Empty: System.Reflection.Emit.SignatureToken;
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.SignatureToken): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class StringToken {
        Token: number;
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.StringToken): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class TypeBuilder {
        Assembly: System.Reflection.Assembly;
        AssemblyQualifiedName: string;
        BaseType: System.Type;
        DeclaringType: System.Type;
        UnderlyingSystemType: System.Type;
        FullName: string;
        GUID: System.Guid;
        Module: System.Reflection.Module;
        Name: string;
        Namespace: string;
        PackingSize: System.Reflection.Emit.PackingSize;
        Size: number;
        ReflectedType: System.Type;
        TypeHandle: System.RuntimeTypeHandle;
        TypeToken: System.Reflection.Emit.TypeToken;
        ContainsGenericParameters: boolean;
        IsGenericParameter: boolean;
        GenericParameterAttributes: System.Reflection.GenericParameterAttributes;
        IsGenericTypeDefinition: boolean;
        IsGenericType: boolean;
        GenericParameterPosition: number;
        DeclaringMethod: System.Reflection.MethodBase;
        IsConstructedGenericType: boolean;
        IsTypeDefinition: boolean;
        GenericTypeParameters: System.Type[];
        DeclaredConstructors: System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo>;
        DeclaredEvents: System.Collections.Generic.IEnumerable<System.Reflection.EventInfo>;
        DeclaredFields: System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo>;
        DeclaredMembers: System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo>;
        DeclaredMethods: System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
        DeclaredNestedTypes: System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>;
        DeclaredProperties: System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>;
        ImplementedInterfaces: System.Collections.Generic.IEnumerable<System.Type>;
        IsSerializable: boolean;
        IsVisible: boolean;
        MemberType: System.Reflection.MemberTypes;
        IsNested: boolean;
        IsArray: boolean;
        IsByRef: boolean;
        IsPointer: boolean;
        IsGenericTypeParameter: boolean;
        IsGenericMethodParameter: boolean;
        IsSZArray: boolean;
        IsVariableBoundArray: boolean;
        IsByRefLike: boolean;
        HasElementType: boolean;
        GenericTypeArguments: System.Type[];
        Attributes: System.Reflection.TypeAttributes;
        IsAbstract: boolean;
        IsImport: boolean;
        IsSealed: boolean;
        IsSpecialName: boolean;
        IsClass: boolean;
        IsNestedAssembly: boolean;
        IsNestedFamANDAssem: boolean;
        IsNestedFamily: boolean;
        IsNestedFamORAssem: boolean;
        IsNestedPrivate: boolean;
        IsNestedPublic: boolean;
        IsNotPublic: boolean;
        IsPublic: boolean;
        IsAutoLayout: boolean;
        IsExplicitLayout: boolean;
        IsLayoutSequential: boolean;
        IsAnsiClass: boolean;
        IsAutoClass: boolean;
        IsUnicodeClass: boolean;
        IsCOMObject: boolean;
        IsContextful: boolean;
        IsCollectible: boolean;
        IsEnum: boolean;
        IsMarshalByRef: boolean;
        IsPrimitive: boolean;
        IsValueType: boolean;
        IsSignatureType: boolean;
        IsSecurityCritical: boolean;
        IsSecuritySafeCritical: boolean;
        IsSecurityTransparent: boolean;
        StructLayoutAttribute: any; // System.Runtime.InteropServices.StructLayoutAttribute
        TypeInitializer: System.Reflection.ConstructorInfo;
        IsInterface: boolean;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        MetadataToken: number;
        static UnspecifiedTypeSize: number;
        IsSubclassOf(c: System.Type): boolean;
        AddDeclarativeSecurity(action: System.Security.Permissions.SecurityAction, pset: System.Security.PermissionSet): void;
        AddInterfaceImplementation(interfaceType: System.Type): void;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        DefineNestedType(name: string): System.Reflection.Emit.TypeBuilder;
        DefineNestedType(name: string, attr: System.Reflection.TypeAttributes): System.Reflection.Emit.TypeBuilder;
        DefineNestedType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type): System.Reflection.Emit.TypeBuilder;
        DefineNestedType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type, interfaces: System.Type[]): System.Reflection.Emit.TypeBuilder;
        DefineNestedType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type, typeSize: number): System.Reflection.Emit.TypeBuilder;
        DefineNestedType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type, packSize: System.Reflection.Emit.PackingSize): System.Reflection.Emit.TypeBuilder;
        DefineNestedType(name: string, attr: System.Reflection.TypeAttributes, parent: System.Type, packSize: System.Reflection.Emit.PackingSize, typeSize: number): System.Reflection.Emit.TypeBuilder;
        DefineConstructor(attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, parameterTypes: System.Type[]): System.Reflection.Emit.ConstructorBuilder;
        DefineConstructor(attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, parameterTypes: System.Type[], requiredCustomModifiers: System.Type[][], optionalCustomModifiers: System.Type[][]): System.Reflection.Emit.ConstructorBuilder;
        DefineDefaultConstructor(attributes: System.Reflection.MethodAttributes): System.Reflection.Emit.ConstructorBuilder;
        DefineMethod(name: string, attributes: System.Reflection.MethodAttributes, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.Emit.MethodBuilder;
        DefineMethod(name: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.Emit.MethodBuilder;
        DefineMethod(name: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, returnTypeRequiredCustomModifiers: System.Type[], returnTypeOptionalCustomModifiers: System.Type[], parameterTypes: System.Type[], parameterTypeRequiredCustomModifiers: System.Type[][], parameterTypeOptionalCustomModifiers: System.Type[][]): System.Reflection.Emit.MethodBuilder;
        DefinePInvokeMethod(name: string, dllName: string, entryName: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[], nativeCallConv: System.Runtime.InteropServices.CallingConvention, nativeCharSet: System.Runtime.InteropServices.CharSet): System.Reflection.Emit.MethodBuilder;
        DefinePInvokeMethod(name: string, dllName: string, entryName: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, returnTypeRequiredCustomModifiers: System.Type[], returnTypeOptionalCustomModifiers: System.Type[], parameterTypes: System.Type[], parameterTypeRequiredCustomModifiers: System.Type[][], parameterTypeOptionalCustomModifiers: System.Type[][], nativeCallConv: System.Runtime.InteropServices.CallingConvention, nativeCharSet: System.Runtime.InteropServices.CharSet): System.Reflection.Emit.MethodBuilder;
        DefinePInvokeMethod(name: string, dllName: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[], nativeCallConv: System.Runtime.InteropServices.CallingConvention, nativeCharSet: System.Runtime.InteropServices.CharSet): System.Reflection.Emit.MethodBuilder;
        DefineMethod(name: string, attributes: System.Reflection.MethodAttributes): System.Reflection.Emit.MethodBuilder;
        DefineMethod(name: string, attributes: System.Reflection.MethodAttributes, callingConvention: System.Reflection.CallingConventions): System.Reflection.Emit.MethodBuilder;
        DefineMethodOverride(methodInfoBody: System.Reflection.MethodInfo, methodInfoDeclaration: System.Reflection.MethodInfo): void;
        DefineField(fieldName: string, type: System.Type, attributes: System.Reflection.FieldAttributes): System.Reflection.Emit.FieldBuilder;
        DefineField(fieldName: string, type: System.Type, requiredCustomModifiers: System.Type[], optionalCustomModifiers: System.Type[], attributes: System.Reflection.FieldAttributes): System.Reflection.Emit.FieldBuilder;
        DefineProperty(name: string, attributes: System.Reflection.PropertyAttributes, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.Emit.PropertyBuilder;
        DefineProperty(name: string, attributes: System.Reflection.PropertyAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.Type[]): System.Reflection.Emit.PropertyBuilder;
        DefineProperty(name: string, attributes: System.Reflection.PropertyAttributes, returnType: System.Type, returnTypeRequiredCustomModifiers: System.Type[], returnTypeOptionalCustomModifiers: System.Type[], parameterTypes: System.Type[], parameterTypeRequiredCustomModifiers: System.Type[][], parameterTypeOptionalCustomModifiers: System.Type[][]): System.Reflection.Emit.PropertyBuilder;
        DefineProperty(name: string, attributes: System.Reflection.PropertyAttributes, callingConvention: System.Reflection.CallingConventions, returnType: System.Type, returnTypeRequiredCustomModifiers: System.Type[], returnTypeOptionalCustomModifiers: System.Type[], parameterTypes: System.Type[], parameterTypeRequiredCustomModifiers: System.Type[][], parameterTypeOptionalCustomModifiers: System.Type[][]): System.Reflection.Emit.PropertyBuilder;
        DefineTypeInitializer(): System.Reflection.Emit.ConstructorBuilder;
        CreateType(): System.Type;
        CreateTypeInfo(): System.Reflection.TypeInfo;
        GetConstructors(bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];
        GetElementType(): System.Type;
        GetEvent(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo;
        GetEvents(): System.Reflection.EventInfo[];
        GetEvents(bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];
        GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
        GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
        GetInterface(name: string, ignoreCase: boolean): System.Type;
        GetInterfaces(): System.Type[];
        GetMember(name: string, type: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
        GetNestedType(name: string, bindingAttr: System.Reflection.BindingFlags): System.Type;
        GetNestedTypes(bindingAttr: System.Reflection.BindingFlags): System.Type[];
        GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], modifiers: System.Reflection.ParameterModifier[], culture: System.Globalization.CultureInfo, namedParameters: string[]): any;
        MakeArrayType(): System.Type;
        MakeArrayType(rank: number): System.Type;
        MakeByRefType(): System.Type;
        MakeGenericType(...typeArguments: System.Type[]): System.Type;
        MakePointerType(): System.Type;
        SetCustomAttribute(customBuilder: System.Reflection.Emit.CustomAttributeBuilder): void;
        SetCustomAttribute(con: System.Reflection.ConstructorInfo, binaryAttribute: Byte[]): void;
        DefineEvent(name: string, attributes: System.Reflection.EventAttributes, eventtype: System.Type): System.Reflection.Emit.EventBuilder;
        DefineInitializedData(name: string, data: Byte[], attributes: System.Reflection.FieldAttributes): System.Reflection.Emit.FieldBuilder;
        DefineUninitializedData(name: string, size: number, attributes: System.Reflection.FieldAttributes): System.Reflection.Emit.FieldBuilder;
        SetParent(parent: System.Type): void;
        GetInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;
        ToString(): string;
        IsAssignableFrom(c: System.Type): boolean;
        IsCreated(): boolean;
        GetGenericArguments(): System.Type[];
        GetGenericTypeDefinition(): System.Type;
        DefineGenericParameters(...names: string[]): System.Reflection.Emit.GenericTypeParameterBuilder[];
        static GetConstructor(type: System.Type, constructor: System.Reflection.ConstructorInfo): System.Reflection.ConstructorInfo;
        static GetMethod(type: System.Type, method: System.Reflection.MethodInfo): System.Reflection.MethodInfo;
        static GetField(type: System.Type, field: System.Reflection.FieldInfo): System.Reflection.FieldInfo;
        IsAssignableFrom(typeInfo: System.Reflection.TypeInfo): boolean;
        AsType(): System.Type;
        GetDeclaredEvent(name: string): System.Reflection.EventInfo;
        GetDeclaredField(name: string): System.Reflection.FieldInfo;
        GetDeclaredMethod(name: string): System.Reflection.MethodInfo;
        GetDeclaredNestedType(name: string): System.Reflection.TypeInfo;
        GetDeclaredProperty(name: string): System.Reflection.PropertyInfo;
        GetDeclaredMethods(name: string): System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>;
        IsEnumDefined(value: any): boolean;
        GetEnumName(value: any): string;
        GetEnumNames(): string[];
        FindInterfaces(filter: ((m: System.Type, filterCriteria: any) => boolean), filterCriteria: any): System.Type[];
        FindMembers(memberType: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags, filter: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean), filterCriteria: any): System.Reflection.MemberInfo[];
        GetType(): System.Type;
        GetArrayRank(): number;
        GetGenericParameterConstraints(): System.Type[];
        GetConstructor(types: System.Type[]): System.Reflection.ConstructorInfo;
        GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
        GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
        GetConstructors(): System.Reflection.ConstructorInfo[];
        GetEvent(name: string): System.Reflection.EventInfo;
        GetField(name: string): System.Reflection.FieldInfo;
        GetFields(): System.Reflection.FieldInfo[];
        GetMember(name: string): System.Reflection.MemberInfo[];
        GetMember(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMembers(): System.Reflection.MemberInfo[];
        GetMethod(name: string): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo;
        GetMethod(name: string, types: System.Type[]): System.Reflection.MethodInfo;
        GetMethod(name: string, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, types: System.Type[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethods(): System.Reflection.MethodInfo[];
        GetNestedType(name: string): System.Type;
        GetNestedTypes(): System.Type[];
        GetProperty(name: string): System.Reflection.PropertyInfo;
        GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type): System.Reflection.PropertyInfo;
        GetProperty(name: string, types: System.Type[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type, types: System.Type[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
        GetProperties(): System.Reflection.PropertyInfo[];
        GetDefaultMembers(): System.Reflection.MemberInfo[];
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[]): any;
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], culture: System.Globalization.CultureInfo): any;
        GetInterface(name: string): System.Type;
        IsInstanceOfType(o: any): boolean;
        IsEquivalentTo(other: System.Type): boolean;
        GetEnumUnderlyingType(): System.Type;
        GetEnumValues(): System.Array;
        Equals(o: any): boolean;
        GetHashCode(): number;
        Equals(o: System.Type): boolean;
        HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetType(): System.Type;
      }
      export class TypeToken {
        Token: number;
        static Empty: System.Reflection.Emit.TypeToken;
        Equals(obj: any): boolean;
        Equals(obj: System.Reflection.Emit.TypeToken): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class UnmanagedMarshal {
        BaseType: System.Runtime.InteropServices.UnmanagedType;
        ElementCount: number;
        GetUnmanagedType: System.Runtime.InteropServices.UnmanagedType;
        IIDGuid: System.Guid;
        static DefineByValArray(elemCount: number): System.Reflection.Emit.UnmanagedMarshal;
        static DefineByValTStr(elemCount: number): System.Reflection.Emit.UnmanagedMarshal;
        static DefineLPArray(elemType: System.Runtime.InteropServices.UnmanagedType): System.Reflection.Emit.UnmanagedMarshal;
        static DefineSafeArray(elemType: System.Runtime.InteropServices.UnmanagedType): System.Reflection.Emit.UnmanagedMarshal;
        static DefineUnmanagedMarshal(unmanagedType: System.Runtime.InteropServices.UnmanagedType): System.Reflection.Emit.UnmanagedMarshal;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace Metadata {
      export class AssemblyExtensions {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
  }
  export namespace Resources {
    export interface IResourceReader {
      Close(): void;
      GetEnumerator(): System.Collections.IDictionaryEnumerator;
    }
    export class MissingManifestResourceException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class MissingSatelliteAssemblyException {
      constructor();
      constructor(message: string);
      constructor(message: string, cultureName: string);
      constructor(message: string, inner: System.Exception);
      CultureName: string;
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum UltimateResourceFallbackLocation {
      MainAssembly = 0,
      Satellite = 1,
    }
    export interface IResourceWriter {
      AddResource(name: string, value: string): void;
      AddResource(name: string, value: any): void;
      AddResource(name: string, value: Byte[]): void;
      Close(): void;
      Generate(): void;
    }
    export class ResourceManager {
      constructor(baseName: string, assembly: System.Reflection.Assembly);
      constructor(baseName: string, assembly: System.Reflection.Assembly, usingResourceSet: System.Type);
      constructor(resourceSource: System.Type);
      BaseName: string;
      IgnoreCase: boolean;
      ResourceSetType: System.Type;
      static MagicNumber: number;
      static HeaderVersionNumber: number;
      ReleaseAllResources(): void;
      static CreateFileBasedResourceManager(baseName: string, resourceDir: string, usingResourceSet: System.Type): System.Resources.ResourceManager;
      GetResourceSet(culture: System.Globalization.CultureInfo, createIfNotExists: boolean, tryParents: boolean): System.Resources.ResourceSet;
      GetString(name: string): string;
      GetString(name: string, culture: System.Globalization.CultureInfo): string;
      GetObject(name: string): any;
      GetObject(name: string, culture: System.Globalization.CultureInfo): any;
      GetStream(name: string): System.IO.UnmanagedMemoryStream;
      GetStream(name: string, culture: System.Globalization.CultureInfo): System.IO.UnmanagedMemoryStream;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ResourceReader {
      constructor(fileName: string);
      constructor(stream: System.IO.Stream);
      Close(): void;
      Dispose(): void;
      GetEnumerator(): System.Collections.IDictionaryEnumerator;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ResourceSet {
      constructor(fileName: string);
      constructor(stream: System.IO.Stream);
      constructor(reader: System.Resources.IResourceReader);
      Close(): void;
      Dispose(): void;
      GetDefaultReader(): System.Type;
      GetDefaultWriter(): System.Type;
      GetEnumerator(): System.Collections.IDictionaryEnumerator;
      GetString(name: string): string;
      GetString(name: string, ignoreCase: boolean): string;
      GetObject(name: string): any;
      GetObject(name: string, ignoreCase: boolean): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ResourceWriter {
      constructor(fileName: string);
      constructor(stream: System.IO.Stream);
      TypeNameConverter: ((arg: System.Type) => string);
      AddResource(name: string, value: string): void;
      AddResource(name: string, value: any): void;
      AddResource(name: string, value: System.IO.Stream): void;
      AddResource(name: string, value: System.IO.Stream, closeAfterWrite: boolean): void;
      AddResource(name: string, value: Byte[]): void;
      AddResourceData(name: string, typeName: string, serializedData: Byte[]): void;
      Close(): void;
      Dispose(): void;
      Generate(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
  }
  export namespace Runtime {
    export class AmbiguousImplementationException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ProfileOptimization {
      static SetProfileRoot(directoryPath: string): void;
      static StartProfile(profile: string): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum GCLargeObjectHeapCompactionMode {
      Default = 1,
      CompactOnce = 2,
    }
    export enum GCLatencyMode {
      Batch = 0,
      Interactive = 1,
      LowLatency = 2,
      SustainedLowLatency = 3,
      NoGCRegion = 4,
    }
    export class GCSettings {
      static IsServerGC: boolean;
      static LatencyMode: System.Runtime.GCLatencyMode;
      static LargeObjectHeapCompactionMode: System.Runtime.GCLargeObjectHeapCompactionMode;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class MemoryFailPoint {
      constructor(sizeInMegabytes: number);
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RuntimeImports {
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export namespace CompilerServices {
      export class AsyncIteratorMethodBuilder {
        static Create(): System.Runtime.CompilerServices.AsyncIteratorMethodBuilder;
        Complete(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class AsyncValueTaskMethodBuilder<TResult = any> {
        Task: System.Threading.Tasks.ValueTask<TResult>;
        static Create(): any;
        SetStateMachine(stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine): void;
        SetResult(result: TResult): void;
        SetException(exception: System.Exception): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ConfiguredAsyncDisposable {
        DisposeAsync(): System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ConfiguredCancelableAsyncEnumerable<T = any> {
        ConfigureAwait(continueOnCapturedContext: boolean): System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T>;
        WithCancellation(cancellationToken: System.Threading.CancellationToken): System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T>;
        GetAsyncEnumerator(): System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ConfiguredValueTaskAwaitable<TResult = any> {
        GetAwaiter(): System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<TResult>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter {
        IsCompleted: boolean;
        GetResult(): void;
        OnCompleted(continuation: (() => void)): void;
        UnsafeOnCompleted(continuation: (() => void)): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class FormattableStringFactory {
        static Create(format: string, ...argumentsCS: any[]): System.FormattableString;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface IAsyncStateMachine {
        MoveNext(): void;
        SetStateMachine(stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine): void;
      }
      export interface INotifyCompletion {
        OnCompleted(continuation: (() => void)): void;
      }
      export interface ICriticalNotifyCompletion {
        UnsafeOnCompleted(continuation: (() => void)): void;
      }
      export interface ITuple {
        Length: number;
      }
      export class IsConst {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsVolatile {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RuntimeFeature {
        static IsDynamicCodeSupported: boolean;
        static IsDynamicCodeCompiled: boolean;
        static PortablePdb: string;
        static DefaultImplementationsOfInterfaces: string;
        static IsSupported(feature: string): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RuntimeWrappedException {
        constructor(thrownObject: any);
        WrappedException: any; // System.Object
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class ValueTaskAwaiter<TResult = any> {
        IsCompleted: boolean;
        GetResult(): TResult;
        OnCompleted(continuation: (() => void)): void;
        UnsafeOnCompleted(continuation: (() => void)): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class TaskAwaiter<TResult = any> {
        IsCompleted: boolean;
        OnCompleted(continuation: (() => void)): void;
        UnsafeOnCompleted(continuation: (() => void)): void;
        GetResult(): TResult;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ConfiguredTaskAwaitable<TResult = any> {
        GetAwaiter(): System.Runtime.CompilerServices.ConfiguredTaskAwaitable<TResult>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ConfiguredTaskAwaitable_ConfiguredTaskAwaiter {
        IsCompleted: boolean;
        OnCompleted(continuation: (() => void)): void;
        UnsafeOnCompleted(continuation: (() => void)): void;
        GetResult(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ContractHelper {
        static RaiseContractFailedEvent(failureKind: System.Diagnostics.Contracts.ContractFailureKind, userMessage: string, conditionText: string, innerException: System.Exception): string;
        static TriggerFailure(kind: System.Diagnostics.Contracts.ContractFailureKind, displayMessage: string, userMessage: string, conditionText: string, innerException: System.Exception): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AsyncVoidMethodBuilder {
        static Create(): System.Runtime.CompilerServices.AsyncVoidMethodBuilder;
        SetStateMachine(stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine): void;
        SetResult(): void;
        SetException(exception: System.Exception): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class AsyncTaskMethodBuilder<TResult = any> {
        Task: System.Threading.Tasks.Task<TResult>;
        static Create(): any;
        SetStateMachine(stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine): void;
        SetResult(result: TResult): void;
        SetException(exception: System.Exception): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class YieldAwaitable {
        GetAwaiter(): System.Runtime.CompilerServices.YieldAwaitable_YieldAwaiter;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class YieldAwaitable_YieldAwaiter {
        IsCompleted: boolean;
        OnCompleted(continuation: (() => void)): void;
        UnsafeOnCompleted(continuation: (() => void)): void;
        GetResult(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum LoadHint {
        Default = 0,
        Always = 1,
        Sometimes = 2,
      }
      export class CallConvCdecl {
        constructor();
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CallConvStdcall {
        constructor();
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CallConvThiscall {
        constructor();
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CallConvFastcall {
        constructor();
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum CompilationRelaxations {
        NoStringInterning = 8,
      }
      export class CompilerMarshalOverride {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsBoxed {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsByValue {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsCopyConstructed {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsExplicitlyDereferenced {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsImplicitlyDereferenced {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsJitIntrinsic {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsLong {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsPinned {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsSignUnspecifiedByte {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IsUdtReturn {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum MethodImplOptions {
        Unmanaged = 4,
        ForwardRef = 16,
        PreserveSig = 128,
        InternalCall = 4096,
        Synchronized = 32,
        NoInlining = 8,
        AggressiveInlining = 256,
        NoOptimization = 64,
        SecurityMitigations = 1024,
      }
      export enum MethodCodeType {
        IL = 0,
        Native = 1,
        OPTIL = 2,
        Runtime = 3,
      }
      export class ConditionalWeakTable<TKey = any, TValue = any> {
        constructor();
        AddOrUpdate(key: TKey, value: TValue): void;
        Add(key: TKey, value: TValue): void;
        Remove(key: TKey): boolean;
        GetOrCreateValue(key: TKey): TValue;
        GetValue(key: TKey, createValueCallback: ((key: TKey) => TValue)): TValue;
        Clear(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RuntimeHelpers {
        static OffsetToStringData: number;
        static InitializeArray(array: System.Array, fldHandle: System.RuntimeFieldHandle): void;
        static GetHashCode(o: any): number;
        static Equals(o1: any, o2: any): boolean;
        static GetObjectValue(obj: any): any;
        static RunClassConstructor(type: System.RuntimeTypeHandle): void;
        static EnsureSufficientExecutionStack(): void;
        static TryEnsureSufficientExecutionStack(): boolean;
        static ExecuteCodeWithGuaranteedCleanup(code: ((userData: any) => void), backoutCode: ((userData: any, exceptionThrown: boolean) => void), userData: any): void;
        static PrepareConstrainedRegions(): void;
        static PrepareConstrainedRegionsNoOP(): void;
        static ProbeForSufficientStack(): void;
        static PrepareDelegate(d: System.Delegate): void;
        static PrepareContractedDelegate(d: System.Delegate): void;
        static PrepareMethod(method: System.RuntimeMethodHandle): void;
        static PrepareMethod(method: System.RuntimeMethodHandle, instantiation: System.RuntimeTypeHandle[]): void;
        static RunModuleConstructor(module: System.ModuleHandle): void;
        static GetUninitializedObject(type: System.Type): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RuntimeHelpers_TryCode {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(userData: any): void;
        BeginInvoke(userData: any, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RuntimeHelpers_CleanupCode {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(userData: any, exceptionThrown: boolean): void;
        BeginInvoke(userData: any, exceptionThrown: boolean, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SwitchExpressionException {
        constructor();
        constructor(innerException: System.Exception);
        constructor(unmatchedValue: any);
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        UnmatchedValue: any; // System.Object
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class RuntimeOps {
        static ExpandoTrySetValue(expando: Record<string, any>, indexClass: any, index: number, value: any, name: string, ignoreCase: boolean): any;
        static ExpandoTryDeleteValue(expando: Record<string, any>, indexClass: any, index: number, name: string, ignoreCase: boolean): boolean;
        static ExpandoCheckVersion(expando: Record<string, any>, version: any): boolean;
        static ExpandoPromoteClass(expando: Record<string, any>, oldClass: any, newClass: any): void;
        static Quote(expression: System.Linq.Expressions.Expression, hoistedLocals: any, locals: any[]): System.Linq.Expressions.Expression;
        static MergeRuntimeVariables(first: System.Runtime.CompilerServices.IRuntimeVariables, second: System.Runtime.CompilerServices.IRuntimeVariables, indexes: number[]): System.Runtime.CompilerServices.IRuntimeVariables;
        static CreateRuntimeVariables(data: any[], indexes: number[]): System.Runtime.CompilerServices.IRuntimeVariables;
        static CreateRuntimeVariables(): System.Runtime.CompilerServices.IRuntimeVariables;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CallSite<T = any> {
        Update: T;
        Binder: System.Runtime.CompilerServices.CallSiteBinder;
        Target: T;
        static Create(binder: System.Runtime.CompilerServices.CallSiteBinder): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CallSiteBinder {
        static UpdateLabel: System.Linq.Expressions.LabelTarget;
        Bind(args: any[], parameters: System.Linq.Expressions.ParameterExpression[], returnLabel: System.Linq.Expressions.LabelTarget): System.Linq.Expressions.Expression;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CallSiteHelpers {
        static IsInternalFrame(mb: System.Reflection.MethodBase): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CallSiteOps {
        static SetNotMatched(site: System.Runtime.CompilerServices.CallSite): boolean;
        static GetMatch(site: System.Runtime.CompilerServices.CallSite): boolean;
        static ClearMatch(site: System.Runtime.CompilerServices.CallSite): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Closure {
        constructor(constants: any[], locals: any[]);
        Constants: any[];
        Locals: any[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DebugInfoGenerator {
        static CreatePdbGenerator(): System.Runtime.CompilerServices.DebugInfoGenerator;
        MarkSequencePoint(method: System.Linq.Expressions.LambdaExpression, ilOffset: number, sequencePoint: System.Linq.Expressions.DebugInfoExpression): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface IRuntimeVariables {
        Count: number;
      }
      export class ReadOnlyCollectionBuilder<T = any> {
        constructor();
        constructor(capacity: number);
        constructor(collection: System.Collections.Generic.IEnumerable<T>);
        Capacity: number;
        Count: number;
        IndexOf(item: T): number;
        Insert(index: number, item: T): void;
        RemoveAt(index: number): void;
        Add(item: T): void;
        Clear(): void;
        Contains(item: T): boolean;
        CopyTo(array: T[], arrayIndex: number): void;
        Remove(item: T): boolean;
        GetEnumerator(): System.Collections.Generic.IEnumerator<T>;
        Reverse(): void;
        Reverse(index: number, count: number): void;
        ToArray(): T[];
        ToReadOnlyCollection(): T[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RuleCache<T = any> {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class StrongBox<T = any> {
        constructor();
        constructor(value: T);
        Value: T;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface IStrongBox {
        Value: any; // System.Object
      }
      export class ExecutionScope {
        Parent: System.Runtime.CompilerServices.ExecutionScope;
        Globals: any[];
        Locals: any[];
        CreateHoistedLocals(): any[];
        CreateDelegate(indexLambda: number, locals: any[]): System.Delegate;
        IsolateExpression(expression: System.Linq.Expressions.Expression, locals: any[]): System.Linq.Expressions.Expression;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace ConstrainedExecution {
      export enum Cer {
        None = 0,
        MayFail = 1,
        Success = 2,
      }
      export enum Consistency {
        MayCorruptProcess = 0,
        MayCorruptAppDomain = 1,
        MayCorruptInstance = 2,
        WillNotCorruptState = 3,
      }
      export class CriticalFinalizerObject {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace DesignerServices {
      export class WindowsRuntimeDesignerContext {
        constructor(paths: System.Collections.Generic.IEnumerable<string>, name: string);
        Name: string;
        GetAssembly(assemblyName: string): System.Reflection.Assembly;
        GetType(typeName: string): System.Type;
        static InitializeSharedContext(paths: any): void;
        static SetIterationContext(context: System.Runtime.DesignerServices.WindowsRuntimeDesignerContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace ExceptionServices {
      export class FirstChanceExceptionEventArgs {
        constructor(exception: System.Exception);
        Exception: System.Exception;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ExceptionDispatchInfo {
        SourceException: System.Exception;
        static Capture(source: System.Exception): System.Runtime.ExceptionServices.ExceptionDispatchInfo;
        Throw(): void;
        static Throw(source: System.Exception): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace Hosting {
      export class ActivationArguments {
        constructor(activationData: System.ActivationContext);
        constructor(applicationIdentity: System.ApplicationIdentity);
        constructor(activationContext: System.ActivationContext, activationData: string[]);
        constructor(applicationIdentity: System.ApplicationIdentity, activationData: string[]);
        ActivationContext: System.ActivationContext;
        ActivationData: string[];
        ApplicationIdentity: System.ApplicationIdentity;
        Clone(): System.Security.Policy.EvidenceBase;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ApplicationActivator {
        constructor();
        CreateInstance(activationContext: System.ActivationContext): System.Runtime.Remoting.ObjectHandle;
        CreateInstance(activationContext: System.ActivationContext, activationCustomData: string[]): System.Runtime.Remoting.ObjectHandle;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace InteropServices {
      export enum CharSet {
        None = 1,
        Ansi = 2,
        Unicode = 3,
        Auto = 4,
      }
      export class ExternalException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        constructor(message: string, errorCode: number);
        ErrorCode: number;
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        ToString(): string;
        GetBaseException(): System.Exception;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class HandleRef {
        constructor(wrapper: any, handle: System.IntPtr);
        Wrapper: any; // System.Object
        Handle: System.IntPtr;
        static ToIntPtr(value: System.Runtime.InteropServices.HandleRef): System.IntPtr;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum LayoutKind {
        Sequential = 0,
        Explicit = 2,
        Auto = 3,
      }
      export class MarshalDirectiveException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MemoryMarshal {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SequenceMarshal {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum Architecture {
        X86 = 0,
        X64 = 1,
        Arm = 2,
        Arm64 = 3,
      }
      export class OSPlatform {
        static Linux: System.Runtime.InteropServices.OSPlatform;
        static OSX: System.Runtime.InteropServices.OSPlatform;
        static Windows: System.Runtime.InteropServices.OSPlatform;
        static Create(osPlatform: string): System.Runtime.InteropServices.OSPlatform;
        Equals(other: System.Runtime.InteropServices.OSPlatform): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum RegistrationConnectionType {
        SingleUse = 0,
        MultipleUse = 1,
        MultiSeparate = 2,
        Suspended = 4,
        Surrogate = 8,
      }
      export enum GCHandleType {
        Weak = 0,
        WeakTrackResurrection = 1,
        Normal = 2,
        Pinned = 3,
      }
      export class SafeBuffer {
        ByteLength: number;
        IsInvalid: boolean;
        IsClosed: boolean;
        Initialize(numBytes: number): void;
        Initialize(numElements: number, sizeOfEachElement: number): void;
        ReleasePointer(): void;
        DangerousGetHandle(): System.IntPtr;
        Close(): void;
        Dispose(): void;
        SetHandleAsInvalid(): void;
        DangerousRelease(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class COMException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        constructor(message: string, errorCode: number);
        ErrorCode: number;
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        ToString(): string;
        GetBaseException(): System.Exception;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class BStrWrapper {
        constructor(value: string);
        constructor(value: any);
        WrappedObject: string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum ComMemberType {
        Method = 0,
        PropGet = 1,
        PropSet = 2,
      }
      export class CurrencyWrapper {
        constructor(obj: number);
        constructor(obj: any);
        WrappedObject: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum CustomQueryInterfaceMode {
        Ignore = 0,
        Allow = 1,
      }
      export class ErrorWrapper {
        constructor(errorCode: number);
        constructor(errorCode: any);
        constructor(e: System.Exception);
        ErrorCode: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface ICustomAdapter {
        GetUnderlyingObject(): any;
      }
      export interface ICustomFactory {
        CreateInstance(serverType: System.Type): System.MarshalByRefObject;
      }
      export interface ICustomMarshaler {
        MarshalNativeToManaged(pNativeData: System.IntPtr): any;
        MarshalManagedToNative(ManagedObj: any): System.IntPtr;
        CleanUpNativeData(pNativeData: System.IntPtr): void;
        CleanUpManagedData(ManagedObj: any): void;
        GetNativeDataSize(): number;
      }
      export class InvalidComObjectException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class InvalidOleVariantTypeException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class SEHException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        ErrorCode: number;
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        CanResume(): boolean;
        ToString(): string;
        GetBaseException(): System.Exception;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class SafeArrayRankMismatchException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class SafeArrayTypeMismatchException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class UnknownWrapper {
        constructor(obj: any);
        WrappedObject: any; // System.Object
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class VariantWrapper {
        constructor(obj: any);
        WrappedObject: any; // System.Object
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ArrayWithOffset {
        constructor(array: any, offset: number);
        GetArray(): any;
        GetOffset(): number;
        GetHashCode(): number;
        Equals(obj: any): boolean;
        Equals(obj: System.Runtime.InteropServices.ArrayWithOffset): boolean;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum ComInterfaceType {
        InterfaceIsDual = 0,
        InterfaceIsIUnknown = 1,
        InterfaceIsIDispatch = 2,
        InterfaceIsIInspectable = 3,
      }
      export enum ClassInterfaceType {
        None = 0,
        AutoDispatch = 1,
        AutoDual = 2,
      }
      export enum IDispatchImplType {
        SystemDefinedImpl = 0,
        InternalImpl = 1,
        CompatibleImpl = 2,
      }
      export enum TypeLibTypeFlags {
        FAppObject = 1,
        FCanCreate = 2,
        FLicensed = 4,
        FPreDeclId = 8,
        FHidden = 16,
        FControl = 32,
        FDual = 64,
        FNonExtensible = 128,
        FOleAutomation = 256,
        FRestricted = 512,
        FAggregatable = 1024,
        FReplaceable = 2048,
        FDispatchable = 4096,
        FReverseBind = 8192,
      }
      export enum TypeLibFuncFlags {
        FRestricted = 1,
        FSource = 2,
        FBindable = 4,
        FRequestEdit = 8,
        FDisplayBind = 16,
        FDefaultBind = 32,
        FHidden = 64,
        FUsesGetLastError = 128,
        FDefaultCollelem = 256,
        FUiDefault = 512,
        FNonBrowsable = 1024,
        FReplaceable = 2048,
        FImmediateBind = 4096,
      }
      export enum TypeLibVarFlags {
        FReadOnly = 1,
        FSource = 2,
        FBindable = 4,
        FRequestEdit = 8,
        FDisplayBind = 16,
        FDefaultBind = 32,
        FHidden = 64,
        FRestricted = 128,
        FDefaultCollelem = 256,
        FUiDefault = 512,
        FNonBrowsable = 1024,
        FReplaceable = 2048,
        FImmediateBind = 4096,
      }
      export enum VarEnum {
        VT_EMPTY = 0,
        VT_NULL = 1,
        VT_I2 = 2,
        VT_I4 = 3,
        VT_R4 = 4,
        VT_R8 = 5,
        VT_CY = 6,
        VT_DATE = 7,
        VT_BSTR = 8,
        VT_DISPATCH = 9,
        VT_ERROR = 10,
        VT_BOOL = 11,
        VT_VARIANT = 12,
        VT_UNKNOWN = 13,
        VT_DECIMAL = 14,
        VT_I1 = 16,
        VT_UI1 = 17,
        VT_UI2 = 18,
        VT_UI4 = 19,
        VT_I8 = 20,
        VT_UI8 = 21,
        VT_INT = 22,
        VT_UINT = 23,
        VT_VOID = 24,
        VT_HRESULT = 25,
        VT_PTR = 26,
        VT_SAFEARRAY = 27,
        VT_CARRAY = 28,
        VT_USERDEFINED = 29,
        VT_LPSTR = 30,
        VT_LPWSTR = 31,
        VT_RECORD = 36,
        VT_FILETIME = 64,
        VT_BLOB = 65,
        VT_STREAM = 66,
        VT_STORAGE = 67,
        VT_STREAMED_OBJECT = 68,
        VT_STORED_OBJECT = 69,
        VT_BLOB_OBJECT = 70,
        VT_CF = 71,
        VT_CLSID = 72,
        VT_VECTOR = 4096,
        VT_ARRAY = 8192,
        VT_BYREF = 16384,
      }
      export enum UnmanagedType {
        Bool = 2,
        I1 = 3,
        U1 = 4,
        I2 = 5,
        U2 = 6,
        I4 = 7,
        U4 = 8,
        I8 = 9,
        U8 = 10,
        R4 = 11,
        R8 = 12,
        Currency = 15,
        BStr = 19,
        LPStr = 20,
        LPWStr = 21,
        LPTStr = 22,
        ByValTStr = 23,
        IUnknown = 25,
        IDispatch = 26,
        Struct = 27,
        Interface = 28,
        SafeArray = 29,
        ByValArray = 30,
        SysInt = 31,
        SysUInt = 32,
        VBByRefStr = 34,
        AnsiBStr = 35,
        TBStr = 36,
        VariantBool = 37,
        FunctionPtr = 38,
        AsAny = 40,
        LPArray = 42,
        LPStruct = 43,
        CustomMarshaler = 44,
        Error = 45,
        IInspectable = 46,
        HString = 47,
        LPUTF8Str = 48,
      }
      export enum DllImportSearchPath {
        UseDllDirectoryForDependencies = 256,
        ApplicationDirectory = 512,
        UserDirectories = 1024,
        System32 = 2048,
        SafeDirectories = 4096,
        AssemblyDirectory = 2,
        LegacyBehavior = 0,
      }
      export enum CallingConvention {
        Winapi = 1,
        Cdecl = 2,
        StdCall = 3,
        ThisCall = 4,
        FastCall = 5,
      }
      export class CriticalHandle {
        IsClosed: boolean;
        IsInvalid: boolean;
        Close(): void;
        Dispose(): void;
        SetHandleAsInvalid(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DispatchWrapper {
        constructor(obj: any);
        WrappedObject: any; // System.Object
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum CustomQueryInterfaceResult {
        Handled = 0,
        NotHandled = 1,
        Failed = 2,
      }
      export interface ICustomQueryInterface {
      }
      export enum AssemblyRegistrationFlags {
        None = 0,
        SetCodeBase = 1,
      }
      export interface IRegistrationServices {
        RegisterAssembly(assembly: System.Reflection.Assembly, flags: System.Runtime.InteropServices.AssemblyRegistrationFlags): boolean;
        UnregisterAssembly(assembly: System.Reflection.Assembly): boolean;
        GetRegistrableTypesInAssembly(assembly: System.Reflection.Assembly): System.Type[];
        GetProgIdForType(type: System.Type): string;
        GetManagedCategoryGuid(): System.Guid;
        TypeRequiresRegistration(type: System.Type): boolean;
        TypeRepresentsComType(type: System.Type): boolean;
      }
      export class ObjectCreationDelegate {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(aggregator: System.IntPtr): System.IntPtr;
        BeginInvoke(aggregator: System.IntPtr, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): System.IntPtr;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RuntimeEnvironment {
        constructor();
        static SystemConfigurationFile: string;
        static FromGlobalAccessCache(a: System.Reflection.Assembly): boolean;
        static GetSystemVersion(): string;
        static GetRuntimeDirectory(): string;
        static GetRuntimeInterfaceAsIntPtr(clsid: System.Guid, riid: System.Guid): System.IntPtr;
        static GetRuntimeInterfaceAsObject(clsid: System.Guid, riid: System.Guid): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SafeHandle {
        IsClosed: boolean;
        IsInvalid: boolean;
        DangerousGetHandle(): System.IntPtr;
        Close(): void;
        Dispose(): void;
        SetHandleAsInvalid(): void;
        DangerousRelease(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CONNECTDATA {
        pUnk: any; // System.Object
        dwCookie: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export interface UCOMIEnumConnections {
        Skip(celt: number): number;
        Reset(): void;
      }
      export enum TYPEKIND {
        TKIND_ENUM = 0,
        TKIND_RECORD = 1,
        TKIND_MODULE = 2,
        TKIND_INTERFACE = 3,
        TKIND_DISPATCH = 4,
        TKIND_COCLASS = 5,
        TKIND_ALIAS = 6,
        TKIND_UNION = 7,
        TKIND_MAX = 8,
      }
      export enum TYPEFLAGS {
        TYPEFLAG_FAPPOBJECT = 1,
        TYPEFLAG_FCANCREATE = 2,
        TYPEFLAG_FLICENSED = 4,
        TYPEFLAG_FPREDECLID = 8,
        TYPEFLAG_FHIDDEN = 16,
        TYPEFLAG_FCONTROL = 32,
        TYPEFLAG_FDUAL = 64,
        TYPEFLAG_FNONEXTENSIBLE = 128,
        TYPEFLAG_FOLEAUTOMATION = 256,
        TYPEFLAG_FRESTRICTED = 512,
        TYPEFLAG_FAGGREGATABLE = 1024,
        TYPEFLAG_FREPLACEABLE = 2048,
        TYPEFLAG_FDISPATCHABLE = 4096,
        TYPEFLAG_FREVERSEBIND = 8192,
        TYPEFLAG_FPROXY = 16384,
      }
      export enum IMPLTYPEFLAGS {
        IMPLTYPEFLAG_FDEFAULT = 1,
        IMPLTYPEFLAG_FSOURCE = 2,
        IMPLTYPEFLAG_FRESTRICTED = 4,
        IMPLTYPEFLAG_FDEFAULTVTABLE = 8,
      }
      export class TYPEATTR {
        static MEMBER_ID_NIL: number;
        guid: System.Guid;
        lcid: number;
        dwReserved: number;
        memidConstructor: number;
        memidDestructor: number;
        lpstrSchema: System.IntPtr;
        cbSizeInstance: number;
        typekind: System.Runtime.InteropServices.TYPEKIND;
        cFuncs: number;
        cVars: number;
        cImplTypes: number;
        cbSizeVft: number;
        cbAlignment: number;
        wTypeFlags: System.Runtime.InteropServices.TYPEFLAGS;
        wMajorVerNum: number;
        wMinorVerNum: number;
        tdescAlias: System.Runtime.InteropServices.TYPEDESC;
        idldescType: System.Runtime.InteropServices.IDLDESC;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class FUNCDESC {
        memid: number;
        lprgscode: System.IntPtr;
        lprgelemdescParam: System.IntPtr;
        funckind: System.Runtime.InteropServices.FUNCKIND;
        invkind: System.Runtime.InteropServices.INVOKEKIND;
        callconv: System.Runtime.InteropServices.CALLCONV;
        cParams: number;
        cParamsOpt: number;
        oVft: number;
        cScodes: number;
        elemdescFunc: System.Runtime.InteropServices.ELEMDESC;
        wFuncFlags: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum IDLFLAG {
        IDLFLAG_NONE = 0,
        IDLFLAG_FIN = 1,
        IDLFLAG_FOUT = 2,
        IDLFLAG_FLCID = 4,
        IDLFLAG_FRETVAL = 8,
      }
      export class IDLDESC {
        dwReserved: number;
        wIDLFlags: System.Runtime.InteropServices.IDLFLAG;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum PARAMFLAG {
        PARAMFLAG_NONE = 0,
        PARAMFLAG_FIN = 1,
        PARAMFLAG_FOUT = 2,
        PARAMFLAG_FLCID = 4,
        PARAMFLAG_FRETVAL = 8,
        PARAMFLAG_FOPT = 16,
        PARAMFLAG_FHASDEFAULT = 32,
        PARAMFLAG_FHASCUSTDATA = 64,
      }
      export class PARAMDESC {
        lpVarValue: System.IntPtr;
        wParamFlags: System.Runtime.InteropServices.PARAMFLAG;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class TYPEDESC {
        lpValue: System.IntPtr;
        vt: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ELEMDESC {
        tdesc: System.Runtime.InteropServices.TYPEDESC;
        desc: System.Runtime.InteropServices.ELEMDESC_DESCUNION;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ELEMDESC_DESCUNION {
        idldesc: System.Runtime.InteropServices.IDLDESC;
        paramdesc: System.Runtime.InteropServices.PARAMDESC;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class VARDESC {
        memid: number;
        lpstrSchema: string;
        elemdescVar: System.Runtime.InteropServices.ELEMDESC;
        wVarFlags: number;
        varkind: System.Runtime.InteropServices.VarEnum;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class VARDESC_DESCUNION {
        oInst: number;
        lpvarValue: System.IntPtr;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class DISPPARAMS {
        rgvarg: System.IntPtr;
        rgdispidNamedArgs: System.IntPtr;
        cArgs: number;
        cNamedArgs: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class EXCEPINFO {
        wCode: number;
        wReserved: number;
        bstrSource: string;
        bstrDescription: string;
        bstrHelpFile: string;
        dwHelpContext: number;
        pvReserved: System.IntPtr;
        pfnDeferredFillIn: System.IntPtr;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum FUNCKIND {
        FUNC_VIRTUAL = 0,
        FUNC_PUREVIRTUAL = 1,
        FUNC_NONVIRTUAL = 2,
        FUNC_STATIC = 3,
        FUNC_DISPATCH = 4,
      }
      export enum INVOKEKIND {
        INVOKE_FUNC = 1,
        INVOKE_PROPERTYGET = 2,
        INVOKE_PROPERTYPUT = 4,
        INVOKE_PROPERTYPUTREF = 8,
      }
      export enum CALLCONV {
        CC_CDECL = 1,
        CC_MSCPASCAL = 2,
        CC_PASCAL = 2,
        CC_MACPASCAL = 3,
        CC_STDCALL = 4,
        CC_RESERVED = 5,
        CC_SYSCALL = 6,
        CC_MPWCDECL = 7,
        CC_MPWPASCAL = 8,
        CC_MAX = 9,
      }
      export enum FUNCFLAGS {
        FUNCFLAG_FRESTRICTED = 1,
        FUNCFLAG_FSOURCE = 2,
        FUNCFLAG_FBINDABLE = 4,
        FUNCFLAG_FREQUESTEDIT = 8,
        FUNCFLAG_FDISPLAYBIND = 16,
        FUNCFLAG_FDEFAULTBIND = 32,
        FUNCFLAG_FHIDDEN = 64,
        FUNCFLAG_FUSESGETLASTERROR = 128,
        FUNCFLAG_FDEFAULTCOLLELEM = 256,
        FUNCFLAG_FUIDEFAULT = 512,
        FUNCFLAG_FNONBROWSABLE = 1024,
        FUNCFLAG_FREPLACEABLE = 2048,
        FUNCFLAG_FIMMEDIATEBIND = 4096,
      }
      export enum VARFLAGS {
        VARFLAG_FREADONLY = 1,
        VARFLAG_FSOURCE = 2,
        VARFLAG_FBINDABLE = 4,
        VARFLAG_FREQUESTEDIT = 8,
        VARFLAG_FDISPLAYBIND = 16,
        VARFLAG_FDEFAULTBIND = 32,
        VARFLAG_FHIDDEN = 64,
        VARFLAG_FRESTRICTED = 128,
        VARFLAG_FDEFAULTCOLLELEM = 256,
        VARFLAG_FUIDEFAULT = 512,
        VARFLAG_FNONBROWSABLE = 1024,
        VARFLAG_FREPLACEABLE = 2048,
        VARFLAG_FIMMEDIATEBIND = 4096,
      }
      export interface UCOMITypeInfo {
        GetIDsOfNames(rgszNames: string[], cNames: number, pMemId: number[]): void;
        ReleaseTypeAttr(pTypeAttr: System.IntPtr): void;
        ReleaseFuncDesc(pFuncDesc: System.IntPtr): void;
        ReleaseVarDesc(pVarDesc: System.IntPtr): void;
      }
      export class RuntimeInformation {
        static FrameworkDescription: string;
        static OSDescription: string;
        static OSArchitecture: System.Runtime.InteropServices.Architecture;
        static ProcessArchitecture: System.Runtime.InteropServices.Architecture;
        static IsOSPlatform(osPlatform: System.Runtime.InteropServices.OSPlatform): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class BINDPTR {
        lpfuncdesc: System.IntPtr;
        lptcomp: System.IntPtr;
        lpvardesc: System.IntPtr;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class BIND_OPTS {
        cbStruct: number;
        grfFlags: number;
        grfMode: number;
        dwTickCountDeadline: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ComEventsHelper {
        static Combine(rcw: any, iid: System.Guid, dispid: number, d: System.Delegate): void;
        static Remove(rcw: any, iid: System.Guid, dispid: number, d: System.Delegate): System.Delegate;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum DESCKIND {
        DESCKIND_NONE = 0,
        DESCKIND_FUNCDESC = 1,
        DESCKIND_VARDESC = 2,
        DESCKIND_TYPECOMP = 3,
        DESCKIND_IMPLICITAPPOBJ = 4,
        DESCKIND_MAX = 5,
      }
      export enum ExporterEventKind {
        NOTIF_TYPECONVERTED = 0,
        NOTIF_CONVERTWARNING = 1,
        ERROR_REFTOINVALIDASSEMBLY = 2,
      }
      export class ExtensibleClassFactory {
        static RegisterObjectCreationCallback(callback: ((aggregator: System.IntPtr) => System.IntPtr)): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FILETIME {
        dwLowDateTime: number;
        dwHighDateTime: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class GCHandle {
        IsAllocated: boolean;
        Target: any; // System.Object
        AddrOfPinnedObject(): System.IntPtr;
        static Alloc(value: any): System.Runtime.InteropServices.GCHandle;
        static Alloc(value: any, type: System.Runtime.InteropServices.GCHandleType): System.Runtime.InteropServices.GCHandle;
        Free(): void;
        Equals(o: any): boolean;
        GetHashCode(): number;
        static FromIntPtr(value: System.IntPtr): System.Runtime.InteropServices.GCHandle;
        static ToIntPtr(value: System.Runtime.InteropServices.GCHandle): System.IntPtr;
        ToString(): string;
        GetType(): System.Type;
      }
      export interface ITypeLibConverter {
        ConvertAssemblyToTypeLib(assembly: System.Reflection.Assembly, typeLibName: string, flags: System.Runtime.InteropServices.TypeLibExporterFlags, notifySink: System.Runtime.InteropServices.ITypeLibExporterNotifySink): any;
        ConvertTypeLibToAssembly(typeLib: any, asmFileName: string, flags: number, notifySink: System.Runtime.InteropServices.ITypeLibImporterNotifySink, publicKey: Byte[], keyPair: System.Reflection.StrongNameKeyPair, unsafeInterfaces: boolean): System.Reflection.Emit.AssemblyBuilder;
        ConvertTypeLibToAssembly(typeLib: any, asmFileName: string, flags: System.Runtime.InteropServices.TypeLibImporterFlags, notifySink: System.Runtime.InteropServices.ITypeLibImporterNotifySink, publicKey: Byte[], keyPair: System.Reflection.StrongNameKeyPair, asmNamespace: string, asmVersion: System.Version): System.Reflection.Emit.AssemblyBuilder;
      }
      export interface ITypeLibExporterNameProvider {
        GetNames(): string[];
      }
      export interface ITypeLibExporterNotifySink {
        ReportEvent(eventKind: System.Runtime.InteropServices.ExporterEventKind, eventCode: number, eventMsg: string): void;
        ResolveRef(assembly: System.Reflection.Assembly): any;
      }
      export interface ITypeLibImporterNotifySink {
        ReportEvent(eventKind: System.Runtime.InteropServices.ImporterEventKind, eventCode: number, eventMsg: string): void;
        ResolveRef(typeLib: any): System.Reflection.Assembly;
      }
      export enum ImporterEventKind {
        NOTIF_TYPECONVERTED = 0,
        NOTIF_CONVERTWARNING = 1,
        ERROR_REFTOINVALIDTYPELIB = 2,
      }
      export enum LIBFLAGS {
        LIBFLAG_FRESTRICTED = 1,
        LIBFLAG_FCONTROL = 2,
        LIBFLAG_FHIDDEN = 4,
        LIBFLAG_FHASDISKIMAGE = 8,
      }
      export class Marshal {
        static SystemMaxDBCSCharSize: number;
        static SystemDefaultCharSize: number;
        static AddRef(pUnk: System.IntPtr): number;
        static AreComObjectsAvailableForCleanup(): boolean;
        static CleanupUnusedObjectsInCurrentContext(): void;
        static AllocCoTaskMem(cb: number): System.IntPtr;
        static AllocHGlobal(cb: System.IntPtr): System.IntPtr;
        static AllocHGlobal(cb: number): System.IntPtr;
        static BindToMoniker(monikerName: string): any;
        static ChangeWrapperHandleStrength(otp: any, fIsWeak: boolean): void;
        static Copy(source: Byte[], startIndex: number, destination: System.IntPtr, length: number): void;
        static Copy(source: System.Char[], startIndex: number, destination: System.IntPtr, length: number): void;
        static Copy(source: number[], startIndex: number, destination: System.IntPtr, length: number): void;
        static Copy(source: number[], startIndex: number, destination: System.IntPtr, length: number): void;
        static Copy(source: number[], startIndex: number, destination: System.IntPtr, length: number): void;
        static Copy(source: number[], startIndex: number, destination: System.IntPtr, length: number): void;
        static Copy(source: number[], startIndex: number, destination: System.IntPtr, length: number): void;
        static Copy(source: System.IntPtr[], startIndex: number, destination: System.IntPtr, length: number): void;
        static Copy(source: System.IntPtr, destination: Byte[], startIndex: number, length: number): void;
        static Copy(source: System.IntPtr, destination: System.Char[], startIndex: number, length: number): void;
        static Copy(source: System.IntPtr, destination: number[], startIndex: number, length: number): void;
        static Copy(source: System.IntPtr, destination: number[], startIndex: number, length: number): void;
        static Copy(source: System.IntPtr, destination: number[], startIndex: number, length: number): void;
        static Copy(source: System.IntPtr, destination: number[], startIndex: number, length: number): void;
        static Copy(source: System.IntPtr, destination: number[], startIndex: number, length: number): void;
        static Copy(source: System.IntPtr, destination: System.IntPtr[], startIndex: number, length: number): void;
        static CreateAggregatedObject(pOuter: System.IntPtr, o: any): System.IntPtr;
        static CreateWrapperOfType(o: any, t: System.Type): any;
        static DestroyStructure(ptr: System.IntPtr, structuretype: System.Type): void;
        static FreeBSTR(ptr: System.IntPtr): void;
        static FreeCoTaskMem(ptr: System.IntPtr): void;
        static FreeHGlobal(hglobal: System.IntPtr): void;
        static ZeroFreeBSTR(s: System.IntPtr): void;
        static ZeroFreeCoTaskMemAnsi(s: System.IntPtr): void;
        static ZeroFreeCoTaskMemUnicode(s: System.IntPtr): void;
        static ZeroFreeCoTaskMemUTF8(s: System.IntPtr): void;
        static ZeroFreeGlobalAllocAnsi(s: System.IntPtr): void;
        static ZeroFreeGlobalAllocUnicode(s: System.IntPtr): void;
        static GenerateGuidForType(type: System.Type): System.Guid;
        static GenerateProgIdForType(type: System.Type): string;
        static GetActiveObject(progID: string): any;
        static GetComInterfaceForObject(o: any, T: System.Type): System.IntPtr;
        static GetComInterfaceForObject(o: any, T: System.Type, mode: System.Runtime.InteropServices.CustomQueryInterfaceMode): System.IntPtr;
        static GetComInterfaceForObjectInContext(o: any, t: System.Type): System.IntPtr;
        static GetComObjectData(obj: any, key: any): any;
        static GetComSlotForMethodInfo(m: System.Reflection.MemberInfo): number;
        static GetEndComSlot(t: System.Type): number;
        static GetExceptionPointers(): System.IntPtr;
        static GetHINSTANCE(m: System.Reflection.Module): System.IntPtr;
        static GetExceptionCode(): number;
        static GetHRForException(e: System.Exception): number;
        static GetHRForLastWin32Error(): number;
        static GetIDispatchForObject(o: any): System.IntPtr;
        static GetIDispatchForObjectInContext(o: any): System.IntPtr;
        static GetITypeInfoForType(t: System.Type): System.IntPtr;
        static GetIUnknownForObjectInContext(o: any): System.IntPtr;
        static GetManagedThunkForUnmanagedMethodPtr(pfnMethodToWrap: System.IntPtr, pbSignature: System.IntPtr, cbSignature: number): System.IntPtr;
        static GetIUnknownForObject(o: any): System.IntPtr;
        static GetNativeVariantForObject(obj: any, pDstNativeVariant: System.IntPtr): void;
        static GetObjectForIUnknown(pUnk: System.IntPtr): any;
        static GetObjectForNativeVariant(pSrcNativeVariant: System.IntPtr): any;
        static GetObjectsForNativeVariants(aSrcNativeVariant: System.IntPtr, cVars: number): any[];
        static GetStartComSlot(t: System.Type): number;
        static GetThreadFromFiberCookie(cookie: number): System.Threading.Thread;
        static GetTypedObjectForIUnknown(pUnk: System.IntPtr, t: System.Type): any;
        static GetTypeForITypeInfo(piTypeInfo: System.IntPtr): System.Type;
        static GetTypeInfoName(pTI: System.Runtime.InteropServices.UCOMITypeInfo): string;
        static GetTypeLibGuid(pTLB: System.Runtime.InteropServices.UCOMITypeLib): System.Guid;
        static GetTypeLibGuid(typelib: System.Runtime.InteropServices.ComTypes.ITypeLib): System.Guid;
        static GetTypeLibGuidForAssembly(asm: System.Reflection.Assembly): System.Guid;
        static GetTypeLibLcid(pTLB: System.Runtime.InteropServices.UCOMITypeLib): number;
        static GetTypeLibLcid(typelib: System.Runtime.InteropServices.ComTypes.ITypeLib): number;
        static GetTypeLibName(pTLB: System.Runtime.InteropServices.UCOMITypeLib): string;
        static GetTypeLibName(typelib: System.Runtime.InteropServices.ComTypes.ITypeLib): string;
        static GetUnmanagedThunkForManagedMethodPtr(pfnMethodToWrap: System.IntPtr, pbSignature: System.IntPtr, cbSignature: number): System.IntPtr;
        static IsTypeVisibleFromCom(t: System.Type): boolean;
        static NumParamBytes(m: System.Reflection.MethodInfo): number;
        static GetTypeFromCLSID(clsid: System.Guid): System.Type;
        static GetTypeInfoName(typeInfo: System.Runtime.InteropServices.ComTypes.ITypeInfo): string;
        static GetUniqueObjectForIUnknown(unknown: System.IntPtr): any;
        static IsComObject(o: any): boolean;
        static GetLastWin32Error(): number;
        static OffsetOf(t: System.Type, fieldName: string): System.IntPtr;
        static Prelink(m: System.Reflection.MethodInfo): void;
        static PrelinkAll(c: System.Type): void;
        static PtrToStringAnsi(ptr: System.IntPtr): string;
        static PtrToStringAnsi(ptr: System.IntPtr, len: number): string;
        static PtrToStringUTF8(ptr: System.IntPtr): string;
        static PtrToStringUTF8(ptr: System.IntPtr, byteLen: number): string;
        static PtrToStringAuto(ptr: System.IntPtr): string;
        static PtrToStringAuto(ptr: System.IntPtr, len: number): string;
        static PtrToStringUni(ptr: System.IntPtr): string;
        static PtrToStringUni(ptr: System.IntPtr, len: number): string;
        static PtrToStringBSTR(ptr: System.IntPtr): string;
        static PtrToStructure(ptr: System.IntPtr, structure: any): void;
        static PtrToStructure(ptr: System.IntPtr, structureType: System.Type): any;
        static ReadByte(ptr: System.IntPtr): Byte;
        static ReadByte(ptr: System.IntPtr, ofs: number): Byte;
        static ReadByte(ptr: any, ofs: number): Byte;
        static ReadInt16(ptr: System.IntPtr): number;
        static ReadInt16(ptr: System.IntPtr, ofs: number): number;
        static ReadInt16(ptr: any, ofs: number): number;
        static ReadInt32(ptr: System.IntPtr): number;
        static ReadInt32(ptr: System.IntPtr, ofs: number): number;
        static ReadInt32(ptr: any, ofs: number): number;
        static ReadInt64(ptr: System.IntPtr): number;
        static ReadInt64(ptr: System.IntPtr, ofs: number): number;
        static ReadInt64(ptr: any, ofs: number): number;
        static ReadIntPtr(ptr: System.IntPtr): System.IntPtr;
        static ReadIntPtr(ptr: System.IntPtr, ofs: number): System.IntPtr;
        static ReadIntPtr(ptr: any, ofs: number): System.IntPtr;
        static ReAllocCoTaskMem(pv: System.IntPtr, cb: number): System.IntPtr;
        static ReAllocHGlobal(pv: System.IntPtr, cb: System.IntPtr): System.IntPtr;
        static Release(pUnk: System.IntPtr): number;
        static ReleaseComObject(o: any): number;
        static ReleaseThreadCache(): void;
        static SetComObjectData(obj: any, key: any, data: any): boolean;
        static SizeOf(structure: any): number;
        static SizeOf(t: System.Type): number;
        static StringToBSTR(s: string): System.IntPtr;
        static StringToCoTaskMemAnsi(s: string): System.IntPtr;
        static StringToCoTaskMemAuto(s: string): System.IntPtr;
        static StringToCoTaskMemUni(s: string): System.IntPtr;
        static StringToHGlobalAnsi(s: string): System.IntPtr;
        static StringToAllocatedMemoryUTF8(s: string): System.IntPtr;
        static StringToHGlobalAuto(s: string): System.IntPtr;
        static StringToHGlobalUni(s: string): System.IntPtr;
        static SecureStringToBSTR(s: System.Security.SecureString): System.IntPtr;
        static SecureStringToCoTaskMemAnsi(s: System.Security.SecureString): System.IntPtr;
        static SecureStringToCoTaskMemUnicode(s: System.Security.SecureString): System.IntPtr;
        static SecureStringToGlobalAllocAnsi(s: System.Security.SecureString): System.IntPtr;
        static SecureStringToGlobalAllocUnicode(s: System.Security.SecureString): System.IntPtr;
        static StructureToPtr(structure: any, ptr: System.IntPtr, fDeleteOld: boolean): void;
        static ThrowExceptionForHR(errorCode: number): void;
        static ThrowExceptionForHR(errorCode: number, errorInfo: System.IntPtr): void;
        static UnsafeAddrOfPinnedArrayElement(arr: System.Array, index: number): System.IntPtr;
        static WriteByte(ptr: System.IntPtr, val: Byte): void;
        static WriteByte(ptr: System.IntPtr, ofs: number, val: Byte): void;
        static WriteByte(ptr: any, ofs: number, val: Byte): void;
        static WriteInt16(ptr: System.IntPtr, val: number): void;
        static WriteInt16(ptr: System.IntPtr, ofs: number, val: number): void;
        static WriteInt16(ptr: any, ofs: number, val: number): void;
        static WriteInt16(ptr: System.IntPtr, val: System.Char): void;
        static WriteInt16(ptr: System.IntPtr, ofs: number, val: System.Char): void;
        static WriteInt16(ptr: any, ofs: number, val: System.Char): void;
        static WriteInt32(ptr: System.IntPtr, val: number): void;
        static WriteInt32(ptr: System.IntPtr, ofs: number, val: number): void;
        static WriteInt32(ptr: any, ofs: number, val: number): void;
        static WriteInt64(ptr: System.IntPtr, val: number): void;
        static WriteInt64(ptr: System.IntPtr, ofs: number, val: number): void;
        static WriteInt64(ptr: any, ofs: number, val: number): void;
        static WriteIntPtr(ptr: System.IntPtr, val: System.IntPtr): void;
        static WriteIntPtr(ptr: System.IntPtr, ofs: number, val: System.IntPtr): void;
        static WriteIntPtr(ptr: any, ofs: number, val: System.IntPtr): void;
        static GetExceptionForHR(errorCode: number): System.Exception;
        static GetExceptionForHR(errorCode: number, errorInfo: System.IntPtr): System.Exception;
        static FinalReleaseComObject(o: any): number;
        static GetDelegateForFunctionPointer(ptr: System.IntPtr, t: System.Type): System.Delegate;
        static GetFunctionPointerForDelegate(d: System.Delegate): System.IntPtr;
        static StringToCoTaskMemUTF8(s: string): System.IntPtr;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum RegistrationClassContext {
        DisableActivateAsActivator = 32768,
        EnableActivateAsActivator = 65536,
        EnableCodeDownload = 8192,
        FromDefaultContext = 131072,
        InProcessHandler = 2,
        InProcessHandler16 = 32,
        InProcessServer = 1,
        InProcessServer16 = 8,
        LocalServer = 4,
        NoCodeDownload = 1024,
        NoCustomMarshal = 4096,
        NoFailureLog = 16384,
        RemoteServer = 16,
        Reserved1 = 64,
        Reserved2 = 128,
        Reserved3 = 256,
        Reserved4 = 512,
        Reserved5 = 2048,
      }
      export class RegistrationServices {
        constructor();
        GetManagedCategoryGuid(): System.Guid;
        GetProgIdForType(type: System.Type): string;
        GetRegistrableTypesInAssembly(assembly: System.Reflection.Assembly): System.Type[];
        RegisterAssembly(assembly: System.Reflection.Assembly, flags: System.Runtime.InteropServices.AssemblyRegistrationFlags): boolean;
        TypeRepresentsComType(type: System.Type): boolean;
        TypeRequiresRegistration(type: System.Type): boolean;
        UnregisterAssembly(assembly: System.Reflection.Assembly): boolean;
        RegisterTypeForComClients(type: System.Type, classContext: System.Runtime.InteropServices.RegistrationClassContext, flags: System.Runtime.InteropServices.RegistrationConnectionType): number;
        UnregisterTypeForComClients(cookie: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class STATSTG {
        pwcsName: string;
        type: number;
        cbSize: number;
        mtime: System.Runtime.InteropServices.FILETIME;
        ctime: System.Runtime.InteropServices.FILETIME;
        atime: System.Runtime.InteropServices.FILETIME;
        grfMode: number;
        grfLocksSupported: number;
        clsid: System.Guid;
        grfStateBits: number;
        reserved: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum SYSKIND {
        SYS_WIN16 = 0,
        SYS_WIN32 = 1,
        SYS_MAC = 2,
      }
      export class TYPELIBATTR {
        guid: System.Guid;
        lcid: number;
        syskind: System.Runtime.InteropServices.SYSKIND;
        wMajorVerNum: number;
        wMinorVerNum: number;
        wLibFlags: System.Runtime.InteropServices.LIBFLAGS;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class TypeLibConverter {
        constructor();
        ConvertAssemblyToTypeLib(assembly: System.Reflection.Assembly, strTypeLibName: string, flags: System.Runtime.InteropServices.TypeLibExporterFlags, notifySink: System.Runtime.InteropServices.ITypeLibExporterNotifySink): any;
        ConvertTypeLibToAssembly(typeLib: any, asmFileName: string, flags: number, notifySink: System.Runtime.InteropServices.ITypeLibImporterNotifySink, publicKey: Byte[], keyPair: System.Reflection.StrongNameKeyPair, unsafeInterfaces: boolean): System.Reflection.Emit.AssemblyBuilder;
        ConvertTypeLibToAssembly(typeLib: any, asmFileName: string, flags: System.Runtime.InteropServices.TypeLibImporterFlags, notifySink: System.Runtime.InteropServices.ITypeLibImporterNotifySink, publicKey: Byte[], keyPair: System.Reflection.StrongNameKeyPair, asmNamespace: string, asmVersion: System.Version): System.Reflection.Emit.AssemblyBuilder;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum TypeLibExporterFlags {
        OnlyReferenceRegistered = 1,
        None = 0,
        CallerResolvedReferences = 2,
        OldNames = 4,
        ExportAs32Bit = 16,
        ExportAs64Bit = 32,
      }
      export enum TypeLibImporterFlags {
        PrimaryInteropAssembly = 1,
        UnsafeInterfaces = 2,
        SafeArrayAsSystemArray = 4,
        TransformDispRetVals = 8,
        None = 0,
        PreventClassMembers = 16,
        ImportAsAgnostic = 2048,
        ImportAsItanium = 1024,
        ImportAsX64 = 512,
        ImportAsX86 = 256,
        ReflectionOnlyLoading = 4096,
        SerializableValueClasses = 32,
        NoDefineVersionResource = 8192,
        ImportAsArm = 16384,
      }
      export interface UCOMIBindCtx {
        RegisterObjectBound(punk: any): void;
        RevokeObjectBound(punk: any): void;
        ReleaseBoundObjects(): void;
        RegisterObjectParam(pszKey: string, punk: any): void;
        RevokeObjectParam(pszKey: string): void;
      }
      export interface UCOMIConnectionPoint {
        Unadvise(dwCookie: number): void;
      }
      export interface UCOMIConnectionPointContainer {
      }
      export interface UCOMIEnumConnectionPoints {
        Skip(celt: number): number;
        Reset(): number;
      }
      export interface UCOMIEnumMoniker {
        Skip(celt: number): number;
        Reset(): number;
      }
      export interface UCOMIEnumString {
        Skip(celt: number): number;
        Reset(): number;
      }
      export interface UCOMIEnumVARIANT {
        Next(celt: number, rgvar: number, pceltFetched: number): number;
        Skip(celt: number): number;
        Reset(): number;
        Clone(ppenum: number): void;
      }
      export interface UCOMIMoniker {
        IsDirty(): number;
        Load(pStm: System.Runtime.InteropServices.UCOMIStream): void;
        Save(pStm: System.Runtime.InteropServices.UCOMIStream, fClearDirty: boolean): void;
        IsEqual(pmkOtherMoniker: System.Runtime.InteropServices.UCOMIMoniker): void;
        IsRunning(pbc: System.Runtime.InteropServices.UCOMIBindCtx, pmkToLeft: System.Runtime.InteropServices.UCOMIMoniker, pmkNewlyRunning: System.Runtime.InteropServices.UCOMIMoniker): void;
      }
      export interface UCOMIPersistFile {
        IsDirty(): number;
        Load(pszFileName: string, dwMode: number): void;
        Save(pszFileName: string, fRemember: boolean): void;
        SaveCompleted(pszFileName: string): void;
      }
      export interface UCOMIRunningObjectTable {
        Revoke(dwRegister: number): void;
        IsRunning(pmkObjectName: System.Runtime.InteropServices.UCOMIMoniker): void;
      }
      export interface UCOMIStream {
        Read(pv: Byte[], cb: number, pcbRead: System.IntPtr): void;
        Write(pv: Byte[], cb: number, pcbWritten: System.IntPtr): void;
        Seek(dlibMove: number, dwOrigin: number, plibNewPosition: System.IntPtr): void;
        SetSize(libNewSize: number): void;
        CopyTo(pstm: System.Runtime.InteropServices.UCOMIStream, cb: number, pcbRead: System.IntPtr, pcbWritten: System.IntPtr): void;
        Commit(grfCommitFlags: number): void;
        Revert(): void;
        LockRegion(libOffset: number, cb: number, dwLockType: number): void;
        UnlockRegion(libOffset: number, cb: number, dwLockType: number): void;
      }
      export interface UCOMITypeComp {
      }
      export interface UCOMITypeLib {
        GetTypeInfoCount(): number;
        IsName(szNameBuf: string, lHashVal: number): boolean;
        ReleaseTLibAttr(pTLibAttr: System.IntPtr): void;
      }
      export interface _Activator {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _Assembly {
        CodeBase: string;
        EscapedCodeBase: string;
        FullName: string;
        EntryPoint: System.Reflection.MethodInfo;
        Location: string;
        Evidence: System.Security.Policy.Evidence;
        GlobalAssemblyCache: boolean;
        ToString(): string;
        Equals(other: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        GetName(): System.Reflection.AssemblyName;
        GetName(copiedName: boolean): System.Reflection.AssemblyName;
        GetType(name: string): System.Type;
        GetType(name: string, throwOnError: boolean): System.Type;
        GetExportedTypes(): System.Type[];
        GetTypes(): System.Type[];
        GetManifestResourceStream(type: System.Type, name: string): System.IO.Stream;
        GetManifestResourceStream(name: string): System.IO.Stream;
        GetFile(name: string): System.IO.FileStream;
        GetFiles(): System.IO.FileStream[];
        GetFiles(getResourceModules: boolean): System.IO.FileStream[];
        GetManifestResourceNames(): string[];
        GetManifestResourceInfo(resourceName: string): System.Reflection.ManifestResourceInfo;
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetCustomAttributes(inherit: boolean): any[];
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(name: string, throwOnError: boolean, ignoreCase: boolean): System.Type;
        GetSatelliteAssembly(culture: System.Globalization.CultureInfo): System.Reflection.Assembly;
        GetSatelliteAssembly(culture: System.Globalization.CultureInfo, version: System.Version): System.Reflection.Assembly;
        LoadModule(moduleName: string, rawModule: Byte[]): System.Reflection.Module;
        LoadModule(moduleName: string, rawModule: Byte[], rawSymbolStore: Byte[]): System.Reflection.Module;
        CreateInstance(typeName: string): any;
        CreateInstance(typeName: string, ignoreCase: boolean): any;
        CreateInstance(typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any[], culture: System.Globalization.CultureInfo, activationAttributes: any[]): any;
        GetLoadedModules(): System.Reflection.Module[];
        GetLoadedModules(getResourceModules: boolean): System.Reflection.Module[];
        GetModules(): System.Reflection.Module[];
        GetModules(getResourceModules: boolean): System.Reflection.Module[];
        GetModule(name: string): System.Reflection.Module;
        GetReferencedAssemblies(): System.Reflection.AssemblyName[];
      }
      export interface _AssemblyBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _AssemblyName {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _Attribute {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _ConstructorBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _ConstructorInfo {
        Attributes: System.Reflection.MethodAttributes;
        CallingConvention: System.Reflection.CallingConventions;
        DeclaringType: System.Type;
        IsAbstract: boolean;
        IsAssembly: boolean;
        IsConstructor: boolean;
        IsFamily: boolean;
        IsFamilyAndAssembly: boolean;
        IsFamilyOrAssembly: boolean;
        IsFinal: boolean;
        IsHideBySig: boolean;
        IsPrivate: boolean;
        IsPublic: boolean;
        IsSpecialName: boolean;
        IsStatic: boolean;
        IsVirtual: boolean;
        MemberType: System.Reflection.MemberTypes;
        MethodHandle: System.RuntimeMethodHandle;
        Name: string;
        ReflectedType: System.Type;
        Equals(other: any): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetHashCode(): number;
        GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;
        GetParameters(): System.Reflection.ParameterInfo[];
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
        GetType(): System.Type;
        Invoke_5(parameters: any[]): any;
        Invoke_3(obj: any, parameters: any[]): any;
        Invoke_4(invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
        Invoke_2(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        ToString(): string;
      }
      export interface _CustomAttributeBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _EnumBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _EventBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _EventInfo {
        Attributes: System.Reflection.EventAttributes;
        DeclaringType: System.Type;
        EventHandlerType: System.Type;
        IsMulticast: boolean;
        IsSpecialName: boolean;
        MemberType: System.Reflection.MemberTypes;
        Name: string;
        ReflectedType: System.Type;
        AddEventHandler(target: any, handler: System.Delegate): void;
        Equals(other: any): boolean;
        GetAddMethod(): System.Reflection.MethodInfo;
        GetAddMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetHashCode(): number;
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
        GetRaiseMethod(): System.Reflection.MethodInfo;
        GetRaiseMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetRemoveMethod(): System.Reflection.MethodInfo;
        GetRemoveMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetType(): System.Type;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        RemoveEventHandler(target: any, handler: System.Delegate): void;
        ToString(): string;
      }
      export interface _Exception {
        HelpLink: string;
        InnerException: System.Exception;
        Message: string;
        Source: string;
        StackTrace: string;
        TargetSite: System.Reflection.MethodBase;
        Equals(obj: any): boolean;
        GetBaseException(): System.Exception;
        GetHashCode(): number;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface _FieldBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _FieldInfo {
        Attributes: System.Reflection.FieldAttributes;
        DeclaringType: System.Type;
        FieldHandle: System.RuntimeFieldHandle;
        FieldType: System.Type;
        IsAssembly: boolean;
        IsFamily: boolean;
        IsFamilyAndAssembly: boolean;
        IsFamilyOrAssembly: boolean;
        IsInitOnly: boolean;
        IsLiteral: boolean;
        IsNotSerialized: boolean;
        IsPinvokeImpl: boolean;
        IsPrivate: boolean;
        IsPublic: boolean;
        IsSpecialName: boolean;
        IsStatic: boolean;
        MemberType: System.Reflection.MemberTypes;
        Name: string;
        ReflectedType: System.Type;
        Equals(other: any): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetHashCode(): number;
        GetType(): System.Type;
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
        GetValue(obj: any): any;
        GetValueDirect(obj: System.TypedReference): any;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        SetValue(obj: any, value: any): void;
        SetValue(obj: any, value: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, culture: System.Globalization.CultureInfo): void;
        SetValueDirect(obj: System.TypedReference, value: any): void;
        ToString(): string;
      }
      export interface _ILGenerator {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _LocalBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _MemberInfo {
        DeclaringType: System.Type;
        MemberType: System.Reflection.MemberTypes;
        Name: string;
        ReflectedType: System.Type;
        Equals(other: any): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetHashCode(): number;
        GetType(): System.Type;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        ToString(): string;
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _MethodBase {
        Attributes: System.Reflection.MethodAttributes;
        CallingConvention: System.Reflection.CallingConventions;
        DeclaringType: System.Type;
        IsAbstract: boolean;
        IsAssembly: boolean;
        IsConstructor: boolean;
        IsFamily: boolean;
        IsFamilyAndAssembly: boolean;
        IsFamilyOrAssembly: boolean;
        IsFinal: boolean;
        IsHideBySig: boolean;
        IsPrivate: boolean;
        IsPublic: boolean;
        IsSpecialName: boolean;
        IsStatic: boolean;
        IsVirtual: boolean;
        MemberType: System.Reflection.MemberTypes;
        MethodHandle: System.RuntimeMethodHandle;
        Name: string;
        ReflectedType: System.Type;
        Equals(other: any): boolean;
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetHashCode(): number;
        GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;
        GetParameters(): System.Reflection.ParameterInfo[];
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
        GetType(): System.Type;
        Invoke(obj: any, parameters: any[]): any;
        Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        ToString(): string;
      }
      export interface _MethodBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _MethodInfo {
        MemberType: System.Reflection.MemberTypes;
        Name: string;
        DeclaringType: System.Type;
        ReflectedType: System.Type;
        MethodHandle: System.RuntimeMethodHandle;
        Attributes: System.Reflection.MethodAttributes;
        CallingConvention: System.Reflection.CallingConventions;
        IsPublic: boolean;
        IsPrivate: boolean;
        IsFamily: boolean;
        IsAssembly: boolean;
        IsFamilyAndAssembly: boolean;
        IsFamilyOrAssembly: boolean;
        IsStatic: boolean;
        IsFinal: boolean;
        IsVirtual: boolean;
        IsHideBySig: boolean;
        IsAbstract: boolean;
        IsSpecialName: boolean;
        IsConstructor: boolean;
        ReturnType: System.Type;
        ReturnTypeCustomAttributes: System.Reflection.ICustomAttributeProvider;
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
        ToString(): string;
        Equals(other: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetCustomAttributes(inherit: boolean): any[];
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetParameters(): System.Reflection.ParameterInfo[];
        GetMethodImplementationFlags(): System.Reflection.MethodImplAttributes;
        Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any[], culture: System.Globalization.CultureInfo): any;
        Invoke(obj: any, parameters: any[]): any;
        GetBaseDefinition(): System.Reflection.MethodInfo;
      }
      export interface _MethodRental {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _Module {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _ModuleBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _ParameterBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _ParameterInfo {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _PropertyBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _PropertyInfo {
        Attributes: System.Reflection.PropertyAttributes;
        CanRead: boolean;
        CanWrite: boolean;
        DeclaringType: System.Type;
        IsSpecialName: boolean;
        MemberType: System.Reflection.MemberTypes;
        Name: string;
        PropertyType: System.Type;
        ReflectedType: System.Type;
        Equals(other: any): boolean;
        GetAccessors(): System.Reflection.MethodInfo[];
        GetAccessors(nonPublic: boolean): System.Reflection.MethodInfo[];
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetGetMethod(): System.Reflection.MethodInfo;
        GetGetMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetHashCode(): number;
        GetIndexParameters(): System.Reflection.ParameterInfo[];
        GetSetMethod(): System.Reflection.MethodInfo;
        GetSetMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
        GetType(): System.Type;
        GetValue(obj: any, index: any[]): any;
        GetValue(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, index: any[], culture: System.Globalization.CultureInfo): any;
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        SetValue(obj: any, value: any, index: any[]): void;
        SetValue(obj: any, value: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, index: any[], culture: System.Globalization.CultureInfo): void;
        ToString(): string;
      }
      export interface _SignatureHelper {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _Thread {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export interface _Type {
        MemberType: System.Reflection.MemberTypes;
        Name: string;
        DeclaringType: System.Type;
        ReflectedType: System.Type;
        GUID: System.Guid;
        Module: System.Reflection.Module;
        Assembly: System.Reflection.Assembly;
        TypeHandle: System.RuntimeTypeHandle;
        FullName: string;
        Namespace: string;
        AssemblyQualifiedName: string;
        BaseType: System.Type;
        UnderlyingSystemType: System.Type;
        TypeInitializer: System.Reflection.ConstructorInfo;
        Attributes: System.Reflection.TypeAttributes;
        IsNotPublic: boolean;
        IsPublic: boolean;
        IsNestedPublic: boolean;
        IsNestedPrivate: boolean;
        IsNestedFamily: boolean;
        IsNestedAssembly: boolean;
        IsNestedFamANDAssem: boolean;
        IsNestedFamORAssem: boolean;
        IsAutoLayout: boolean;
        IsLayoutSequential: boolean;
        IsExplicitLayout: boolean;
        IsClass: boolean;
        IsInterface: boolean;
        IsValueType: boolean;
        IsAbstract: boolean;
        IsSealed: boolean;
        IsEnum: boolean;
        IsSpecialName: boolean;
        IsImport: boolean;
        IsSerializable: boolean;
        IsAnsiClass: boolean;
        IsUnicodeClass: boolean;
        IsAutoClass: boolean;
        IsArray: boolean;
        IsByRef: boolean;
        IsPointer: boolean;
        IsPrimitive: boolean;
        IsCOMObject: boolean;
        HasElementType: boolean;
        IsContextful: boolean;
        IsMarshalByRef: boolean;
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
        ToString(): string;
        Equals(other: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetCustomAttributes(inherit: boolean): any[];
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetArrayRank(): number;
        GetConstructors(bindingAttr: System.Reflection.BindingFlags): System.Reflection.ConstructorInfo[];
        GetInterface(name: string, ignoreCase: boolean): System.Type;
        GetInterfaces(): System.Type[];
        FindInterfaces(filter: ((m: System.Type, filterCriteria: any) => boolean), filterCriteria: any): System.Type[];
        GetEvent(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo;
        GetEvents(): System.Reflection.EventInfo[];
        GetEvents(bindingAttr: System.Reflection.BindingFlags): System.Reflection.EventInfo[];
        GetNestedTypes(bindingAttr: System.Reflection.BindingFlags): System.Type[];
        GetNestedType(name: string, bindingAttr: System.Reflection.BindingFlags): System.Type;
        GetMember(name: string, type: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetDefaultMembers(): System.Reflection.MemberInfo[];
        FindMembers(memberType: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags, filter: ((m: System.Reflection.MemberInfo, filterCriteria: any) => boolean), filterCriteria: any): System.Reflection.MemberInfo[];
        GetElementType(): System.Type;
        IsSubclassOf(c: System.Type): boolean;
        IsInstanceOfType(o: any): boolean;
        IsAssignableFrom(c: System.Type): boolean;
        GetInterfaceMap(interfaceType: System.Type): System.Reflection.InterfaceMapping;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo;
        GetMethods(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MethodInfo[];
        GetField(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo;
        GetFields(bindingAttr: System.Reflection.BindingFlags): System.Reflection.FieldInfo[];
        GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo;
        GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
        GetProperties(bindingAttr: System.Reflection.BindingFlags): System.Reflection.PropertyInfo[];
        GetMember(name: string, bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        GetMembers(bindingAttr: System.Reflection.BindingFlags): System.Reflection.MemberInfo[];
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], modifiers: System.Reflection.ParameterModifier[], culture: System.Globalization.CultureInfo, namedParameters: string[]): any;
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[], culture: System.Globalization.CultureInfo): any;
        InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any[]): any;
        GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
        GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.ConstructorInfo;
        GetConstructor(types: System.Type[]): System.Reflection.ConstructorInfo;
        GetConstructors(): System.Reflection.ConstructorInfo[];
        GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.MethodInfo;
        GetMethod(name: string, types: System.Type[]): System.Reflection.MethodInfo;
        GetMethod(name: string): System.Reflection.MethodInfo;
        GetMethods(): System.Reflection.MethodInfo[];
        GetField(name: string): System.Reflection.FieldInfo;
        GetFields(): System.Reflection.FieldInfo[];
        GetInterface(name: string): System.Type;
        GetEvent(name: string): System.Reflection.EventInfo;
        GetProperty(name: string, returnType: System.Type, types: System.Type[], modifiers: System.Reflection.ParameterModifier[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type, types: System.Type[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, types: System.Type[]): System.Reflection.PropertyInfo;
        GetProperty(name: string, returnType: System.Type): System.Reflection.PropertyInfo;
        GetProperty(name: string): System.Reflection.PropertyInfo;
        GetProperties(): System.Reflection.PropertyInfo[];
        GetNestedTypes(): System.Type[];
        GetNestedType(name: string): System.Type;
        GetMember(name: string): System.Reflection.MemberInfo[];
        GetMembers(): System.Reflection.MemberInfo[];
        Equals(o: System.Type): boolean;
      }
      export interface _TypeBuilder {
        GetTypeInfo(iTInfo: number, lcid: number, ppTInfo: System.IntPtr): void;
      }
      export class ComAwareEventInfo {
        constructor(type: System.Type, eventName: string);
        Attributes: System.Reflection.EventAttributes;
        DeclaringType: System.Type;
        Name: string;
        ReflectedType: System.Type;
        MemberType: System.Reflection.MemberTypes;
        IsSpecialName: boolean;
        AddMethod: System.Reflection.MethodInfo;
        RemoveMethod: System.Reflection.MethodInfo;
        RaiseMethod: System.Reflection.MethodInfo;
        IsMulticast: boolean;
        EventHandlerType: System.Type;
        Module: System.Reflection.Module;
        CustomAttributes: System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>;
        MetadataToken: number;
        AddEventHandler(target: any, handler: System.Delegate): void;
        RemoveEventHandler(target: any, handler: System.Delegate): void;
        GetAddMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetRaiseMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetRemoveMethod(nonPublic: boolean): System.Reflection.MethodInfo;
        GetCustomAttributes(attributeType: System.Type, inherit: boolean): any[];
        GetCustomAttributes(inherit: boolean): any[];
        IsDefined(attributeType: System.Type, inherit: boolean): boolean;
        GetOtherMethods(): System.Reflection.MethodInfo[];
        GetOtherMethods(nonPublic: boolean): System.Reflection.MethodInfo[];
        GetAddMethod(): System.Reflection.MethodInfo;
        GetRemoveMethod(): System.Reflection.MethodInfo;
        GetRaiseMethod(): System.Reflection.MethodInfo;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo): boolean;
        GetCustomAttributesData(): System.Reflection.CustomAttributeData[];
        GetType(): System.Type;
        ToString(): string;
      }
      export class HandleCollector {
        constructor(name: string, initialThreshold: number);
        constructor(name: string, initialThreshold: number, maximumThreshold: number);
        Count: number;
        InitialThreshold: number;
        MaximumThreshold: number;
        Name: string;
        Add(): void;
        Remove(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class StandardOleMarshalObject {
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export namespace ComTypes {
        export interface IConnectionPoint {
          Unadvise(dwCookie: number): void;
        }
        export interface IConnectionPointContainer {
        }
        export class BIND_OPTS {
          cbStruct: number;
          grfFlags: number;
          grfMode: number;
          dwTickCountDeadline: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export interface IBindCtx {
          RegisterObjectBound(punk: any): void;
          RevokeObjectBound(punk: any): void;
          ReleaseBoundObjects(): void;
          RegisterObjectParam(pszKey: string, punk: any): void;
          RevokeObjectParam(pszKey: string): number;
        }
        export interface IEnumConnectionPoints {
          Next(celt: number, rgelt: System.Runtime.InteropServices.ComTypes.IConnectionPoint[], pceltFetched: System.IntPtr): number;
          Skip(celt: number): number;
          Reset(): void;
        }
        export class CONNECTDATA {
          pUnk: any; // System.Object
          dwCookie: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export interface IEnumConnections {
          Next(celt: number, rgelt: System.Runtime.InteropServices.ComTypes.CONNECTDATA[], pceltFetched: System.IntPtr): number;
          Skip(celt: number): number;
          Reset(): void;
        }
        export interface IEnumMoniker {
          Next(celt: number, rgelt: System.Runtime.InteropServices.ComTypes.IMoniker[], pceltFetched: System.IntPtr): number;
          Skip(celt: number): number;
          Reset(): void;
        }
        export interface IEnumString {
          Next(celt: number, rgelt: string[], pceltFetched: System.IntPtr): number;
          Skip(celt: number): number;
          Reset(): void;
        }
        export interface IEnumVARIANT {
          Next(celt: number, rgVar: any[], pceltFetched: System.IntPtr): number;
          Skip(celt: number): number;
          Reset(): number;
          Clone(): System.Runtime.InteropServices.ComTypes.IEnumVARIANT;
        }
        export class FILETIME {
          dwLowDateTime: number;
          dwHighDateTime: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export interface IMoniker {
          IsDirty(): number;
          Load(pStm: System.Runtime.InteropServices.ComTypes.IStream): void;
          Save(pStm: System.Runtime.InteropServices.ComTypes.IStream, fClearDirty: boolean): void;
          IsEqual(pmkOtherMoniker: System.Runtime.InteropServices.ComTypes.IMoniker): number;
          IsRunning(pbc: System.Runtime.InteropServices.ComTypes.IBindCtx, pmkToLeft: System.Runtime.InteropServices.ComTypes.IMoniker, pmkNewlyRunning: System.Runtime.InteropServices.ComTypes.IMoniker): number;
        }
        export interface IPersistFile {
          IsDirty(): number;
          Load(pszFileName: string, dwMode: number): void;
          Save(pszFileName: string, fRemember: boolean): void;
          SaveCompleted(pszFileName: string): void;
        }
        export interface IRunningObjectTable {
          Register(grfFlags: number, punkObject: any, pmkObjectName: System.Runtime.InteropServices.ComTypes.IMoniker): number;
          Revoke(dwRegister: number): void;
          IsRunning(pmkObjectName: System.Runtime.InteropServices.ComTypes.IMoniker): number;
        }
        export class STATSTG {
          pwcsName: string;
          type: number;
          cbSize: number;
          mtime: System.Runtime.InteropServices.ComTypes.FILETIME;
          ctime: System.Runtime.InteropServices.ComTypes.FILETIME;
          atime: System.Runtime.InteropServices.ComTypes.FILETIME;
          grfMode: number;
          grfLocksSupported: number;
          clsid: System.Guid;
          grfStateBits: number;
          reserved: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export interface IStream {
          Read(pv: Byte[], cb: number, pcbRead: System.IntPtr): void;
          Write(pv: Byte[], cb: number, pcbWritten: System.IntPtr): void;
          Seek(dlibMove: number, dwOrigin: number, plibNewPosition: System.IntPtr): void;
          SetSize(libNewSize: number): void;
          CopyTo(pstm: System.Runtime.InteropServices.ComTypes.IStream, cb: number, pcbRead: System.IntPtr, pcbWritten: System.IntPtr): void;
          Commit(grfCommitFlags: number): void;
          Revert(): void;
          LockRegion(libOffset: number, cb: number, dwLockType: number): void;
          UnlockRegion(libOffset: number, cb: number, dwLockType: number): void;
        }
        export enum DESCKIND {
          DESCKIND_NONE = 0,
          DESCKIND_FUNCDESC = 1,
          DESCKIND_VARDESC = 2,
          DESCKIND_TYPECOMP = 3,
          DESCKIND_IMPLICITAPPOBJ = 4,
          DESCKIND_MAX = 5,
        }
        export class BINDPTR {
          lpfuncdesc: System.IntPtr;
          lpvardesc: System.IntPtr;
          lptcomp: System.IntPtr;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export interface ITypeComp {
        }
        export enum TYPEKIND {
          TKIND_ENUM = 0,
          TKIND_RECORD = 1,
          TKIND_MODULE = 2,
          TKIND_INTERFACE = 3,
          TKIND_DISPATCH = 4,
          TKIND_COCLASS = 5,
          TKIND_ALIAS = 6,
          TKIND_UNION = 7,
          TKIND_MAX = 8,
        }
        export enum TYPEFLAGS {
          TYPEFLAG_FAPPOBJECT = 1,
          TYPEFLAG_FCANCREATE = 2,
          TYPEFLAG_FLICENSED = 4,
          TYPEFLAG_FPREDECLID = 8,
          TYPEFLAG_FHIDDEN = 16,
          TYPEFLAG_FCONTROL = 32,
          TYPEFLAG_FDUAL = 64,
          TYPEFLAG_FNONEXTENSIBLE = 128,
          TYPEFLAG_FOLEAUTOMATION = 256,
          TYPEFLAG_FRESTRICTED = 512,
          TYPEFLAG_FAGGREGATABLE = 1024,
          TYPEFLAG_FREPLACEABLE = 2048,
          TYPEFLAG_FDISPATCHABLE = 4096,
          TYPEFLAG_FREVERSEBIND = 8192,
          TYPEFLAG_FPROXY = 16384,
        }
        export enum IMPLTYPEFLAGS {
          IMPLTYPEFLAG_FDEFAULT = 1,
          IMPLTYPEFLAG_FSOURCE = 2,
          IMPLTYPEFLAG_FRESTRICTED = 4,
          IMPLTYPEFLAG_FDEFAULTVTABLE = 8,
        }
        export class TYPEATTR {
          static MEMBER_ID_NIL: number;
          guid: System.Guid;
          lcid: number;
          dwReserved: number;
          memidConstructor: number;
          memidDestructor: number;
          lpstrSchema: System.IntPtr;
          cbSizeInstance: number;
          typekind: System.Runtime.InteropServices.ComTypes.TYPEKIND;
          cFuncs: number;
          cVars: number;
          cImplTypes: number;
          cbSizeVft: number;
          cbAlignment: number;
          wTypeFlags: System.Runtime.InteropServices.ComTypes.TYPEFLAGS;
          wMajorVerNum: number;
          wMinorVerNum: number;
          tdescAlias: System.Runtime.InteropServices.ComTypes.TYPEDESC;
          idldescType: System.Runtime.InteropServices.ComTypes.IDLDESC;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class FUNCDESC {
          memid: number;
          lprgscode: System.IntPtr;
          lprgelemdescParam: System.IntPtr;
          funckind: System.Runtime.InteropServices.ComTypes.FUNCKIND;
          invkind: System.Runtime.InteropServices.ComTypes.INVOKEKIND;
          callconv: System.Runtime.InteropServices.ComTypes.CALLCONV;
          cParams: number;
          cParamsOpt: number;
          oVft: number;
          cScodes: number;
          elemdescFunc: System.Runtime.InteropServices.ComTypes.ELEMDESC;
          wFuncFlags: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export enum IDLFLAG {
          IDLFLAG_NONE = 0,
          IDLFLAG_FIN = 1,
          IDLFLAG_FOUT = 2,
          IDLFLAG_FLCID = 4,
          IDLFLAG_FRETVAL = 8,
        }
        export class IDLDESC {
          dwReserved: System.IntPtr;
          wIDLFlags: System.Runtime.InteropServices.ComTypes.IDLFLAG;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export enum PARAMFLAG {
          PARAMFLAG_NONE = 0,
          PARAMFLAG_FIN = 1,
          PARAMFLAG_FOUT = 2,
          PARAMFLAG_FLCID = 4,
          PARAMFLAG_FRETVAL = 8,
          PARAMFLAG_FOPT = 16,
          PARAMFLAG_FHASDEFAULT = 32,
          PARAMFLAG_FHASCUSTDATA = 64,
        }
        export class PARAMDESC {
          lpVarValue: System.IntPtr;
          wParamFlags: System.Runtime.InteropServices.ComTypes.PARAMFLAG;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class TYPEDESC {
          lpValue: System.IntPtr;
          vt: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class ELEMDESC {
          tdesc: System.Runtime.InteropServices.ComTypes.TYPEDESC;
          desc: System.Runtime.InteropServices.ComTypes.ELEMDESC_DESCUNION;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class ELEMDESC_DESCUNION {
          idldesc: System.Runtime.InteropServices.ComTypes.IDLDESC;
          paramdesc: System.Runtime.InteropServices.ComTypes.PARAMDESC;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export enum VARKIND {
          VAR_PERINSTANCE = 0,
          VAR_STATIC = 1,
          VAR_CONST = 2,
          VAR_DISPATCH = 3,
        }
        export class VARDESC {
          memid: number;
          lpstrSchema: string;
          desc: System.Runtime.InteropServices.ComTypes.VARDESC_DESCUNION;
          elemdescVar: System.Runtime.InteropServices.ComTypes.ELEMDESC;
          wVarFlags: number;
          varkind: System.Runtime.InteropServices.ComTypes.VARKIND;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class VARDESC_DESCUNION {
          oInst: number;
          lpvarValue: System.IntPtr;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class DISPPARAMS {
          rgvarg: System.IntPtr;
          rgdispidNamedArgs: System.IntPtr;
          cArgs: number;
          cNamedArgs: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class EXCEPINFO {
          wCode: number;
          wReserved: number;
          bstrSource: string;
          bstrDescription: string;
          bstrHelpFile: string;
          dwHelpContext: number;
          pvReserved: System.IntPtr;
          pfnDeferredFillIn: System.IntPtr;
          scode: number;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export enum FUNCKIND {
          FUNC_VIRTUAL = 0,
          FUNC_PUREVIRTUAL = 1,
          FUNC_NONVIRTUAL = 2,
          FUNC_STATIC = 3,
          FUNC_DISPATCH = 4,
        }
        export enum INVOKEKIND {
          INVOKE_FUNC = 1,
          INVOKE_PROPERTYGET = 2,
          INVOKE_PROPERTYPUT = 4,
          INVOKE_PROPERTYPUTREF = 8,
        }
        export enum CALLCONV {
          CC_CDECL = 1,
          CC_MSCPASCAL = 2,
          CC_PASCAL = 2,
          CC_MACPASCAL = 3,
          CC_STDCALL = 4,
          CC_RESERVED = 5,
          CC_SYSCALL = 6,
          CC_MPWCDECL = 7,
          CC_MPWPASCAL = 8,
          CC_MAX = 9,
        }
        export enum FUNCFLAGS {
          FUNCFLAG_FRESTRICTED = 1,
          FUNCFLAG_FSOURCE = 2,
          FUNCFLAG_FBINDABLE = 4,
          FUNCFLAG_FREQUESTEDIT = 8,
          FUNCFLAG_FDISPLAYBIND = 16,
          FUNCFLAG_FDEFAULTBIND = 32,
          FUNCFLAG_FHIDDEN = 64,
          FUNCFLAG_FUSESGETLASTERROR = 128,
          FUNCFLAG_FDEFAULTCOLLELEM = 256,
          FUNCFLAG_FUIDEFAULT = 512,
          FUNCFLAG_FNONBROWSABLE = 1024,
          FUNCFLAG_FREPLACEABLE = 2048,
          FUNCFLAG_FIMMEDIATEBIND = 4096,
        }
        export enum VARFLAGS {
          VARFLAG_FREADONLY = 1,
          VARFLAG_FSOURCE = 2,
          VARFLAG_FBINDABLE = 4,
          VARFLAG_FREQUESTEDIT = 8,
          VARFLAG_FDISPLAYBIND = 16,
          VARFLAG_FDEFAULTBIND = 32,
          VARFLAG_FHIDDEN = 64,
          VARFLAG_FRESTRICTED = 128,
          VARFLAG_FDEFAULTCOLLELEM = 256,
          VARFLAG_FUIDEFAULT = 512,
          VARFLAG_FNONBROWSABLE = 1024,
          VARFLAG_FREPLACEABLE = 2048,
          VARFLAG_FIMMEDIATEBIND = 4096,
        }
        export interface ITypeInfo {
          GetIDsOfNames(rgszNames: string[], cNames: number, pMemId: number[]): void;
          GetDllEntry(memid: number, invKind: System.Runtime.InteropServices.ComTypes.INVOKEKIND, pBstrDllName: System.IntPtr, pBstrName: System.IntPtr, pwOrdinal: System.IntPtr): void;
          ReleaseTypeAttr(pTypeAttr: System.IntPtr): void;
          ReleaseFuncDesc(pFuncDesc: System.IntPtr): void;
          ReleaseVarDesc(pVarDesc: System.IntPtr): void;
        }
        export interface ITypeInfo2 {
          GetIDsOfNames(rgszNames: string[], cNames: number, pMemId: number[]): void;
          GetDllEntry(memid: number, invKind: System.Runtime.InteropServices.ComTypes.INVOKEKIND, pBstrDllName: System.IntPtr, pBstrName: System.IntPtr, pwOrdinal: System.IntPtr): void;
          ReleaseTypeAttr(pTypeAttr: System.IntPtr): void;
          ReleaseFuncDesc(pFuncDesc: System.IntPtr): void;
          ReleaseVarDesc(pVarDesc: System.IntPtr): void;
          GetAllCustData(pCustData: System.IntPtr): void;
          GetAllFuncCustData(index: number, pCustData: System.IntPtr): void;
          GetAllParamCustData(indexFunc: number, indexParam: number, pCustData: System.IntPtr): void;
          GetAllVarCustData(index: number, pCustData: System.IntPtr): void;
          GetAllImplTypeCustData(index: number, pCustData: System.IntPtr): void;
        }
        export enum SYSKIND {
          SYS_WIN16 = 0,
          SYS_WIN32 = 1,
          SYS_MAC = 2,
          SYS_WIN64 = 3,
        }
        export enum LIBFLAGS {
          LIBFLAG_FRESTRICTED = 1,
          LIBFLAG_FCONTROL = 2,
          LIBFLAG_FHIDDEN = 4,
          LIBFLAG_FHASDISKIMAGE = 8,
        }
        export class TYPELIBATTR {
          guid: System.Guid;
          lcid: number;
          syskind: System.Runtime.InteropServices.ComTypes.SYSKIND;
          wMajorVerNum: number;
          wMinorVerNum: number;
          wLibFlags: System.Runtime.InteropServices.ComTypes.LIBFLAGS;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export interface ITypeLib {
          GetTypeInfoCount(): number;
          IsName(szNameBuf: string, lHashVal: number): boolean;
          ReleaseTLibAttr(pTLibAttr: System.IntPtr): void;
        }
        export interface ITypeLib2 {
          GetTypeInfoCount(): number;
          IsName(szNameBuf: string, lHashVal: number): boolean;
          ReleaseTLibAttr(pTLibAttr: System.IntPtr): void;
          GetAllCustData(pCustData: System.IntPtr): void;
        }
        export enum ADVF {
          ADVF_NODATA = 1,
          ADVF_PRIMEFIRST = 2,
          ADVF_ONLYONCE = 4,
          ADVFCACHE_NOHANDLER = 8,
          ADVFCACHE_FORCEBUILTIN = 16,
          ADVFCACHE_ONSAVE = 32,
          ADVF_DATAONSTOP = 64,
        }
        export enum DATADIR {
          DATADIR_GET = 1,
          DATADIR_SET = 2,
        }
        export enum DVASPECT {
          DVASPECT_CONTENT = 1,
          DVASPECT_THUMBNAIL = 2,
          DVASPECT_ICON = 4,
          DVASPECT_DOCPRINT = 8,
        }
        export class FORMATETC {
          cfFormat: number;
          dwAspect: System.Runtime.InteropServices.ComTypes.DVASPECT;
          lindex: number;
          ptd: System.IntPtr;
          tymed: System.Runtime.InteropServices.ComTypes.TYMED;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export interface IAdviseSink {
          OnClose(): void;
          OnRename(moniker: System.Runtime.InteropServices.ComTypes.IMoniker): void;
          OnSave(): void;
          OnViewChange(aspect: number, index: number): void;
        }
        export interface IDataObject {
          DUnadvise(connection: number): void;
          EnumFormatEtc(direction: System.Runtime.InteropServices.ComTypes.DATADIR): System.Runtime.InteropServices.ComTypes.IEnumFORMATETC;
        }
        export interface IEnumFORMATETC {
          Next(celt: number, rgelt: System.Runtime.InteropServices.ComTypes.FORMATETC[], pceltFetched: number[]): number;
          Reset(): number;
          Skip(celt: number): number;
        }
        export interface IEnumSTATDATA {
          Next(celt: number, rgelt: System.Runtime.InteropServices.ComTypes.STATDATA[], pceltFetched: number[]): number;
          Reset(): number;
          Skip(celt: number): number;
        }
        export class STATDATA {
          advf: System.Runtime.InteropServices.ComTypes.ADVF;
          advSink: System.Runtime.InteropServices.ComTypes.IAdviseSink;
          connection: number;
          formatetc: System.Runtime.InteropServices.ComTypes.FORMATETC;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class STGMEDIUM {
          pUnkForRelease: any; // System.Object
          tymed: System.Runtime.InteropServices.ComTypes.TYMED;
          unionmember: System.IntPtr;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export enum TYMED {
          TYMED_HGLOBAL = 1,
          TYMED_FILE = 2,
          TYMED_ISTREAM = 4,
          TYMED_ISTORAGE = 8,
          TYMED_GDI = 16,
          TYMED_MFPICT = 32,
          TYMED_ENHMF = 64,
          TYMED_NULL = 0,
        }
      }
      export namespace Expando {
        export interface IExpando {
          AddField(name: string): System.Reflection.FieldInfo;
          AddProperty(name: string): System.Reflection.PropertyInfo;
          AddMethod(name: string, method: System.Delegate): System.Reflection.MethodInfo;
          RemoveMember(m: System.Reflection.MemberInfo): void;
        }
      }
      export namespace WindowsRuntime {
        export class EventRegistrationToken {
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class EventRegistrationTokenTable<T = any> {
          constructor();
          InvocationList: T;
          AddEventHandler(handler: T): System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken;
          RemoveEventHandler(token: System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken): void;
          RemoveEventHandler(handler: T): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export interface IActivationFactory {
          ActivateInstance(): any;
        }
        export class WindowsRuntimeMarshal {
          static RemoveAllEventHandlers(removeMethod: ((obj: System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken) => void)): void;
          static GetActivationFactory(type: System.Type): System.Runtime.InteropServices.WindowsRuntime.IActivationFactory;
          static StringToHString(s: string): System.IntPtr;
          static PtrToStringHString(ptr: System.IntPtr): string;
          static FreeHString(ptr: System.IntPtr): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class DesignerNamespaceResolveEventArgs {
          constructor(namespaceName: string);
          NamespaceName: string;
          ResolvedAssemblyFiles: string[];
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class NamespaceResolveEventArgs {
          constructor(namespaceName: string, requestingAssembly: System.Reflection.Assembly);
          NamespaceName: string;
          RequestingAssembly: System.Reflection.Assembly;
          ResolvedAssemblies: System.Reflection.Assembly[];
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class WindowsRuntimeMetadata {
          static ResolveNamespace(namespaceName: string, packageGraphFilePaths: any): any;
          static ResolveNamespace(namespaceName: string, windowsSdkFilePath: string, packageGraphFilePaths: any): any;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
      }
    }
    export namespace Remoting {
      export class ActivatedClientTypeEntry {
        constructor(type: System.Type, appUrl: string);
        constructor(typeName: string, assemblyName: string, appUrl: string);
        ApplicationUrl: string;
        ContextAttributes: System.Runtime.Remoting.Contexts.IContextAttribute[];
        ObjectType: System.Type;
        AssemblyName: string;
        TypeName: string;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class ActivatedServiceTypeEntry {
        constructor(type: System.Type);
        constructor(typeName: string, assemblyName: string);
        ContextAttributes: System.Runtime.Remoting.Contexts.IContextAttribute[];
        ObjectType: System.Type;
        AssemblyName: string;
        TypeName: string;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum CustomErrorsModes {
        On = 0,
        Off = 1,
        RemoteOnly = 2,
      }
      export interface IChannelInfo {
        ChannelData: any[];
      }
      export interface IEnvoyInfo {
        EnvoySinks: System.Runtime.Remoting.Messaging.IMessageSink;
      }
      export interface IObjectHandle {
        Unwrap(): any;
      }
      export interface IRemotingTypeInfo {
        TypeName: string;
        CanCastTo(fromType: System.Type, o: any): boolean;
      }
      export class InternalRemotingServices {
        constructor();
        static DebugOutChnl(s: string): void;
        static GetCachedSoapAttribute(reflectionObject: any): any;
        static RemotingAssert(condition: boolean, message: string): void;
        static RemotingTrace(...messages: any[]): void;
        static SetServerIdentity(m: System.Runtime.Remoting.Messaging.MethodCall, srvID: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ObjRef {
        constructor();
        constructor(o: System.MarshalByRefObject, requestedType: System.Type);
        ChannelInfo: System.Runtime.Remoting.IChannelInfo;
        EnvoyInfo: System.Runtime.Remoting.IEnvoyInfo;
        TypeInfo: System.Runtime.Remoting.IRemotingTypeInfo;
        URI: string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetRealObject(context: System.Runtime.Serialization.StreamingContext): any;
        IsFromThisAppDomain(): boolean;
        IsFromThisProcess(): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ObjectHandle {
        constructor(o: any);
        InitializeLifetimeService(): any;
        Unwrap(): any;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RemotingConfiguration {
        static ApplicationId: string;
        static ApplicationName: string;
        static CustomErrorsMode: System.Runtime.Remoting.CustomErrorsModes;
        static ProcessId: string;
        static Configure(filename: string, ensureSecurity: boolean): void;
        static Configure(filename: string): void;
        static GetRegisteredActivatedClientTypes(): System.Runtime.Remoting.ActivatedClientTypeEntry[];
        static GetRegisteredActivatedServiceTypes(): System.Runtime.Remoting.ActivatedServiceTypeEntry[];
        static GetRegisteredWellKnownClientTypes(): System.Runtime.Remoting.WellKnownClientTypeEntry[];
        static GetRegisteredWellKnownServiceTypes(): System.Runtime.Remoting.WellKnownServiceTypeEntry[];
        static IsActivationAllowed(svrType: System.Type): boolean;
        static IsRemotelyActivatedClientType(svrType: System.Type): System.Runtime.Remoting.ActivatedClientTypeEntry;
        static IsRemotelyActivatedClientType(typeName: string, assemblyName: string): System.Runtime.Remoting.ActivatedClientTypeEntry;
        static IsWellKnownClientType(svrType: System.Type): System.Runtime.Remoting.WellKnownClientTypeEntry;
        static IsWellKnownClientType(typeName: string, assemblyName: string): System.Runtime.Remoting.WellKnownClientTypeEntry;
        static RegisterActivatedClientType(entry: System.Runtime.Remoting.ActivatedClientTypeEntry): void;
        static RegisterActivatedClientType(type: System.Type, appUrl: string): void;
        static RegisterActivatedServiceType(entry: System.Runtime.Remoting.ActivatedServiceTypeEntry): void;
        static RegisterActivatedServiceType(type: System.Type): void;
        static RegisterWellKnownClientType(type: System.Type, objectUrl: string): void;
        static RegisterWellKnownClientType(entry: System.Runtime.Remoting.WellKnownClientTypeEntry): void;
        static RegisterWellKnownServiceType(type: System.Type, objectUri: string, mode: System.Runtime.Remoting.WellKnownObjectMode): void;
        static RegisterWellKnownServiceType(entry: System.Runtime.Remoting.WellKnownServiceTypeEntry): void;
        static CustomErrorsEnabled(isLocalRequest: boolean): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RemotingException {
        constructor();
        constructor(message: string);
        constructor(message: string, InnerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class RemotingServices {
        static IsTransparentProxy(proxy: any): boolean;
        static ExecuteMessage(target: System.MarshalByRefObject, reqMsg: System.Runtime.Remoting.Messaging.IMethodCallMessage): System.Runtime.Remoting.Messaging.IMethodReturnMessage;
        static Connect(classToProxy: System.Type, url: string): any;
        static Connect(classToProxy: System.Type, url: string, data: any): any;
        static Disconnect(obj: System.MarshalByRefObject): boolean;
        static GetServerTypeForUri(URI: string): System.Type;
        static GetObjectUri(obj: System.MarshalByRefObject): string;
        static Unmarshal(objectRef: System.Runtime.Remoting.ObjRef): any;
        static Unmarshal(objectRef: System.Runtime.Remoting.ObjRef, fRefine: boolean): any;
        static Marshal(Obj: System.MarshalByRefObject): System.Runtime.Remoting.ObjRef;
        static Marshal(Obj: System.MarshalByRefObject, URI: string): System.Runtime.Remoting.ObjRef;
        static Marshal(Obj: System.MarshalByRefObject, ObjURI: string, RequestedType: System.Type): System.Runtime.Remoting.ObjRef;
        static GetRealProxy(proxy: any): System.Runtime.Remoting.Proxies.RealProxy;
        static GetMethodBaseFromMethodMessage(msg: System.Runtime.Remoting.Messaging.IMethodMessage): System.Reflection.MethodBase;
        static GetObjectData(obj: any, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        static GetObjRefForProxy(obj: System.MarshalByRefObject): System.Runtime.Remoting.ObjRef;
        static GetLifetimeService(obj: System.MarshalByRefObject): any;
        static GetEnvoyChainForProxy(obj: System.MarshalByRefObject): System.Runtime.Remoting.Messaging.IMessageSink;
        static LogRemotingStage(stage: number): void;
        static GetSessionIdForMethodMessage(msg: System.Runtime.Remoting.Messaging.IMethodMessage): string;
        static IsMethodOverloaded(msg: System.Runtime.Remoting.Messaging.IMethodMessage): boolean;
        static IsObjectOutOfAppDomain(tp: any): boolean;
        static IsObjectOutOfContext(tp: any): boolean;
        static IsOneWay(method: System.Reflection.MethodBase): boolean;
        static SetObjectUriForMarshal(obj: System.MarshalByRefObject, uri: string): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RemotingTimeoutException {
        constructor();
        constructor(message: string);
        constructor(message: string, InnerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class ServerException {
        constructor();
        constructor(message: string);
        constructor(message: string, InnerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class SoapServices {
        static XmlNsForClrType: string;
        static XmlNsForClrTypeWithAssembly: string;
        static XmlNsForClrTypeWithNs: string;
        static XmlNsForClrTypeWithNsAndAssembly: string;
        static CodeXmlNamespaceForClrTypeNamespace(typeNamespace: string, assemblyName: string): string;
        static GetInteropTypeFromXmlElement(xmlElement: string, xmlNamespace: string): System.Type;
        static GetInteropTypeFromXmlType(xmlType: string, xmlTypeNamespace: string): System.Type;
        static GetSoapActionFromMethodBase(mb: System.Reflection.MethodBase): string;
        static GetXmlNamespaceForMethodCall(mb: System.Reflection.MethodBase): string;
        static GetXmlNamespaceForMethodResponse(mb: System.Reflection.MethodBase): string;
        static IsClrTypeNamespace(namespaceString: string): boolean;
        static IsSoapActionValidForMethodBase(soapAction: string, mb: System.Reflection.MethodBase): boolean;
        static PreLoad(assembly: System.Reflection.Assembly): void;
        static PreLoad(type: System.Type): void;
        static RegisterInteropXmlElement(xmlElement: string, xmlNamespace: string, type: System.Type): void;
        static RegisterInteropXmlType(xmlType: string, xmlTypeNamespace: string, type: System.Type): void;
        static RegisterSoapActionForMethodBase(mb: System.Reflection.MethodBase): void;
        static RegisterSoapActionForMethodBase(mb: System.Reflection.MethodBase, soapAction: string): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class TypeEntry {
        AssemblyName: string;
        TypeName: string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class WellKnownClientTypeEntry {
        constructor(type: System.Type, objectUrl: string);
        constructor(typeName: string, assemblyName: string, objectUrl: string);
        ApplicationUrl: string;
        ObjectType: System.Type;
        ObjectUrl: string;
        AssemblyName: string;
        TypeName: string;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum WellKnownObjectMode {
        Singleton = 1,
        SingleCall = 2,
      }
      export class WellKnownServiceTypeEntry {
        constructor(type: System.Type, objectUri: string, mode: System.Runtime.Remoting.WellKnownObjectMode);
        constructor(typeName: string, assemblyName: string, objectUri: string, mode: System.Runtime.Remoting.WellKnownObjectMode);
        ContextAttributes: System.Runtime.Remoting.Contexts.IContextAttribute[];
        Mode: System.Runtime.Remoting.WellKnownObjectMode;
        ObjectType: System.Type;
        ObjectUri: string;
        AssemblyName: string;
        TypeName: string;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export namespace Activation {
        export enum ActivatorLevel {
          Construction = 4,
          Context = 8,
          AppDomain = 12,
          Process = 16,
          Machine = 20,
        }
        export interface IActivator {
          Level: System.Runtime.Remoting.Activation.ActivatorLevel;
          NextActivator: System.Runtime.Remoting.Activation.IActivator;
          Activate(msg: System.Runtime.Remoting.Activation.IConstructionCallMessage): System.Runtime.Remoting.Activation.IConstructionReturnMessage;
        }
        export interface IConstructionCallMessage {
          ActivationType: System.Type;
          ActivationTypeName: string;
          Activator: System.Runtime.Remoting.Activation.IActivator;
          CallSiteActivationAttributes: any[];
          ContextProperties: System.Collections.IList;
        }
        export interface IConstructionReturnMessage {
        }
      }
      export namespace Channels {
        export class BaseChannelObjectWithProperties {
          Count: number;
          IsFixedSize: boolean;
          IsReadOnly: boolean;
          IsSynchronized: boolean;
          Keys: System.Collections.ICollection;
          Properties: System.Collections.IDictionary;
          SyncRoot: any; // System.Object
          Values: System.Collections.ICollection;
          Add(key: any, value: any): void;
          Clear(): void;
          Contains(key: any): boolean;
          CopyTo(array: System.Array, index: number): void;
          GetEnumerator(): System.Collections.IDictionaryEnumerator;
          Remove(key: any): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class BaseChannelSinkWithProperties {
          Count: number;
          IsFixedSize: boolean;
          IsReadOnly: boolean;
          IsSynchronized: boolean;
          Keys: System.Collections.ICollection;
          Properties: System.Collections.IDictionary;
          SyncRoot: any; // System.Object
          Values: System.Collections.ICollection;
          Add(key: any, value: any): void;
          Clear(): void;
          Contains(key: any): boolean;
          CopyTo(array: System.Array, index: number): void;
          GetEnumerator(): System.Collections.IDictionaryEnumerator;
          Remove(key: any): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class BaseChannelWithProperties {
          Properties: System.Collections.IDictionary;
          Count: number;
          IsFixedSize: boolean;
          IsReadOnly: boolean;
          IsSynchronized: boolean;
          Keys: System.Collections.ICollection;
          SyncRoot: any; // System.Object
          Values: System.Collections.ICollection;
          Add(key: any, value: any): void;
          Clear(): void;
          Contains(key: any): boolean;
          CopyTo(array: System.Array, index: number): void;
          GetEnumerator(): System.Collections.IDictionaryEnumerator;
          Remove(key: any): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ChannelDataStore {
          constructor(channelURIs: string[]);
          ChannelUris: string[];
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ChannelServices {
          static RegisteredChannels: System.Runtime.Remoting.Channels.IChannel[];
          static CreateServerChannelSinkChain(provider: System.Runtime.Remoting.Channels.IServerChannelSinkProvider, channel: System.Runtime.Remoting.Channels.IChannelReceiver): System.Runtime.Remoting.Channels.IServerChannelSink;
          static GetChannel(name: string): System.Runtime.Remoting.Channels.IChannel;
          static GetChannelSinkProperties(obj: any): System.Collections.IDictionary;
          static GetUrlsForObject(obj: System.MarshalByRefObject): string[];
          static RegisterChannel(chnl: System.Runtime.Remoting.Channels.IChannel): void;
          static RegisterChannel(chnl: System.Runtime.Remoting.Channels.IChannel, ensureSecurity: boolean): void;
          static SyncDispatchMessage(msg: System.Runtime.Remoting.Messaging.IMessage): System.Runtime.Remoting.Messaging.IMessage;
          static AsyncDispatchMessage(msg: System.Runtime.Remoting.Messaging.IMessage, replySink: System.Runtime.Remoting.Messaging.IMessageSink): System.Runtime.Remoting.Messaging.IMessageCtrl;
          static UnregisterChannel(chnl: System.Runtime.Remoting.Channels.IChannel): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ClientChannelSinkStack {
          constructor();
          constructor(replySink: System.Runtime.Remoting.Messaging.IMessageSink);
          AsyncProcessResponse(headers: System.Runtime.Remoting.Channels.ITransportHeaders, stream: System.IO.Stream): void;
          DispatchException(e: System.Exception): void;
          DispatchReplyMessage(msg: System.Runtime.Remoting.Messaging.IMessage): void;
          Pop(sink: System.Runtime.Remoting.Channels.IClientChannelSink): any;
          Push(sink: System.Runtime.Remoting.Channels.IClientChannelSink, state: any): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export interface IChannel {
          ChannelName: string;
          ChannelPriority: number;
        }
        export interface IChannelDataStore {
          ChannelUris: string[];
        }
        export interface IChannelReceiver {
          ChannelData: any; // System.Object
          GetUrlsForUri(objectURI: string): string[];
          StartListening(data: any): void;
          StopListening(data: any): void;
        }
        export interface IChannelReceiverHook {
          ChannelScheme: string;
          ChannelSinkChain: System.Runtime.Remoting.Channels.IServerChannelSink;
          WantsToListen: boolean;
          AddHookChannelUri(channelUri: string): void;
        }
        export interface IChannelSender {
        }
        export interface IChannelSinkBase {
          Properties: System.Collections.IDictionary;
        }
        export interface IClientChannelSink {
          NextChannelSink: System.Runtime.Remoting.Channels.IClientChannelSink;
          AsyncProcessRequest(sinkStack: System.Runtime.Remoting.Channels.IClientChannelSinkStack, msg: System.Runtime.Remoting.Messaging.IMessage, headers: System.Runtime.Remoting.Channels.ITransportHeaders, stream: System.IO.Stream): void;
          AsyncProcessResponse(sinkStack: System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack, state: any, headers: System.Runtime.Remoting.Channels.ITransportHeaders, stream: System.IO.Stream): void;
          GetRequestStream(msg: System.Runtime.Remoting.Messaging.IMessage, headers: System.Runtime.Remoting.Channels.ITransportHeaders): System.IO.Stream;
        }
        export interface IClientChannelSinkProvider {
          Next: System.Runtime.Remoting.Channels.IClientChannelSinkProvider;
          CreateSink(channel: System.Runtime.Remoting.Channels.IChannelSender, url: string, remoteChannelData: any): System.Runtime.Remoting.Channels.IClientChannelSink;
        }
        export interface IClientChannelSinkStack {
          Pop(sink: System.Runtime.Remoting.Channels.IClientChannelSink): any;
          Push(sink: System.Runtime.Remoting.Channels.IClientChannelSink, state: any): void;
        }
        export interface IClientFormatterSink {
        }
        export interface IClientFormatterSinkProvider {
        }
        export interface IClientResponseChannelSinkStack {
          AsyncProcessResponse(headers: System.Runtime.Remoting.Channels.ITransportHeaders, stream: System.IO.Stream): void;
          DispatchException(e: System.Exception): void;
          DispatchReplyMessage(msg: System.Runtime.Remoting.Messaging.IMessage): void;
        }
        export interface ISecurableChannel {
          IsSecured: boolean;
        }
        export interface IServerChannelSink {
          NextChannelSink: System.Runtime.Remoting.Channels.IServerChannelSink;
          AsyncProcessResponse(sinkStack: System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack, state: any, msg: System.Runtime.Remoting.Messaging.IMessage, headers: System.Runtime.Remoting.Channels.ITransportHeaders, stream: System.IO.Stream): void;
          GetResponseStream(sinkStack: System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack, state: any, msg: System.Runtime.Remoting.Messaging.IMessage, headers: System.Runtime.Remoting.Channels.ITransportHeaders): System.IO.Stream;
        }
        export interface IServerChannelSinkProvider {
          Next: System.Runtime.Remoting.Channels.IServerChannelSinkProvider;
          CreateSink(channel: System.Runtime.Remoting.Channels.IChannelReceiver): System.Runtime.Remoting.Channels.IServerChannelSink;
          GetChannelData(channelData: System.Runtime.Remoting.Channels.IChannelDataStore): void;
        }
        export interface IServerChannelSinkStack {
          Pop(sink: System.Runtime.Remoting.Channels.IServerChannelSink): any;
          Push(sink: System.Runtime.Remoting.Channels.IServerChannelSink, state: any): void;
          ServerCallback(ar: System.IAsyncResult): void;
          Store(sink: System.Runtime.Remoting.Channels.IServerChannelSink, state: any): void;
          StoreAndDispatch(sink: System.Runtime.Remoting.Channels.IServerChannelSink, state: any): void;
        }
        export interface IServerFormatterSinkProvider {
        }
        export interface IServerResponseChannelSinkStack {
          AsyncProcessResponse(msg: System.Runtime.Remoting.Messaging.IMessage, headers: System.Runtime.Remoting.Channels.ITransportHeaders, stream: System.IO.Stream): void;
          GetResponseStream(msg: System.Runtime.Remoting.Messaging.IMessage, headers: System.Runtime.Remoting.Channels.ITransportHeaders): System.IO.Stream;
        }
        export interface ITransportHeaders {
          GetEnumerator(): System.Collections.IEnumerator;
        }
        export class ServerChannelSinkStack {
          constructor();
          GetResponseStream(msg: System.Runtime.Remoting.Messaging.IMessage, headers: System.Runtime.Remoting.Channels.ITransportHeaders): System.IO.Stream;
          Pop(sink: System.Runtime.Remoting.Channels.IServerChannelSink): any;
          Push(sink: System.Runtime.Remoting.Channels.IServerChannelSink, state: any): void;
          ServerCallback(ar: System.IAsyncResult): void;
          Store(sink: System.Runtime.Remoting.Channels.IServerChannelSink, state: any): void;
          StoreAndDispatch(sink: System.Runtime.Remoting.Channels.IServerChannelSink, state: any): void;
          AsyncProcessResponse(msg: System.Runtime.Remoting.Messaging.IMessage, headers: System.Runtime.Remoting.Channels.ITransportHeaders, stream: System.IO.Stream): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export enum ServerProcessing {
          Complete = 0,
          OneWay = 1,
          Async = 2,
        }
        export class SinkProviderData {
          constructor(name: string);
          Children: System.Collections.IList;
          Name: string;
          Properties: System.Collections.IDictionary;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class TransportHeaders {
          constructor();
          GetEnumerator(): System.Collections.IEnumerator;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
      }
      export namespace Contexts {
        export class Context {
          constructor();
          static DefaultContext: System.Runtime.Remoting.Contexts.Context;
          ContextID: number;
          ContextProperties: System.Runtime.Remoting.Contexts.IContextProperty[];
          static RegisterDynamicProperty(prop: System.Runtime.Remoting.Contexts.IDynamicProperty, obj: System.ContextBoundObject, ctx: System.Runtime.Remoting.Contexts.Context): boolean;
          static UnregisterDynamicProperty(name: string, obj: System.ContextBoundObject, ctx: System.Runtime.Remoting.Contexts.Context): boolean;
          GetProperty(name: string): System.Runtime.Remoting.Contexts.IContextProperty;
          SetProperty(prop: System.Runtime.Remoting.Contexts.IContextProperty): void;
          Freeze(): void;
          ToString(): string;
          DoCallBack(deleg: (() => void)): void;
          static AllocateDataSlot(): System.LocalDataStoreSlot;
          static AllocateNamedDataSlot(name: string): System.LocalDataStoreSlot;
          static FreeNamedDataSlot(name: string): void;
          static GetNamedDataSlot(name: string): System.LocalDataStoreSlot;
          static GetData(slot: System.LocalDataStoreSlot): any;
          static SetData(slot: System.LocalDataStoreSlot, data: any): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
        }
        export class ContextProperty {
          Name: string;
          Property: any; // System.Object
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class CrossContextDelegate {
          constructor(object: any, method: System.IntPtr);
          Method: System.Reflection.MethodInfo;
          Target: any; // System.Object
          Invoke(): void;
          BeginInvoke(callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
          EndInvoke(result: System.IAsyncResult): void;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetInvocationList(): System.Delegate[];
          DynamicInvoke(...args: any[]): any;
          Clone(): any;
          GetType(): System.Type;
          ToString(): string;
        }
        export interface IContextAttribute {
          GetPropertiesForNewContext(msg: System.Runtime.Remoting.Activation.IConstructionCallMessage): void;
          IsContextOK(ctx: System.Runtime.Remoting.Contexts.Context, msg: System.Runtime.Remoting.Activation.IConstructionCallMessage): boolean;
        }
        export interface IContextProperty {
          Name: string;
          Freeze(newContext: System.Runtime.Remoting.Contexts.Context): void;
          IsNewContextOK(newCtx: System.Runtime.Remoting.Contexts.Context): boolean;
        }
        export interface IContextPropertyActivator {
          CollectFromClientContext(msg: System.Runtime.Remoting.Activation.IConstructionCallMessage): void;
          CollectFromServerContext(msg: System.Runtime.Remoting.Activation.IConstructionReturnMessage): void;
          DeliverClientContextToServerContext(msg: System.Runtime.Remoting.Activation.IConstructionCallMessage): boolean;
          DeliverServerContextToClientContext(msg: System.Runtime.Remoting.Activation.IConstructionReturnMessage): boolean;
          IsOKToActivate(msg: System.Runtime.Remoting.Activation.IConstructionCallMessage): boolean;
        }
        export interface IContributeClientContextSink {
          GetClientContextSink(nextSink: System.Runtime.Remoting.Messaging.IMessageSink): System.Runtime.Remoting.Messaging.IMessageSink;
        }
        export interface IContributeDynamicSink {
          GetDynamicSink(): System.Runtime.Remoting.Contexts.IDynamicMessageSink;
        }
        export interface IContributeEnvoySink {
          GetEnvoySink(obj: System.MarshalByRefObject, nextSink: System.Runtime.Remoting.Messaging.IMessageSink): System.Runtime.Remoting.Messaging.IMessageSink;
        }
        export interface IContributeObjectSink {
          GetObjectSink(obj: System.MarshalByRefObject, nextSink: System.Runtime.Remoting.Messaging.IMessageSink): System.Runtime.Remoting.Messaging.IMessageSink;
        }
        export interface IContributeServerContextSink {
          GetServerContextSink(nextSink: System.Runtime.Remoting.Messaging.IMessageSink): System.Runtime.Remoting.Messaging.IMessageSink;
        }
        export interface IDynamicMessageSink {
          ProcessMessageFinish(replyMsg: System.Runtime.Remoting.Messaging.IMessage, bCliSide: boolean, bAsync: boolean): void;
          ProcessMessageStart(reqMsg: System.Runtime.Remoting.Messaging.IMessage, bCliSide: boolean, bAsync: boolean): void;
        }
        export interface IDynamicProperty {
          Name: string;
        }
      }
      export namespace Lifetime {
        export class ClientSponsor {
          constructor();
          constructor(renewalTime: System.TimeSpan);
          RenewalTime: System.TimeSpan;
          Close(): void;
          InitializeLifetimeService(): any;
          Register(obj: System.MarshalByRefObject): boolean;
          Renewal(lease: System.Runtime.Remoting.Lifetime.ILease): System.TimeSpan;
          Unregister(obj: System.MarshalByRefObject): void;
          CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
          GetLifetimeService(): any;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export interface ILease {
          CurrentLeaseTime: System.TimeSpan;
          CurrentState: System.Runtime.Remoting.Lifetime.LeaseState;
          InitialLeaseTime: System.TimeSpan;
          RenewOnCallTime: System.TimeSpan;
          SponsorshipTimeout: System.TimeSpan;
          Register(obj: System.Runtime.Remoting.Lifetime.ISponsor): void;
          Register(obj: System.Runtime.Remoting.Lifetime.ISponsor, renewalTime: System.TimeSpan): void;
          Renew(renewalTime: System.TimeSpan): System.TimeSpan;
          Unregister(obj: System.Runtime.Remoting.Lifetime.ISponsor): void;
        }
        export interface ISponsor {
          Renewal(lease: System.Runtime.Remoting.Lifetime.ILease): System.TimeSpan;
        }
        export enum LeaseState {
          Null = 0,
          Initial = 1,
          Active = 2,
          Renewing = 3,
          Expired = 4,
        }
        export class LifetimeServices {
          constructor();
          static LeaseManagerPollTime: System.TimeSpan;
          static LeaseTime: System.TimeSpan;
          static RenewOnCallTime: System.TimeSpan;
          static SponsorshipTimeout: System.TimeSpan;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
      }
      export namespace Messaging {
        export class CallContext {
          static HostContext: any; // System.Object
          static FreeNamedDataSlot(name: string): void;
          static LogicalGetData(name: string): any;
          static GetData(name: string): any;
          static SetData(name: string, data: any): void;
          static LogicalSetData(name: string, data: any): void;
          static GetHeaders(): System.Runtime.Remoting.Messaging.Header[];
          static SetHeaders(headers: System.Runtime.Remoting.Messaging.Header[]): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export interface ILogicalThreadAffinative {
        }
        export class LogicalCallContext {
          HasInfo: boolean;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          Clone(): any;
          FreeNamedDataSlot(name: string): void;
          GetData(name: string): any;
          SetData(name: string, data: any): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class AsyncResult {
          AsyncState: any; // System.Object
          AsyncWaitHandle: System.Threading.WaitHandle;
          CompletedSynchronously: boolean;
          IsCompleted: boolean;
          EndInvokeCalled: boolean;
          AsyncDelegate: any; // System.Object
          NextSink: System.Runtime.Remoting.Messaging.IMessageSink;
          AsyncProcessMessage(msg: System.Runtime.Remoting.Messaging.IMessage, replySink: System.Runtime.Remoting.Messaging.IMessageSink): System.Runtime.Remoting.Messaging.IMessageCtrl;
          GetReplyMessage(): System.Runtime.Remoting.Messaging.IMessage;
          SetMessageCtrl(mc: System.Runtime.Remoting.Messaging.IMessageCtrl): void;
          SyncProcessMessage(msg: System.Runtime.Remoting.Messaging.IMessage): System.Runtime.Remoting.Messaging.IMessage;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ConstructionCall {
          constructor(m: System.Runtime.Remoting.Messaging.IMessage);
          constructor(headers: System.Runtime.Remoting.Messaging.Header[]);
          ActivationType: System.Type;
          ActivationTypeName: string;
          Activator: System.Runtime.Remoting.Activation.IActivator;
          CallSiteActivationAttributes: any[];
          ContextProperties: System.Collections.IList;
          Properties: System.Collections.IDictionary;
          ArgCount: number;
          Args: any[];
          HasVarArgs: boolean;
          InArgCount: number;
          InArgs: any[];
          LogicalCallContext: System.Runtime.Remoting.Messaging.LogicalCallContext;
          MethodBase: System.Reflection.MethodBase;
          MethodName: string;
          MethodSignature: any; // System.Object
          TypeName: string;
          Uri: string;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetArg(argNum: number): any;
          GetArgName(index: number): string;
          GetInArg(argNum: number): any;
          GetInArgName(index: number): string;
          HeaderHandler(h: System.Runtime.Remoting.Messaging.Header[]): any;
          Init(): void;
          ResolveMethod(): void;
          RootSetObjectData(info: System.Runtime.Serialization.SerializationInfo, ctx: System.Runtime.Serialization.StreamingContext): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ConstructionResponse {
          constructor(h: System.Runtime.Remoting.Messaging.Header[], mcm: System.Runtime.Remoting.Messaging.IMethodCallMessage);
          Properties: System.Collections.IDictionary;
          ArgCount: number;
          Args: any[];
          Exception: System.Exception;
          HasVarArgs: boolean;
          LogicalCallContext: System.Runtime.Remoting.Messaging.LogicalCallContext;
          MethodBase: System.Reflection.MethodBase;
          MethodName: string;
          MethodSignature: any; // System.Object
          OutArgCount: number;
          OutArgs: any[];
          ReturnValue: any; // System.Object
          TypeName: string;
          Uri: string;
          GetArg(argNum: number): any;
          GetArgName(index: number): string;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetOutArg(argNum: number): any;
          GetOutArgName(index: number): string;
          HeaderHandler(h: System.Runtime.Remoting.Messaging.Header[]): any;
          RootSetObjectData(info: System.Runtime.Serialization.SerializationInfo, ctx: System.Runtime.Serialization.StreamingContext): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class Header {
          constructor(_Name: string, _Value: any);
          constructor(_Name: string, _Value: any, _MustUnderstand: boolean);
          constructor(_Name: string, _Value: any, _MustUnderstand: boolean, _HeaderNamespace: string);
          HeaderNamespace: string;
          MustUnderstand: boolean;
          Name: string;
          Value: any; // System.Object
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class HeaderHandler {
          constructor(object: any, method: System.IntPtr);
          Method: System.Reflection.MethodInfo;
          Target: any; // System.Object
          Invoke(headers: System.Runtime.Remoting.Messaging.Header[]): any;
          BeginInvoke(headers: System.Runtime.Remoting.Messaging.Header[], callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
          EndInvoke(result: System.IAsyncResult): any;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetInvocationList(): System.Delegate[];
          DynamicInvoke(...args: any[]): any;
          Clone(): any;
          GetType(): System.Type;
          ToString(): string;
        }
        export interface IMessage {
          Properties: System.Collections.IDictionary;
        }
        export interface IMessageCtrl {
          Cancel(msToCancel: number): void;
        }
        export interface IMessageSink {
          NextSink: System.Runtime.Remoting.Messaging.IMessageSink;
          SyncProcessMessage(msg: System.Runtime.Remoting.Messaging.IMessage): System.Runtime.Remoting.Messaging.IMessage;
          AsyncProcessMessage(msg: System.Runtime.Remoting.Messaging.IMessage, replySink: System.Runtime.Remoting.Messaging.IMessageSink): System.Runtime.Remoting.Messaging.IMessageCtrl;
        }
        export interface IMethodCallMessage {
          InArgCount: number;
          InArgs: any[];
          GetInArg(argNum: number): any;
          GetInArgName(index: number): string;
        }
        export interface IMethodMessage {
          ArgCount: number;
          Args: any[];
          HasVarArgs: boolean;
          LogicalCallContext: System.Runtime.Remoting.Messaging.LogicalCallContext;
          MethodBase: System.Reflection.MethodBase;
          MethodName: string;
          MethodSignature: any; // System.Object
          TypeName: string;
          Uri: string;
          GetArg(argNum: number): any;
          GetArgName(index: number): string;
        }
        export interface IMethodReturnMessage {
          Exception: System.Exception;
          OutArgCount: number;
          OutArgs: any[];
          ReturnValue: any; // System.Object
          GetOutArg(argNum: number): any;
          GetOutArgName(index: number): string;
        }
        export interface IRemotingFormatter {
          Deserialize(serializationStream: System.IO.Stream, handler: ((headers: System.Runtime.Remoting.Messaging.Header[]) => any)): any;
          Serialize(serializationStream: System.IO.Stream, graph: any, headers: System.Runtime.Remoting.Messaging.Header[]): void;
        }
        export class InternalMessageWrapper {
          constructor(msg: System.Runtime.Remoting.Messaging.IMessage);
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class MessageSurrogateFilter {
          constructor(object: any, method: System.IntPtr);
          Method: System.Reflection.MethodInfo;
          Target: any; // System.Object
          Invoke(key: string, value: any): boolean;
          BeginInvoke(key: string, value: any, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
          EndInvoke(result: System.IAsyncResult): boolean;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetInvocationList(): System.Delegate[];
          DynamicInvoke(...args: any[]): any;
          Clone(): any;
          GetType(): System.Type;
          ToString(): string;
        }
        export class MethodCall {
          constructor(h1: System.Runtime.Remoting.Messaging.Header[]);
          constructor(msg: System.Runtime.Remoting.Messaging.IMessage);
          ArgCount: number;
          Args: any[];
          HasVarArgs: boolean;
          InArgCount: number;
          InArgs: any[];
          LogicalCallContext: System.Runtime.Remoting.Messaging.LogicalCallContext;
          MethodBase: System.Reflection.MethodBase;
          MethodName: string;
          MethodSignature: any; // System.Object
          Properties: System.Collections.IDictionary;
          TypeName: string;
          Uri: string;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetArg(argNum: number): any;
          GetArgName(index: number): string;
          GetInArg(argNum: number): any;
          GetInArgName(index: number): string;
          HeaderHandler(h: System.Runtime.Remoting.Messaging.Header[]): any;
          Init(): void;
          ResolveMethod(): void;
          RootSetObjectData(info: System.Runtime.Serialization.SerializationInfo, ctx: System.Runtime.Serialization.StreamingContext): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class MethodCallMessageWrapper {
          constructor(msg: System.Runtime.Remoting.Messaging.IMethodCallMessage);
          ArgCount: number;
          Args: any[];
          HasVarArgs: boolean;
          InArgCount: number;
          InArgs: any[];
          LogicalCallContext: System.Runtime.Remoting.Messaging.LogicalCallContext;
          MethodBase: System.Reflection.MethodBase;
          MethodName: string;
          MethodSignature: any; // System.Object
          Properties: System.Collections.IDictionary;
          TypeName: string;
          Uri: string;
          GetArg(argNum: number): any;
          GetArgName(index: number): string;
          GetInArg(argNum: number): any;
          GetInArgName(index: number): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class MethodResponse {
          constructor(h1: System.Runtime.Remoting.Messaging.Header[], mcm: System.Runtime.Remoting.Messaging.IMethodCallMessage);
          ArgCount: number;
          Args: any[];
          Exception: System.Exception;
          HasVarArgs: boolean;
          LogicalCallContext: System.Runtime.Remoting.Messaging.LogicalCallContext;
          MethodBase: System.Reflection.MethodBase;
          MethodName: string;
          MethodSignature: any; // System.Object
          OutArgCount: number;
          OutArgs: any[];
          Properties: System.Collections.IDictionary;
          ReturnValue: any; // System.Object
          TypeName: string;
          Uri: string;
          GetArg(argNum: number): any;
          GetArgName(index: number): string;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetOutArg(argNum: number): any;
          GetOutArgName(index: number): string;
          HeaderHandler(h: System.Runtime.Remoting.Messaging.Header[]): any;
          RootSetObjectData(info: System.Runtime.Serialization.SerializationInfo, ctx: System.Runtime.Serialization.StreamingContext): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class MethodReturnMessageWrapper {
          constructor(msg: System.Runtime.Remoting.Messaging.IMethodReturnMessage);
          ArgCount: number;
          Args: any[];
          Exception: System.Exception;
          HasVarArgs: boolean;
          LogicalCallContext: System.Runtime.Remoting.Messaging.LogicalCallContext;
          MethodBase: System.Reflection.MethodBase;
          MethodName: string;
          MethodSignature: any; // System.Object
          OutArgCount: number;
          OutArgs: any[];
          Properties: System.Collections.IDictionary;
          ReturnValue: any; // System.Object
          TypeName: string;
          Uri: string;
          GetArg(argNum: number): any;
          GetArgName(index: number): string;
          GetOutArg(argNum: number): any;
          GetOutArgName(index: number): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class RemotingSurrogateSelector {
          constructor();
          Filter: ((key: string, value: any) => boolean);
          ChainSelector(selector: System.Runtime.Serialization.ISurrogateSelector): void;
          GetNextSelector(): System.Runtime.Serialization.ISurrogateSelector;
          GetRootObject(): any;
          SetRootObject(obj: any): void;
          UseSoapFormat(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ReturnMessage {
          constructor(ret: any, outArgs: any[], outArgsCount: number, callCtx: System.Runtime.Remoting.Messaging.LogicalCallContext, mcm: System.Runtime.Remoting.Messaging.IMethodCallMessage);
          constructor(e: System.Exception, mcm: System.Runtime.Remoting.Messaging.IMethodCallMessage);
          ArgCount: number;
          Args: any[];
          HasVarArgs: boolean;
          LogicalCallContext: System.Runtime.Remoting.Messaging.LogicalCallContext;
          MethodBase: System.Reflection.MethodBase;
          MethodName: string;
          MethodSignature: any; // System.Object
          Properties: System.Collections.IDictionary;
          TypeName: string;
          Uri: string;
          Exception: System.Exception;
          OutArgCount: number;
          OutArgs: any[];
          ReturnValue: any; // System.Object
          GetArg(argNum: number): any;
          GetArgName(index: number): string;
          GetOutArg(argNum: number): any;
          GetOutArgName(index: number): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
      }
      export namespace Metadata {
        export enum SoapOption {
          None = 0,
          AlwaysIncludeTypes = 1,
          XsdString = 2,
          EmbedAll = 4,
          Option1 = 8,
          Option2 = 16,
        }
        export enum XmlFieldOrderOption {
          All = 0,
          Sequence = 1,
          Choice = 2,
        }
        export namespace W3cXsd2001 {
          export interface ISoapXsd {
            GetXsdType(): string;
          }
          export class SoapAnyUri {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapAnyUri;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapBase64Binary {
            constructor();
            constructor(value: Byte[]);
            Value: Byte[];
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapBase64Binary;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapDate {
            constructor();
            constructor(value: System.DateTime);
            constructor(value: System.DateTime, sign: number);
            Sign: number;
            Value: System.DateTime;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapDateTime {
            constructor();
            static XsdType: string;
            static Parse(value: string): System.DateTime;
            static ToString(value: System.DateTime): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
            ToString(): string;
          }
          export class SoapDay {
            constructor();
            constructor(value: System.DateTime);
            Value: System.DateTime;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDay;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapDuration {
            constructor();
            static XsdType: string;
            static Parse(value: string): System.TimeSpan;
            static ToString(timeSpan: System.TimeSpan): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
            ToString(): string;
          }
          export class SoapEntities {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntities;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapEntity {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntity;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapHexBinary {
            constructor();
            constructor(value: Byte[]);
            Value: Byte[];
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapId {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapId;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapIdref {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdref;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapIdrefs {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdrefs;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapInteger {
            constructor();
            constructor(value: number);
            Value: number;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapLanguage {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapLanguage;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapMonth {
            constructor();
            constructor(value: System.DateTime);
            Value: System.DateTime;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonth;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapMonthDay {
            constructor();
            constructor(value: System.DateTime);
            Value: System.DateTime;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonthDay;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapName {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapName;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapNcName {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNcName;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapNegativeInteger {
            constructor();
            constructor(value: number);
            Value: number;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNegativeInteger;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapNmtoken {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtoken;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapNmtokens {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtokens;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapNonNegativeInteger {
            constructor();
            constructor(value: number);
            Value: number;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonNegativeInteger;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapNonPositiveInteger {
            constructor();
            constructor(value: number);
            Value: number;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonPositiveInteger;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapNormalizedString {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNormalizedString;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapNotation {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNotation;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapPositiveInteger {
            constructor();
            constructor(value: number);
            Value: number;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapPositiveInteger;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapQName {
            constructor();
            constructor(value: string);
            constructor(key: string, name: string);
            constructor(key: string, name: string, namespaceValue: string);
            Key: string;
            Name: string;
            Namespace: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapQName;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapTime {
            constructor();
            constructor(value: System.DateTime);
            Value: System.DateTime;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapTime;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapToken {
            constructor();
            constructor(value: string);
            Value: string;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapToken;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapYear {
            constructor();
            constructor(value: System.DateTime);
            constructor(value: System.DateTime, sign: number);
            Sign: number;
            Value: System.DateTime;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYear;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
          export class SoapYearMonth {
            constructor();
            constructor(value: System.DateTime);
            constructor(value: System.DateTime, sign: number);
            Sign: number;
            Value: System.DateTime;
            static XsdType: string;
            GetXsdType(): string;
            static Parse(value: string): System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYearMonth;
            ToString(): string;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
          }
        }
      }
      export namespace Proxies {
        export class RealProxy {
          GetProxiedType(): System.Type;
          CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          GetCOMIUnknown(fIsMarshalled: boolean): System.IntPtr;
          SetCOMIUnknown(i: System.IntPtr): void;
          static GetStubData(rp: System.Runtime.Remoting.Proxies.RealProxy): any;
          static SetStubData(rp: System.Runtime.Remoting.Proxies.RealProxy, stubData: any): void;
          Invoke(msg: System.Runtime.Remoting.Messaging.IMessage): System.Runtime.Remoting.Messaging.IMessage;
          GetTransparentProxy(): any;
          InitializeServerObject(ctorMsg: System.Runtime.Remoting.Activation.IConstructionCallMessage): System.Runtime.Remoting.Activation.IConstructionReturnMessage;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
      }
      export namespace Services {
        export class EnterpriseServicesHelper {
          constructor();
          static CreateConstructionReturnMessage(ctorMsg: System.Runtime.Remoting.Activation.IConstructionCallMessage, retObj: System.MarshalByRefObject): System.Runtime.Remoting.Activation.IConstructionReturnMessage;
          static SwitchWrappers(oldcp: System.Runtime.Remoting.Proxies.RealProxy, newcp: System.Runtime.Remoting.Proxies.RealProxy): void;
          static WrapIUnknownWithComObject(punk: System.IntPtr): any;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export interface ITrackingHandler {
          DisconnectedObject(obj: any): void;
          MarshaledObject(obj: any, or: System.Runtime.Remoting.ObjRef): void;
          UnmarshaledObject(obj: any, or: System.Runtime.Remoting.ObjRef): void;
        }
        export class TrackingServices {
          constructor();
          static RegisteredHandlers: System.Runtime.Remoting.Services.ITrackingHandler[];
          static RegisterTrackingHandler(handler: System.Runtime.Remoting.Services.ITrackingHandler): void;
          static UnregisterTrackingHandler(handler: System.Runtime.Remoting.Services.ITrackingHandler): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
      }
    }
    export namespace Serialization {
      export interface IDeserializationCallback {
        OnDeserialization(sender: any): void;
      }
      export interface IFormatterConverter {
        Convert(value: any, type: System.Type): any;
        Convert(value: any, typeCode: System.TypeCode): any;
        ToBoolean(value: any): boolean;
        ToChar(value: any): System.Char;
        ToSByte(value: any): System.SByte;
        ToByte(value: any): Byte;
        ToInt16(value: any): number;
        ToUInt16(value: any): number;
        ToInt32(value: any): number;
        ToUInt32(value: any): number;
        ToInt64(value: any): number;
        ToUInt64(value: any): number;
        ToSingle(value: any): number;
        ToDouble(value: any): number;
        ToDecimal(value: any): number;
        ToDateTime(value: any): System.DateTime;
        ToString(value: any): string;
      }
      export interface IObjectReference {
        GetRealObject(context: System.Runtime.Serialization.StreamingContext): any;
      }
      export interface ISerializable {
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      }
      export class SerializationException {
        constructor();
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class SerializationEntry {
        Value: any; // System.Object
        Name: string;
        ObjectType: System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class SerializationInfoEnumerator {
        Current: System.Runtime.Serialization.SerializationEntry;
        Name: string;
        Value: any; // System.Object
        ObjectType: System.Type;
        MoveNext(): boolean;
        Reset(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SerializationEventHandler {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(context: System.Runtime.Serialization.StreamingContext): void;
        BeginInvoke(context: System.Runtime.Serialization.StreamingContext, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): void;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Formatter {
        SurrogateSelector: System.Runtime.Serialization.ISurrogateSelector;
        Binder: System.Runtime.Serialization.SerializationBinder;
        Context: System.Runtime.Serialization.StreamingContext;
        Deserialize(serializationStream: System.IO.Stream): any;
        Serialize(serializationStream: System.IO.Stream, graph: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FormatterConverter {
        constructor();
        Convert(value: any, type: System.Type): any;
        Convert(value: any, typeCode: System.TypeCode): any;
        ToBoolean(value: any): boolean;
        ToChar(value: any): System.Char;
        ToSByte(value: any): System.SByte;
        ToByte(value: any): Byte;
        ToInt16(value: any): number;
        ToUInt16(value: any): number;
        ToInt32(value: any): number;
        ToUInt32(value: any): number;
        ToInt64(value: any): number;
        ToUInt64(value: any): number;
        ToSingle(value: any): number;
        ToDouble(value: any): number;
        ToDecimal(value: any): number;
        ToDateTime(value: any): System.DateTime;
        ToString(value: any): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface ISerializationSurrogate {
        GetObjectData(obj: any, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        SetObjectData(obj: any, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext, selector: System.Runtime.Serialization.ISurrogateSelector): any;
      }
      export interface ISurrogateSelector {
        ChainSelector(selector: System.Runtime.Serialization.ISurrogateSelector): void;
        GetNextSelector(): System.Runtime.Serialization.ISurrogateSelector;
      }
      export class SerializationBinder {
        BindToType(assemblyName: string, typeName: string): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SerializationObjectManager {
        constructor(context: System.Runtime.Serialization.StreamingContext);
        RegisterObject(obj: any): void;
        RaiseOnSerializedEvent(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FormatterServices {
        static GetSerializableMembers(type: System.Type): System.Reflection.MemberInfo[];
        static GetSerializableMembers(type: System.Type, context: System.Runtime.Serialization.StreamingContext): System.Reflection.MemberInfo[];
        static CheckTypeSecurity(t: System.Type, securityLevel: System.Runtime.Serialization.Formatters.TypeFilterLevel): void;
        static GetUninitializedObject(type: System.Type): any;
        static GetSafeUninitializedObject(type: System.Type): any;
        static PopulateObjectMembers(obj: any, members: System.Reflection.MemberInfo[], data: any[]): any;
        static GetObjectData(obj: any, members: System.Reflection.MemberInfo[]): any[];
        static GetSurrogateForCyclicalReference(innerSurrogate: System.Runtime.Serialization.ISerializationSurrogate): System.Runtime.Serialization.ISerializationSurrogate;
        static GetTypeFromAssembly(assem: System.Reflection.Assembly, name: string): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface IFormatter {
        SurrogateSelector: System.Runtime.Serialization.ISurrogateSelector;
        Binder: System.Runtime.Serialization.SerializationBinder;
        Context: System.Runtime.Serialization.StreamingContext;
        Deserialize(serializationStream: System.IO.Stream): any;
        Serialize(serializationStream: System.IO.Stream, graph: any): void;
      }
      export class ObjectIDGenerator {
        constructor();
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ObjectManager {
        constructor(selector: System.Runtime.Serialization.ISurrogateSelector, context: System.Runtime.Serialization.StreamingContext);
        GetObject(objectID: number): any;
        RegisterObject(obj: any, objectID: number): void;
        RegisterObject(obj: any, objectID: number, info: System.Runtime.Serialization.SerializationInfo): void;
        RegisterObject(obj: any, objectID: number, info: System.Runtime.Serialization.SerializationInfo, idOfContainingObj: number, member: System.Reflection.MemberInfo): void;
        RegisterObject(obj: any, objectID: number, info: System.Runtime.Serialization.SerializationInfo, idOfContainingObj: number, member: System.Reflection.MemberInfo, arrayIndex: number[]): void;
        DoFixups(): void;
        RecordFixup(objectToBeFixed: number, member: System.Reflection.MemberInfo, objectRequired: number): void;
        RecordDelayedFixup(objectToBeFixed: number, memberName: string, objectRequired: number): void;
        RecordArrayElementFixup(arrayToBeFixed: number, index: number, objectRequired: number): void;
        RecordArrayElementFixup(arrayToBeFixed: number, indices: number[], objectRequired: number): void;
        RaiseDeserializationEvent(): void;
        RaiseOnDeserializingEvent(obj: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SafeSerializationEventArgs {
        StreamingContext: System.Runtime.Serialization.StreamingContext;
        AddSerializedState(serializedState: System.Runtime.Serialization.ISafeSerializationData): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface ISafeSerializationData {
        CompleteDeserialization(deserialized: any): void;
      }
      export class SerializationInfo {
        constructor(type: System.Type, converter: System.Runtime.Serialization.IFormatterConverter);
        constructor(type: System.Type, converter: System.Runtime.Serialization.IFormatterConverter, requireSameTokenInPartialTrust: boolean);
        FullTypeName: string;
        AssemblyName: string;
        MemberCount: number;
        ObjectType: System.Type;
        IsFullTypeNameSetExplicit: boolean;
        IsAssemblyNameSetExplicit: boolean;
        SetType(type: System.Type): void;
        GetEnumerator(): System.Runtime.Serialization.SerializationInfoEnumerator;
        AddValue(name: string, value: any, type: System.Type): void;
        AddValue(name: string, value: any): void;
        AddValue(name: string, value: boolean): void;
        AddValue(name: string, value: System.Char): void;
        AddValue(name: string, value: System.SByte): void;
        AddValue(name: string, value: Byte): void;
        AddValue(name: string, value: number): void;
        AddValue(name: string, value: number): void;
        AddValue(name: string, value: number): void;
        AddValue(name: string, value: number): void;
        AddValue(name: string, value: number): void;
        AddValue(name: string, value: number): void;
        AddValue(name: string, value: number): void;
        AddValue(name: string, value: number): void;
        AddValue(name: string, value: number): void;
        AddValue(name: string, value: System.DateTime): void;
        GetValue(name: string, type: System.Type): any;
        GetBoolean(name: string): boolean;
        GetChar(name: string): System.Char;
        GetSByte(name: string): System.SByte;
        GetByte(name: string): Byte;
        GetInt16(name: string): number;
        GetUInt16(name: string): number;
        GetInt32(name: string): number;
        GetUInt32(name: string): number;
        GetInt64(name: string): number;
        GetUInt64(name: string): number;
        GetSingle(name: string): number;
        GetDouble(name: string): number;
        GetDecimal(name: string): number;
        GetDateTime(name: string): System.DateTime;
        GetString(name: string): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class StreamingContext {
        constructor(state: System.Runtime.Serialization.StreamingContextStates);
        constructor(state: System.Runtime.Serialization.StreamingContextStates, additional: any);
        Context: any; // System.Object
        State: System.Runtime.Serialization.StreamingContextStates;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum StreamingContextStates {
        CrossProcess = 1,
        CrossMachine = 2,
        File = 4,
        Persistence = 8,
        Remoting = 16,
        Other = 32,
        Clone = 64,
        CrossAppDomain = 128,
        All = 255,
      }
      export class SurrogateSelector {
        constructor();
        AddSurrogate(type: System.Type, context: System.Runtime.Serialization.StreamingContext, surrogate: System.Runtime.Serialization.ISerializationSurrogate): void;
        ChainSelector(selector: System.Runtime.Serialization.ISurrogateSelector): void;
        GetNextSelector(): System.Runtime.Serialization.ISurrogateSelector;
        RemoveSurrogate(type: System.Type, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export namespace Formatters {
        export enum FormatterTypeStyle {
          TypesWhenNeeded = 0,
          TypesAlways = 1,
          XsdString = 2,
        }
        export enum FormatterAssemblyStyle {
          Simple = 0,
          Full = 1,
        }
        export enum TypeFilterLevel {
          Low = 2,
          Full = 3,
        }
        export interface IFieldInfo {
          FieldNames: string[];
          FieldTypes: System.Type[];
        }
        export interface ISoapMessage {
          ParamNames: string[];
          ParamValues: any[];
          ParamTypes: System.Type[];
          MethodName: string;
          XmlNameSpace: string;
          Headers: System.Runtime.Remoting.Messaging.Header[];
        }
        export class InternalRM {
          constructor();
          static InfoSoap(...messages: any[]): void;
          static SoapCheckEnabled(): boolean;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class InternalST {
          static InfoSoap(...messages: any[]): void;
          static SoapCheckEnabled(): boolean;
          static Soap(...messages: any[]): void;
          static SoapAssert(condition: boolean, message: string): void;
          static SerializationSetValue(fi: System.Reflection.FieldInfo, target: any, value: any): void;
          static LoadAssemblyFromString(assemblyString: string): System.Reflection.Assembly;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class SoapFault {
          constructor();
          constructor(faultCode: string, faultString: string, faultActor: string, serverFault: System.Runtime.Serialization.Formatters.ServerFault);
          FaultCode: string;
          FaultString: string;
          FaultActor: string;
          Detail: any; // System.Object
          GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ServerFault {
          constructor(exceptionType: string, message: string, stackTrace: string);
          ExceptionType: string;
          ExceptionMessage: string;
          StackTrace: string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class SoapMessage {
          constructor();
          ParamNames: string[];
          ParamValues: any[];
          ParamTypes: System.Type[];
          MethodName: string;
          XmlNameSpace: string;
          Headers: System.Runtime.Remoting.Messaging.Header[];
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export namespace Binary {
          export class BinaryFormatter {
            constructor();
            constructor(selector: System.Runtime.Serialization.ISurrogateSelector, context: System.Runtime.Serialization.StreamingContext);
            TypeFormat: System.Runtime.Serialization.Formatters.FormatterTypeStyle;
            AssemblyFormat: System.Runtime.Serialization.Formatters.FormatterAssemblyStyle;
            FilterLevel: System.Runtime.Serialization.Formatters.TypeFilterLevel;
            SurrogateSelector: System.Runtime.Serialization.ISurrogateSelector;
            Binder: System.Runtime.Serialization.SerializationBinder;
            Context: System.Runtime.Serialization.StreamingContext;
            Deserialize(serializationStream: System.IO.Stream): any;
            Deserialize(serializationStream: System.IO.Stream, handler: ((headers: System.Runtime.Remoting.Messaging.Header[]) => any)): any;
            DeserializeMethodResponse(serializationStream: System.IO.Stream, handler: ((headers: System.Runtime.Remoting.Messaging.Header[]) => any), methodCallMessage: System.Runtime.Remoting.Messaging.IMethodCallMessage): any;
            UnsafeDeserialize(serializationStream: System.IO.Stream, handler: ((headers: System.Runtime.Remoting.Messaging.Header[]) => any)): any;
            UnsafeDeserializeMethodResponse(serializationStream: System.IO.Stream, handler: ((headers: System.Runtime.Remoting.Messaging.Header[]) => any), methodCallMessage: System.Runtime.Remoting.Messaging.IMethodCallMessage): any;
            Serialize(serializationStream: System.IO.Stream, graph: any): void;
            Serialize(serializationStream: System.IO.Stream, graph: any, headers: System.Runtime.Remoting.Messaging.Header[]): void;
            Equals(obj: any): boolean;
            GetHashCode(): number;
            GetType(): System.Type;
            ToString(): string;
          }
        }
      }
    }
    export namespace Versioning {
      export enum ComponentGuaranteesOptions {
        None = 0,
        Exchange = 1,
        Stable = 2,
        SideBySide = 4,
      }
      export enum ResourceScope {
        None = 0,
        Machine = 1,
        Process = 2,
        AppDomain = 4,
        Library = 8,
        Private = 16,
        Assembly = 32,
      }
      export class VersioningHelper {
        static MakeVersionSafeName(name: string, from: System.Runtime.Versioning.ResourceScope, to: System.Runtime.Versioning.ResourceScope): string;
        static MakeVersionSafeName(name: string, from: System.Runtime.Versioning.ResourceScope, to: System.Runtime.Versioning.ResourceScope, type: System.Type): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CompatibilitySwitch {
        static IsEnabled(compatibilitySwitchName: string): boolean;
        static GetValue(compatibilitySwitchName: string): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FrameworkName {
        constructor(identifier: string, version: System.Version);
        constructor(identifier: string, version: System.Version, profile: string);
        constructor(frameworkName: string);
        Identifier: string;
        Version: System.Version;
        Profile: string;
        FullName: string;
        Equals(obj: any): boolean;
        Equals(other: System.Runtime.Versioning.FrameworkName): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
    }
  }
  export namespace Security {
    export class VerificationException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export interface IPermission {
      Copy(): System.Security.IPermission;
      Demand(): void;
      Intersect(target: System.Security.IPermission): System.Security.IPermission;
      IsSubsetOf(target: System.Security.IPermission): boolean;
      Union(target: System.Security.IPermission): System.Security.IPermission;
    }
    export interface ISecurityEncodable {
      FromXml(e: System.Security.SecurityElement): void;
      ToXml(): System.Security.SecurityElement;
    }
    export interface IEvidenceFactory {
      Evidence: System.Security.Policy.Evidence;
    }
    export interface ISecurityPolicyEncodable {
      FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
      ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
    }
    export interface IStackWalk {
      Assert(): void;
      Demand(): void;
      Deny(): void;
      PermitOnly(): void;
    }
    export enum PolicyLevelType {
      AppDomain = 3,
      Enterprise = 2,
      Machine = 1,
      User = 0,
    }
    export enum SecurityZone {
      Internet = 3,
      Intranet = 1,
      MyComputer = 0,
      NoZone = -1,
      Trusted = 2,
      Untrusted = 4,
    }
    export class XmlSyntaxException {
      constructor();
      constructor(lineNumber: number);
      constructor(lineNumber: number, message: string);
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum PartialTrustVisibilityLevel {
      VisibleToAllHosts = 0,
      NotVisibleByDefault = 1,
    }
    export enum SecurityCriticalScope {
      Explicit = 0,
      Everything = 1,
    }
    export enum SecurityRuleSet {
      None = 0,
      Level1 = 1,
      Level2 = 2,
    }
    export enum SecurityContextSource {
      CurrentAppDomain = 0,
      CurrentAssembly = 1,
    }
    export class SecurityContext {
      CreateCopy(): System.Security.SecurityContext;
      static Capture(): System.Security.SecurityContext;
      Dispose(): void;
      static IsFlowSuppressed(): boolean;
      static IsWindowsIdentityFlowSuppressed(): boolean;
      static RestoreFlow(): void;
      static Run(securityContext: System.Security.SecurityContext, callback: ((state: any) => void), state: any): void;
      static SuppressFlow(): System.Threading.AsyncFlowControl;
      static SuppressFlowWindowsIdentity(): System.Threading.AsyncFlowControl;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CodeAccessPermission {
      Assert(): void;
      Copy(): System.Security.IPermission;
      Demand(): void;
      Deny(): void;
      Equals(obj: any): boolean;
      FromXml(elem: System.Security.SecurityElement): void;
      GetHashCode(): number;
      Intersect(target: System.Security.IPermission): System.Security.IPermission;
      IsSubsetOf(target: System.Security.IPermission): boolean;
      ToString(): string;
      ToXml(): System.Security.SecurityElement;
      Union(other: System.Security.IPermission): System.Security.IPermission;
      PermitOnly(): void;
      static RevertAll(): void;
      static RevertAssert(): void;
      static RevertDeny(): void;
      static RevertPermitOnly(): void;
      GetType(): System.Type;
    }
    export class HostProtectionException {
      constructor();
      constructor(message: string);
      constructor(message: string, e: System.Exception);
      constructor(message: string, protectedResources: System.Security.Permissions.HostProtectionResource, demandedResources: System.Security.Permissions.HostProtectionResource);
      DemandedResources: System.Security.Permissions.HostProtectionResource;
      ProtectedResources: System.Security.Permissions.HostProtectionResource;
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      ToString(): string;
      GetBaseException(): System.Exception;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class HostSecurityManager {
      constructor();
      DomainPolicy: System.Security.Policy.PolicyLevel;
      Flags: System.Security.HostSecurityManagerOptions;
      DetermineApplicationTrust(applicationEvidence: System.Security.Policy.Evidence, activatorEvidence: System.Security.Policy.Evidence, context: System.Security.Policy.TrustManagerContext): System.Security.Policy.ApplicationTrust;
      ProvideAppDomainEvidence(inputEvidence: System.Security.Policy.Evidence): System.Security.Policy.Evidence;
      ProvideAssemblyEvidence(loadedAssembly: System.Reflection.Assembly, inputEvidence: System.Security.Policy.Evidence): System.Security.Policy.Evidence;
      ResolvePolicy(evidence: System.Security.Policy.Evidence): System.Security.PermissionSet;
      GenerateAppDomainEvidence(evidenceType: System.Type): System.Security.Policy.EvidenceBase;
      GenerateAssemblyEvidence(evidenceType: System.Type, assembly: System.Reflection.Assembly): System.Security.Policy.EvidenceBase;
      GetHostSuppliedAppDomainEvidenceTypes(): System.Type[];
      GetHostSuppliedAssemblyEvidenceTypes(assembly: System.Reflection.Assembly): System.Type[];
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum HostSecurityManagerOptions {
      None = 0,
      HostAppDomainEvidence = 1,
      HostPolicyLevel = 2,
      HostAssemblyEvidence = 4,
      HostDetermineApplicationTrust = 8,
      HostResolvePolicy = 16,
      AllFlags = 31,
    }
    export class NamedPermissionSet {
      constructor(name: string, permSet: System.Security.PermissionSet);
      constructor(name: string, state: System.Security.Permissions.PermissionState);
      constructor(permSet: System.Security.NamedPermissionSet);
      constructor(name: string);
      Description: string;
      Name: string;
      Count: number;
      IsSynchronized: boolean;
      IsReadOnly: boolean;
      SyncRoot: any; // System.Object
      Copy(): System.Security.PermissionSet;
      Copy(name: string): System.Security.NamedPermissionSet;
      FromXml(et: System.Security.SecurityElement): void;
      ToXml(): System.Security.SecurityElement;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      AddPermission(perm: System.Security.IPermission): System.Security.IPermission;
      Assert(): void;
      CopyTo(array: System.Array, index: number): void;
      Demand(): void;
      Deny(): void;
      GetEnumerator(): System.Collections.IEnumerator;
      IsSubsetOf(target: System.Security.PermissionSet): boolean;
      PermitOnly(): void;
      ContainsNonCodeAccessPermissions(): boolean;
      GetPermission(permClass: System.Type): System.Security.IPermission;
      Intersect(other: System.Security.PermissionSet): System.Security.PermissionSet;
      IsEmpty(): boolean;
      IsUnrestricted(): boolean;
      RemovePermission(permClass: System.Type): System.Security.IPermission;
      SetPermission(perm: System.Security.IPermission): System.Security.IPermission;
      ToString(): string;
      Union(other: System.Security.PermissionSet): System.Security.PermissionSet;
      GetType(): System.Type;
    }
    export class PermissionSet {
      constructor(state: System.Security.Permissions.PermissionState);
      constructor(permSet: System.Security.PermissionSet);
      Count: number;
      IsSynchronized: boolean;
      IsReadOnly: boolean;
      SyncRoot: any; // System.Object
      AddPermission(perm: System.Security.IPermission): System.Security.IPermission;
      Assert(): void;
      Copy(): System.Security.PermissionSet;
      CopyTo(array: System.Array, index: number): void;
      Demand(): void;
      Deny(): void;
      FromXml(et: System.Security.SecurityElement): void;
      GetEnumerator(): System.Collections.IEnumerator;
      IsSubsetOf(target: System.Security.PermissionSet): boolean;
      PermitOnly(): void;
      ContainsNonCodeAccessPermissions(): boolean;
      static ConvertPermissionSet(inFormat: string, inData: Byte[], outFormat: string): Byte[];
      GetPermission(permClass: System.Type): System.Security.IPermission;
      Intersect(other: System.Security.PermissionSet): System.Security.PermissionSet;
      IsEmpty(): boolean;
      IsUnrestricted(): boolean;
      RemovePermission(permClass: System.Type): System.Security.IPermission;
      SetPermission(perm: System.Security.IPermission): System.Security.IPermission;
      ToString(): string;
      ToXml(): System.Security.SecurityElement;
      Union(other: System.Security.PermissionSet): System.Security.PermissionSet;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      static RevertAssert(): void;
      GetType(): System.Type;
    }
    export class SecureString {
      constructor();
      Length: number;
      AppendChar(c: System.Char): void;
      Clear(): void;
      Copy(): System.Security.SecureString;
      Dispose(): void;
      InsertAt(index: number, c: System.Char): void;
      IsReadOnly(): boolean;
      MakeReadOnly(): void;
      RemoveAt(index: number): void;
      SetAt(index: number, c: System.Char): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SecurityElement {
      constructor(tag: string);
      constructor(tag: string, text: string);
      Attributes: System.Collections.Hashtable;
      Children: System.Collections.ArrayList;
      Tag: string;
      Text: string;
      AddAttribute(name: string, value: string): void;
      AddChild(child: System.Security.SecurityElement): void;
      Attribute(name: string): string;
      Copy(): System.Security.SecurityElement;
      Equal(other: System.Security.SecurityElement): boolean;
      static Escape(str: string): string;
      static FromString(xml: string): System.Security.SecurityElement;
      static IsValidAttributeName(name: string): boolean;
      static IsValidAttributeValue(value: string): boolean;
      static IsValidTag(tag: string): boolean;
      static IsValidText(text: string): boolean;
      SearchForChildByTag(tag: string): System.Security.SecurityElement;
      SearchForTextOfTag(tag: string): string;
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class SecurityException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      constructor(message: string, type: System.Type);
      constructor(message: string, type: System.Type, state: string);
      constructor(message: string, deny: any, permitOnly: any, method: System.Reflection.MethodInfo, demanded: any, permThatFailed: System.Security.IPermission);
      constructor(message: string, assemblyName: System.Reflection.AssemblyName, grant: System.Security.PermissionSet, refused: System.Security.PermissionSet, method: System.Reflection.MethodInfo, action: System.Security.Permissions.SecurityAction, demanded: any, permThatFailed: System.Security.IPermission, evidence: System.Security.Policy.Evidence);
      Action: System.Security.Permissions.SecurityAction;
      DenySetInstance: any; // System.Object
      FailedAssemblyInfo: System.Reflection.AssemblyName;
      Method: System.Reflection.MethodInfo;
      PermitOnlySetInstance: any; // System.Object
      Url: string;
      Zone: System.Security.SecurityZone;
      Demanded: any; // System.Object
      FirstPermissionThatFailed: System.Security.IPermission;
      PermissionState: string;
      PermissionType: System.Type;
      GrantedSet: string;
      RefusedSet: string;
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      ToString(): string;
      GetBaseException(): System.Exception;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class SecurityManager {
      static CheckExecutionRights: boolean;
      static SecurityEnabled: boolean;
      static IsGranted(perm: System.Security.IPermission): boolean;
      static LoadPolicyLevelFromFile(path: string, type: System.Security.PolicyLevelType): System.Security.Policy.PolicyLevel;
      static LoadPolicyLevelFromString(str: string, type: System.Security.PolicyLevelType): System.Security.Policy.PolicyLevel;
      static PolicyHierarchy(): System.Collections.IEnumerator;
      static ResolvePolicy(evidence: System.Security.Policy.Evidence): System.Security.PermissionSet;
      static ResolvePolicy(evidences: System.Security.Policy.Evidence[]): System.Security.PermissionSet;
      static ResolveSystemPolicy(evidence: System.Security.Policy.Evidence): System.Security.PermissionSet;
      static ResolvePolicyGroups(evidence: System.Security.Policy.Evidence): System.Collections.IEnumerator;
      static SavePolicy(): void;
      static SavePolicyLevel(level: System.Security.Policy.PolicyLevel): void;
      static GetStandardSandbox(evidence: System.Security.Policy.Evidence): System.Security.PermissionSet;
      static CurrentThreadRequiresSecurityContextCapture(): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SecurityState {
      EnsureState(): void;
      IsStateAvailable(): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ReadOnlyPermissionSet {
      constructor(permissionSetXml: System.Security.SecurityElement);
      Count: number;
      IsSynchronized: boolean;
      IsReadOnly: boolean;
      SyncRoot: any; // System.Object
      AddPermission(perm: System.Security.IPermission): System.Security.IPermission;
      Assert(): void;
      Copy(): System.Security.PermissionSet;
      CopyTo(array: System.Array, index: number): void;
      Demand(): void;
      Deny(): void;
      FromXml(et: System.Security.SecurityElement): void;
      GetEnumerator(): System.Collections.IEnumerator;
      IsSubsetOf(target: System.Security.PermissionSet): boolean;
      PermitOnly(): void;
      ContainsNonCodeAccessPermissions(): boolean;
      GetPermission(permClass: System.Type): System.Security.IPermission;
      Intersect(other: System.Security.PermissionSet): System.Security.PermissionSet;
      IsEmpty(): boolean;
      IsUnrestricted(): boolean;
      RemovePermission(permClass: System.Type): System.Security.IPermission;
      SetPermission(perm: System.Security.IPermission): System.Security.IPermission;
      ToString(): string;
      ToXml(): System.Security.SecurityElement;
      Union(other: System.Security.PermissionSet): System.Security.PermissionSet;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum ManifestKinds {
      Application = 2,
      ApplicationAndDeployment = 3,
      Deployment = 1,
      None = 0,
    }
    export class SecureStringMarshal {
      static SecureStringToCoTaskMemAnsi(s: System.Security.SecureString): System.IntPtr;
      static SecureStringToGlobalAllocAnsi(s: System.Security.SecureString): System.IntPtr;
      static SecureStringToCoTaskMemUnicode(s: System.Security.SecureString): System.IntPtr;
      static SecureStringToGlobalAllocUnicode(s: System.Security.SecureString): System.IntPtr;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export namespace AccessControl {
      export class RegistrySecurity {
        constructor();
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAccessRule(rule: System.Security.AccessControl.RegistryAccessRule): void;
        SetAccessRule(rule: System.Security.AccessControl.RegistryAccessRule): void;
        ResetAccessRule(rule: System.Security.AccessControl.RegistryAccessRule): void;
        RemoveAccessRule(rule: System.Security.AccessControl.RegistryAccessRule): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.RegistryAccessRule): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.RegistryAccessRule): void;
        AddAuditRule(rule: System.Security.AccessControl.RegistryAuditRule): void;
        SetAuditRule(rule: System.Security.AccessControl.RegistryAuditRule): void;
        RemoveAuditRule(rule: System.Security.AccessControl.RegistryAuditRule): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.RegistryAuditRule): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.RegistryAuditRule): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RegistryAccessRule {
        constructor(identity: System.Security.Principal.IdentityReference, registryRights: System.Security.AccessControl.RegistryRights, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: string, registryRights: System.Security.AccessControl.RegistryRights, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: System.Security.Principal.IdentityReference, registryRights: System.Security.AccessControl.RegistryRights, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: string, registryRights: System.Security.AccessControl.RegistryRights, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType);
        RegistryRights: System.Security.AccessControl.RegistryRights;
        AccessControlType: System.Security.AccessControl.AccessControlType;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RegistryAuditRule {
        constructor(identity: System.Security.Principal.IdentityReference, registryRights: System.Security.AccessControl.RegistryRights, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags);
        constructor(identity: string, registryRights: System.Security.AccessControl.RegistryRights, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags);
        RegistryRights: System.Security.AccessControl.RegistryRights;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class PrivilegeNotHeldException {
        constructor();
        constructor(privilege: string);
        constructor(privilege: string, inner: System.Exception);
        PrivilegeName: string;
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum AccessControlActions {
        None = 0,
        View = 1,
        Change = 2,
      }
      export enum AccessControlModification {
        Add = 0,
        Set = 1,
        Reset = 2,
        Remove = 3,
        RemoveAll = 4,
        RemoveSpecific = 5,
      }
      export enum AccessControlSections {
        None = 0,
        Audit = 1,
        Access = 2,
        Owner = 4,
        Group = 8,
        All = 15,
      }
      export enum AccessControlType {
        Allow = 0,
        Deny = 1,
      }
      export class AccessRule<T = any> {
        constructor(identity: string, rights: T, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: System.Security.Principal.IdentityReference, rights: T, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: string, rights: T, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: System.Security.Principal.IdentityReference, rights: T, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType);
        Rights: T;
        AccessControlType: System.Security.AccessControl.AccessControlType;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AceEnumerator {
        Current: System.Security.AccessControl.GenericAce;
        MoveNext(): boolean;
        Reset(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum AceFlags {
        None = 0,
        ObjectInherit = 1,
        ContainerInherit = 2,
        NoPropagateInherit = 4,
        InheritOnly = 8,
        InheritanceFlags = 15,
        Inherited = 16,
        SuccessfulAccess = 64,
        FailedAccess = 128,
        AuditFlags = 192,
      }
      export enum AceQualifier {
        AccessAllowed = 0,
        AccessDenied = 1,
        SystemAudit = 2,
        SystemAlarm = 3,
      }
      export enum AceType {
        AccessAllowed = 0,
        AccessDenied = 1,
        SystemAudit = 2,
        SystemAlarm = 3,
        AccessAllowedCompound = 4,
        AccessAllowedObject = 5,
        AccessDeniedObject = 6,
        SystemAuditObject = 7,
        SystemAlarmObject = 8,
        AccessAllowedCallback = 9,
        AccessDeniedCallback = 10,
        AccessAllowedCallbackObject = 11,
        AccessDeniedCallbackObject = 12,
        SystemAuditCallback = 13,
        SystemAlarmCallback = 14,
        SystemAuditCallbackObject = 15,
        SystemAlarmCallbackObject = 16,
        MaxDefinedAceType = 16,
      }
      export enum AuditFlags {
        None = 0,
        Success = 1,
        Failure = 2,
      }
      export class AuditRule<T = any> {
        constructor(identity: string, rights: T, flags: System.Security.AccessControl.AuditFlags);
        constructor(identity: System.Security.Principal.IdentityReference, rights: T, flags: System.Security.AccessControl.AuditFlags);
        constructor(identity: string, rights: T, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags);
        constructor(identity: System.Security.Principal.IdentityReference, rights: T, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags);
        Rights: T;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AuthorizationRule {
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AuthorizationRuleCollection {
        constructor();
        Count: number;
        AddRule(rule: System.Security.AccessControl.AuthorizationRule): void;
        CopyTo(rules: System.Security.AccessControl.AuthorizationRule[], index: number): void;
        GetEnumerator(): System.Collections.IEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CommonAce {
        constructor(flags: System.Security.AccessControl.AceFlags, qualifier: System.Security.AccessControl.AceQualifier, accessMask: number, sid: System.Security.Principal.SecurityIdentifier, isCallback: boolean, opaque: Byte[]);
        BinaryLength: number;
        AceQualifier: System.Security.AccessControl.AceQualifier;
        IsCallback: boolean;
        OpaqueLength: number;
        AccessMask: number;
        SecurityIdentifier: System.Security.Principal.SecurityIdentifier;
        AceFlags: System.Security.AccessControl.AceFlags;
        AceType: System.Security.AccessControl.AceType;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        static MaxOpaqueLength(isCallback: boolean): number;
        GetOpaque(): Byte[];
        SetOpaque(opaque: Byte[]): void;
        Copy(): System.Security.AccessControl.GenericAce;
        Equals(o: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CommonAcl {
        BinaryLength: number;
        Count: number;
        IsCanonical: boolean;
        IsContainer: boolean;
        IsDS: boolean;
        Revision: Byte;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        Purge(sid: System.Security.Principal.SecurityIdentifier): void;
        RemoveInheritedAces(): void;
        CopyTo(array: System.Security.AccessControl.GenericAce[], index: number): void;
        GetEnumerator(): System.Security.AccessControl.AceEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CommonObjectSecurity {
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CommonSecurityDescriptor {
        constructor(isContainer: boolean, isDS: boolean, rawSecurityDescriptor: System.Security.AccessControl.RawSecurityDescriptor);
        constructor(isContainer: boolean, isDS: boolean, sddlForm: string);
        constructor(isContainer: boolean, isDS: boolean, binaryForm: Byte[], offset: number);
        constructor(isContainer: boolean, isDS: boolean, flags: System.Security.AccessControl.ControlFlags, owner: System.Security.Principal.SecurityIdentifier, group: System.Security.Principal.SecurityIdentifier, systemAcl: System.Security.AccessControl.SystemAcl, discretionaryAcl: System.Security.AccessControl.DiscretionaryAcl);
        ControlFlags: System.Security.AccessControl.ControlFlags;
        DiscretionaryAcl: System.Security.AccessControl.DiscretionaryAcl;
        Group: System.Security.Principal.SecurityIdentifier;
        IsContainer: boolean;
        IsDiscretionaryAclCanonical: boolean;
        IsDS: boolean;
        IsSystemAclCanonical: boolean;
        Owner: System.Security.Principal.SecurityIdentifier;
        SystemAcl: System.Security.AccessControl.SystemAcl;
        BinaryLength: number;
        PurgeAccessControl(sid: System.Security.Principal.SecurityIdentifier): void;
        PurgeAudit(sid: System.Security.Principal.SecurityIdentifier): void;
        SetDiscretionaryAclProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetSystemAclProtection(isProtected: boolean, preserveInheritance: boolean): void;
        AddDiscretionaryAcl(revision: Byte, trusted: number): void;
        AddSystemAcl(revision: Byte, trusted: number): void;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        GetSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CompoundAce {
        constructor(flags: System.Security.AccessControl.AceFlags, accessMask: number, compoundAceType: System.Security.AccessControl.CompoundAceType, sid: System.Security.Principal.SecurityIdentifier);
        BinaryLength: number;
        CompoundAceType: System.Security.AccessControl.CompoundAceType;
        AccessMask: number;
        SecurityIdentifier: System.Security.Principal.SecurityIdentifier;
        AceFlags: System.Security.AccessControl.AceFlags;
        AceType: System.Security.AccessControl.AceType;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        Copy(): System.Security.AccessControl.GenericAce;
        Equals(o: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum CompoundAceType {
        Impersonation = 1,
      }
      export enum ControlFlags {
        None = 0,
        OwnerDefaulted = 1,
        GroupDefaulted = 2,
        DiscretionaryAclPresent = 4,
        DiscretionaryAclDefaulted = 8,
        SystemAclPresent = 16,
        SystemAclDefaulted = 32,
        DiscretionaryAclUntrusted = 64,
        ServerSecurity = 128,
        DiscretionaryAclAutoInheritRequired = 256,
        SystemAclAutoInheritRequired = 512,
        DiscretionaryAclAutoInherited = 1024,
        SystemAclAutoInherited = 2048,
        DiscretionaryAclProtected = 4096,
        SystemAclProtected = 8192,
        RMControlValid = 16384,
        SelfRelative = 32768,
      }
      export class CryptoKeyAccessRule {
        constructor(identity: System.Security.Principal.IdentityReference, cryptoKeyRights: System.Security.AccessControl.CryptoKeyRights, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: string, cryptoKeyRights: System.Security.AccessControl.CryptoKeyRights, type: System.Security.AccessControl.AccessControlType);
        CryptoKeyRights: System.Security.AccessControl.CryptoKeyRights;
        AccessControlType: System.Security.AccessControl.AccessControlType;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CryptoKeyAuditRule {
        constructor(identity: System.Security.Principal.IdentityReference, cryptoKeyRights: System.Security.AccessControl.CryptoKeyRights, flags: System.Security.AccessControl.AuditFlags);
        constructor(identity: string, cryptoKeyRights: System.Security.AccessControl.CryptoKeyRights, flags: System.Security.AccessControl.AuditFlags);
        CryptoKeyRights: System.Security.AccessControl.CryptoKeyRights;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum CryptoKeyRights {
        ReadData = 1,
        WriteData = 2,
        ReadExtendedAttributes = 8,
        WriteExtendedAttributes = 16,
        ReadAttributes = 128,
        WriteAttributes = 256,
        Delete = 65536,
        ReadPermissions = 131072,
        ChangePermissions = 262144,
        TakeOwnership = 524288,
        Synchronize = 1048576,
        FullControl = 2032027,
        GenericAll = 268435456,
        GenericExecute = 536870912,
        GenericWrite = 1073741824,
        GenericRead = -2147483648,
      }
      export class CryptoKeySecurity {
        constructor();
        constructor(securityDescriptor: System.Security.AccessControl.CommonSecurityDescriptor);
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AddAccessRule(rule: System.Security.AccessControl.CryptoKeyAccessRule): void;
        RemoveAccessRule(rule: System.Security.AccessControl.CryptoKeyAccessRule): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.CryptoKeyAccessRule): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.CryptoKeyAccessRule): void;
        ResetAccessRule(rule: System.Security.AccessControl.CryptoKeyAccessRule): void;
        SetAccessRule(rule: System.Security.AccessControl.CryptoKeyAccessRule): void;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAuditRule(rule: System.Security.AccessControl.CryptoKeyAuditRule): void;
        RemoveAuditRule(rule: System.Security.AccessControl.CryptoKeyAuditRule): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.CryptoKeyAuditRule): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.CryptoKeyAuditRule): void;
        SetAuditRule(rule: System.Security.AccessControl.CryptoKeyAuditRule): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CustomAce {
        constructor(type: System.Security.AccessControl.AceType, flags: System.Security.AccessControl.AceFlags, opaque: Byte[]);
        BinaryLength: number;
        OpaqueLength: number;
        AceFlags: System.Security.AccessControl.AceFlags;
        AceType: System.Security.AccessControl.AceType;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        static MaxOpaqueLength: number;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        GetOpaque(): Byte[];
        SetOpaque(opaque: Byte[]): void;
        Copy(): System.Security.AccessControl.GenericAce;
        Equals(o: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DirectoryObjectSecurity {
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType, objectType: System.Guid, inheritedObjectType: System.Guid): System.Security.AccessControl.AccessRule;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags, objectType: System.Guid, inheritedObjectType: System.Guid): System.Security.AccessControl.AuditRule;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DirectorySecurity {
        constructor();
        constructor(name: string, includeSections: System.Security.AccessControl.AccessControlSections);
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AddAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        RemoveAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        ResetAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        SetAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAuditRule(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        RemoveAuditRule(rule: System.Security.AccessControl.FileSystemAuditRule): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        SetAuditRule(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DiscretionaryAcl {
        constructor(isContainer: boolean, isDS: boolean, capacity: number);
        constructor(isContainer: boolean, isDS: boolean, rawAcl: System.Security.AccessControl.RawAcl);
        constructor(isContainer: boolean, isDS: boolean, revision: Byte, capacity: number);
        BinaryLength: number;
        Count: number;
        IsCanonical: boolean;
        IsContainer: boolean;
        IsDS: boolean;
        Revision: Byte;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        AddAccess(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags): void;
        AddAccess(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, objectFlags: System.Security.AccessControl.ObjectAceFlags, objectType: System.Guid, inheritedObjectType: System.Guid): void;
        AddAccess(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, rule: System.Security.AccessControl.ObjectAccessRule): void;
        RemoveAccess(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags): boolean;
        RemoveAccess(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, objectFlags: System.Security.AccessControl.ObjectAceFlags, objectType: System.Guid, inheritedObjectType: System.Guid): boolean;
        RemoveAccess(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, rule: System.Security.AccessControl.ObjectAccessRule): boolean;
        RemoveAccessSpecific(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags): void;
        RemoveAccessSpecific(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, objectFlags: System.Security.AccessControl.ObjectAceFlags, objectType: System.Guid, inheritedObjectType: System.Guid): void;
        RemoveAccessSpecific(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, rule: System.Security.AccessControl.ObjectAccessRule): void;
        SetAccess(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags): void;
        SetAccess(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, objectFlags: System.Security.AccessControl.ObjectAceFlags, objectType: System.Guid, inheritedObjectType: System.Guid): void;
        SetAccess(accessType: System.Security.AccessControl.AccessControlType, sid: System.Security.Principal.SecurityIdentifier, rule: System.Security.AccessControl.ObjectAccessRule): void;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        Purge(sid: System.Security.Principal.SecurityIdentifier): void;
        RemoveInheritedAces(): void;
        CopyTo(array: System.Security.AccessControl.GenericAce[], index: number): void;
        GetEnumerator(): System.Security.AccessControl.AceEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class EventWaitHandleAccessRule {
        constructor(identity: System.Security.Principal.IdentityReference, eventRights: System.Security.AccessControl.EventWaitHandleRights, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: string, eventRights: System.Security.AccessControl.EventWaitHandleRights, type: System.Security.AccessControl.AccessControlType);
        EventWaitHandleRights: System.Security.AccessControl.EventWaitHandleRights;
        AccessControlType: System.Security.AccessControl.AccessControlType;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class EventWaitHandleAuditRule {
        constructor(identity: System.Security.Principal.IdentityReference, eventRights: System.Security.AccessControl.EventWaitHandleRights, flags: System.Security.AccessControl.AuditFlags);
        EventWaitHandleRights: System.Security.AccessControl.EventWaitHandleRights;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum EventWaitHandleRights {
        Modify = 2,
        Delete = 65536,
        ReadPermissions = 131072,
        ChangePermissions = 262144,
        TakeOwnership = 524288,
        Synchronize = 1048576,
        FullControl = 2031619,
      }
      export class EventWaitHandleSecurity {
        constructor();
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AddAccessRule(rule: System.Security.AccessControl.EventWaitHandleAccessRule): void;
        RemoveAccessRule(rule: System.Security.AccessControl.EventWaitHandleAccessRule): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.EventWaitHandleAccessRule): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.EventWaitHandleAccessRule): void;
        ResetAccessRule(rule: System.Security.AccessControl.EventWaitHandleAccessRule): void;
        SetAccessRule(rule: System.Security.AccessControl.EventWaitHandleAccessRule): void;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAuditRule(rule: System.Security.AccessControl.EventWaitHandleAuditRule): void;
        RemoveAuditRule(rule: System.Security.AccessControl.EventWaitHandleAuditRule): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.EventWaitHandleAuditRule): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.EventWaitHandleAuditRule): void;
        SetAuditRule(rule: System.Security.AccessControl.EventWaitHandleAuditRule): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FileSecurity {
        constructor();
        constructor(fileName: string, includeSections: System.Security.AccessControl.AccessControlSections);
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AddAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        RemoveAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        ResetAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        SetAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAuditRule(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        RemoveAuditRule(rule: System.Security.AccessControl.FileSystemAuditRule): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        SetAuditRule(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FileSystemAccessRule {
        constructor(identity: System.Security.Principal.IdentityReference, fileSystemRights: System.Security.AccessControl.FileSystemRights, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: string, fileSystemRights: System.Security.AccessControl.FileSystemRights, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: System.Security.Principal.IdentityReference, fileSystemRights: System.Security.AccessControl.FileSystemRights, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: string, fileSystemRights: System.Security.AccessControl.FileSystemRights, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType);
        FileSystemRights: System.Security.AccessControl.FileSystemRights;
        AccessControlType: System.Security.AccessControl.AccessControlType;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FileSystemAuditRule {
        constructor(identity: System.Security.Principal.IdentityReference, fileSystemRights: System.Security.AccessControl.FileSystemRights, flags: System.Security.AccessControl.AuditFlags);
        constructor(identity: string, fileSystemRights: System.Security.AccessControl.FileSystemRights, flags: System.Security.AccessControl.AuditFlags);
        constructor(identity: System.Security.Principal.IdentityReference, fileSystemRights: System.Security.AccessControl.FileSystemRights, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags);
        constructor(identity: string, fileSystemRights: System.Security.AccessControl.FileSystemRights, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags);
        FileSystemRights: System.Security.AccessControl.FileSystemRights;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum FileSystemRights {
        ListDirectory = 1,
        ReadData = 1,
        CreateFiles = 2,
        WriteData = 2,
        AppendData = 4,
        CreateDirectories = 4,
        ReadExtendedAttributes = 8,
        WriteExtendedAttributes = 16,
        ExecuteFile = 32,
        Traverse = 32,
        DeleteSubdirectoriesAndFiles = 64,
        ReadAttributes = 128,
        WriteAttributes = 256,
        Write = 278,
        Delete = 65536,
        ReadPermissions = 131072,
        Read = 131209,
        ReadAndExecute = 131241,
        Modify = 197055,
        ChangePermissions = 262144,
        TakeOwnership = 524288,
        Synchronize = 1048576,
        FullControl = 2032127,
      }
      export class FileSystemSecurity {
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AddAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        RemoveAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        ResetAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        SetAccessRule(rule: System.Security.AccessControl.FileSystemAccessRule): void;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAuditRule(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        RemoveAuditRule(rule: System.Security.AccessControl.FileSystemAuditRule): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        SetAuditRule(rule: System.Security.AccessControl.FileSystemAuditRule): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class GenericAce {
        AceFlags: System.Security.AccessControl.AceFlags;
        AceType: System.Security.AccessControl.AceType;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        BinaryLength: number;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Copy(): System.Security.AccessControl.GenericAce;
        static CreateFromBinaryForm(binaryForm: Byte[], offset: number): System.Security.AccessControl.GenericAce;
        Equals(o: any): boolean;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class GenericAcl {
        BinaryLength: number;
        Count: number;
        IsSynchronized: boolean;
        Revision: Byte;
        SyncRoot: any; // System.Object
        static AclRevision: Byte;
        static AclRevisionDS: Byte;
        static MaxBinaryLength: number;
        CopyTo(array: System.Security.AccessControl.GenericAce[], index: number): void;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        GetEnumerator(): System.Security.AccessControl.AceEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class GenericSecurityDescriptor {
        BinaryLength: number;
        ControlFlags: System.Security.AccessControl.ControlFlags;
        Group: System.Security.Principal.SecurityIdentifier;
        Owner: System.Security.Principal.SecurityIdentifier;
        static Revision: Byte;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        GetSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        static IsSddlConversionSupported(): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum InheritanceFlags {
        None = 0,
        ContainerInherit = 1,
        ObjectInherit = 2,
      }
      export class KnownAce {
        AccessMask: number;
        SecurityIdentifier: System.Security.Principal.SecurityIdentifier;
        AceFlags: System.Security.AccessControl.AceFlags;
        AceType: System.Security.AccessControl.AceType;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        BinaryLength: number;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Copy(): System.Security.AccessControl.GenericAce;
        Equals(o: any): boolean;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MutexAccessRule {
        constructor(identity: System.Security.Principal.IdentityReference, eventRights: System.Security.AccessControl.MutexRights, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: string, eventRights: System.Security.AccessControl.MutexRights, type: System.Security.AccessControl.AccessControlType);
        MutexRights: System.Security.AccessControl.MutexRights;
        AccessControlType: System.Security.AccessControl.AccessControlType;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MutexAuditRule {
        constructor(identity: System.Security.Principal.IdentityReference, eventRights: System.Security.AccessControl.MutexRights, flags: System.Security.AccessControl.AuditFlags);
        MutexRights: System.Security.AccessControl.MutexRights;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum MutexRights {
        Modify = 1,
        Delete = 65536,
        ReadPermissions = 131072,
        ChangePermissions = 262144,
        TakeOwnership = 524288,
        Synchronize = 1048576,
        FullControl = 2031617,
      }
      export class MutexSecurity {
        constructor();
        constructor(name: string, includeSections: System.Security.AccessControl.AccessControlSections);
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AddAccessRule(rule: System.Security.AccessControl.MutexAccessRule): void;
        RemoveAccessRule(rule: System.Security.AccessControl.MutexAccessRule): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.MutexAccessRule): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.MutexAccessRule): void;
        ResetAccessRule(rule: System.Security.AccessControl.MutexAccessRule): void;
        SetAccessRule(rule: System.Security.AccessControl.MutexAccessRule): void;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAuditRule(rule: System.Security.AccessControl.MutexAuditRule): void;
        RemoveAuditRule(rule: System.Security.AccessControl.MutexAuditRule): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.MutexAuditRule): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.MutexAuditRule): void;
        SetAuditRule(rule: System.Security.AccessControl.MutexAuditRule): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class NativeObjectSecurity {
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ObjectAccessRule {
        InheritedObjectType: System.Guid;
        ObjectFlags: System.Security.AccessControl.ObjectAceFlags;
        ObjectType: System.Guid;
        AccessControlType: System.Security.AccessControl.AccessControlType;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ObjectAce {
        constructor(aceFlags: System.Security.AccessControl.AceFlags, qualifier: System.Security.AccessControl.AceQualifier, accessMask: number, sid: System.Security.Principal.SecurityIdentifier, flags: System.Security.AccessControl.ObjectAceFlags, type: System.Guid, inheritedType: System.Guid, isCallback: boolean, opaque: Byte[]);
        BinaryLength: number;
        InheritedObjectAceType: System.Guid;
        ObjectAceFlags: System.Security.AccessControl.ObjectAceFlags;
        ObjectAceType: System.Guid;
        AceQualifier: System.Security.AccessControl.AceQualifier;
        IsCallback: boolean;
        OpaqueLength: number;
        AccessMask: number;
        SecurityIdentifier: System.Security.Principal.SecurityIdentifier;
        AceFlags: System.Security.AccessControl.AceFlags;
        AceType: System.Security.AccessControl.AceType;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        static MaxOpaqueLength(isCallback: boolean): number;
        GetOpaque(): Byte[];
        SetOpaque(opaque: Byte[]): void;
        Copy(): System.Security.AccessControl.GenericAce;
        Equals(o: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum ObjectAceFlags {
        None = 0,
        ObjectAceTypePresent = 1,
        InheritedObjectAceTypePresent = 2,
      }
      export class ObjectAuditRule {
        InheritedObjectType: System.Guid;
        ObjectFlags: System.Security.AccessControl.ObjectAceFlags;
        ObjectType: System.Guid;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ObjectSecurity<T = any> {
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AddAccessRule(rule: System.Security.AccessControl.AccessRule<T>): void;
        RemoveAccessRule(rule: System.Security.AccessControl.AccessRule<T>): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.AccessRule<T>): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.AccessRule<T>): void;
        ResetAccessRule(rule: System.Security.AccessControl.AccessRule<T>): void;
        SetAccessRule(rule: System.Security.AccessControl.AccessRule<T>): void;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAuditRule(rule: System.Security.AccessControl.AuditRule<T>): void;
        RemoveAuditRule(rule: System.Security.AccessControl.AuditRule<T>): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.AuditRule<T>): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.AuditRule<T>): void;
        SetAuditRule(rule: System.Security.AccessControl.AuditRule<T>): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum PropagationFlags {
        None = 0,
        NoPropagateInherit = 1,
        InheritOnly = 2,
      }
      export class QualifiedAce {
        AceQualifier: System.Security.AccessControl.AceQualifier;
        IsCallback: boolean;
        OpaqueLength: number;
        AccessMask: number;
        SecurityIdentifier: System.Security.Principal.SecurityIdentifier;
        AceFlags: System.Security.AccessControl.AceFlags;
        AceType: System.Security.AccessControl.AceType;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        BinaryLength: number;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        GetOpaque(): Byte[];
        SetOpaque(opaque: Byte[]): void;
        Copy(): System.Security.AccessControl.GenericAce;
        Equals(o: any): boolean;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RawAcl {
        constructor(revision: Byte, capacity: number);
        constructor(binaryForm: Byte[], offset: number);
        BinaryLength: number;
        Count: number;
        Revision: Byte;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        InsertAce(index: number, ace: System.Security.AccessControl.GenericAce): void;
        RemoveAce(index: number): void;
        CopyTo(array: System.Security.AccessControl.GenericAce[], index: number): void;
        GetEnumerator(): System.Security.AccessControl.AceEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RawSecurityDescriptor {
        constructor(sddlForm: string);
        constructor(binaryForm: Byte[], offset: number);
        constructor(flags: System.Security.AccessControl.ControlFlags, owner: System.Security.Principal.SecurityIdentifier, group: System.Security.Principal.SecurityIdentifier, systemAcl: System.Security.AccessControl.RawAcl, discretionaryAcl: System.Security.AccessControl.RawAcl);
        ControlFlags: System.Security.AccessControl.ControlFlags;
        DiscretionaryAcl: System.Security.AccessControl.RawAcl;
        Group: System.Security.Principal.SecurityIdentifier;
        Owner: System.Security.Principal.SecurityIdentifier;
        ResourceManagerControl: Byte;
        SystemAcl: System.Security.AccessControl.RawAcl;
        BinaryLength: number;
        SetFlags(flags: System.Security.AccessControl.ControlFlags): void;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        GetSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum RegistryRights {
        QueryValues = 1,
        SetValue = 2,
        CreateSubKey = 4,
        EnumerateSubKeys = 8,
        Notify = 16,
        CreateLink = 32,
        Delete = 65536,
        ReadPermissions = 131072,
        WriteKey = 131078,
        ReadKey = 131097,
        ExecuteKey = 131097,
        ChangePermissions = 262144,
        TakeOwnership = 524288,
        FullControl = 983103,
      }
      export enum ResourceType {
        Unknown = 0,
        FileObject = 1,
        Service = 2,
        Printer = 3,
        RegistryKey = 4,
        LMShare = 5,
        KernelObject = 6,
        WindowObject = 7,
        DSObject = 8,
        DSObjectAll = 9,
        ProviderDefined = 10,
        WmiGuidObject = 11,
        RegistryWow6432Key = 12,
      }
      export enum SecurityInfos {
        Owner = 1,
        Group = 2,
        DiscretionaryAcl = 4,
        SystemAcl = 8,
      }
      export class SystemAcl {
        constructor(isContainer: boolean, isDS: boolean, capacity: number);
        constructor(isContainer: boolean, isDS: boolean, rawAcl: System.Security.AccessControl.RawAcl);
        constructor(isContainer: boolean, isDS: boolean, revision: Byte, capacity: number);
        BinaryLength: number;
        Count: number;
        IsCanonical: boolean;
        IsContainer: boolean;
        IsDS: boolean;
        Revision: Byte;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        AddAudit(auditFlags: System.Security.AccessControl.AuditFlags, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags): void;
        AddAudit(auditFlags: System.Security.AccessControl.AuditFlags, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, objectFlags: System.Security.AccessControl.ObjectAceFlags, objectType: System.Guid, inheritedObjectType: System.Guid): void;
        AddAudit(sid: System.Security.Principal.SecurityIdentifier, rule: System.Security.AccessControl.ObjectAuditRule): void;
        RemoveAudit(auditFlags: System.Security.AccessControl.AuditFlags, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags): boolean;
        RemoveAudit(auditFlags: System.Security.AccessControl.AuditFlags, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, objectFlags: System.Security.AccessControl.ObjectAceFlags, objectType: System.Guid, inheritedObjectType: System.Guid): boolean;
        RemoveAudit(sid: System.Security.Principal.SecurityIdentifier, rule: System.Security.AccessControl.ObjectAuditRule): boolean;
        RemoveAuditSpecific(auditFlags: System.Security.AccessControl.AuditFlags, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags): void;
        RemoveAuditSpecific(auditFlags: System.Security.AccessControl.AuditFlags, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, objectFlags: System.Security.AccessControl.ObjectAceFlags, objectType: System.Guid, inheritedObjectType: System.Guid): void;
        RemoveAuditSpecific(sid: System.Security.Principal.SecurityIdentifier, rule: System.Security.AccessControl.ObjectAuditRule): void;
        SetAudit(auditFlags: System.Security.AccessControl.AuditFlags, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags): void;
        SetAudit(auditFlags: System.Security.AccessControl.AuditFlags, sid: System.Security.Principal.SecurityIdentifier, accessMask: number, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, objectFlags: System.Security.AccessControl.ObjectAceFlags, objectType: System.Guid, inheritedObjectType: System.Guid): void;
        SetAudit(sid: System.Security.Principal.SecurityIdentifier, rule: System.Security.AccessControl.ObjectAuditRule): void;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        Purge(sid: System.Security.Principal.SecurityIdentifier): void;
        RemoveInheritedAces(): void;
        CopyTo(array: System.Security.AccessControl.GenericAce[], index: number): void;
        GetEnumerator(): System.Security.AccessControl.AceEnumerator;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SemaphoreAccessRule {
        constructor(identity: System.Security.Principal.IdentityReference, eventRights: System.Security.AccessControl.SemaphoreRights, type: System.Security.AccessControl.AccessControlType);
        constructor(identity: string, eventRights: System.Security.AccessControl.SemaphoreRights, type: System.Security.AccessControl.AccessControlType);
        SemaphoreRights: System.Security.AccessControl.SemaphoreRights;
        AccessControlType: System.Security.AccessControl.AccessControlType;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SemaphoreAuditRule {
        constructor(identity: System.Security.Principal.IdentityReference, eventRights: System.Security.AccessControl.SemaphoreRights, flags: System.Security.AccessControl.AuditFlags);
        SemaphoreRights: System.Security.AccessControl.SemaphoreRights;
        AuditFlags: System.Security.AccessControl.AuditFlags;
        IdentityReference: System.Security.Principal.IdentityReference;
        InheritanceFlags: System.Security.AccessControl.InheritanceFlags;
        IsInherited: boolean;
        PropagationFlags: System.Security.AccessControl.PropagationFlags;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum SemaphoreRights {
        Modify = 2,
        Delete = 65536,
        ReadPermissions = 131072,
        ChangePermissions = 262144,
        TakeOwnership = 524288,
        Synchronize = 1048576,
        FullControl = 2031619,
      }
      export class SemaphoreSecurity {
        constructor();
        constructor(name: string, includeSections: System.Security.AccessControl.AccessControlSections);
        AccessRightType: System.Type;
        AccessRuleType: System.Type;
        AuditRuleType: System.Type;
        AreAccessRulesCanonical: boolean;
        AreAccessRulesProtected: boolean;
        AreAuditRulesCanonical: boolean;
        AreAuditRulesProtected: boolean;
        AccessRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, type: System.Security.AccessControl.AccessControlType): System.Security.AccessControl.AccessRule;
        AddAccessRule(rule: System.Security.AccessControl.SemaphoreAccessRule): void;
        RemoveAccessRule(rule: System.Security.AccessControl.SemaphoreAccessRule): boolean;
        RemoveAccessRuleAll(rule: System.Security.AccessControl.SemaphoreAccessRule): void;
        RemoveAccessRuleSpecific(rule: System.Security.AccessControl.SemaphoreAccessRule): void;
        ResetAccessRule(rule: System.Security.AccessControl.SemaphoreAccessRule): void;
        SetAccessRule(rule: System.Security.AccessControl.SemaphoreAccessRule): void;
        AuditRuleFactory(identityReference: System.Security.Principal.IdentityReference, accessMask: number, isInherited: boolean, inheritanceFlags: System.Security.AccessControl.InheritanceFlags, propagationFlags: System.Security.AccessControl.PropagationFlags, flags: System.Security.AccessControl.AuditFlags): System.Security.AccessControl.AuditRule;
        AddAuditRule(rule: System.Security.AccessControl.SemaphoreAuditRule): void;
        RemoveAuditRule(rule: System.Security.AccessControl.SemaphoreAuditRule): boolean;
        RemoveAuditRuleAll(rule: System.Security.AccessControl.SemaphoreAuditRule): void;
        RemoveAuditRuleSpecific(rule: System.Security.AccessControl.SemaphoreAuditRule): void;
        SetAuditRule(rule: System.Security.AccessControl.SemaphoreAuditRule): void;
        GetAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: System.Type): System.Security.AccessControl.AuthorizationRuleCollection;
        GetGroup(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetOwner(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetSecurityDescriptorBinaryForm(): Byte[];
        GetSecurityDescriptorSddlForm(includeSections: System.Security.AccessControl.AccessControlSections): string;
        PurgeAccessRules(identity: System.Security.Principal.IdentityReference): void;
        PurgeAuditRules(identity: System.Security.Principal.IdentityReference): void;
        SetAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
        SetGroup(identity: System.Security.Principal.IdentityReference): void;
        SetOwner(identity: System.Security.Principal.IdentityReference): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[]): void;
        SetSecurityDescriptorBinaryForm(binaryForm: Byte[], includeSections: System.Security.AccessControl.AccessControlSections): void;
        SetSecurityDescriptorSddlForm(sddlForm: string): void;
        SetSecurityDescriptorSddlForm(sddlForm: string, includeSections: System.Security.AccessControl.AccessControlSections): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace Authentication {
      export class AuthenticationException {
        constructor();
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum CipherAlgorithmType {
        None = 0,
        Null = 24576,
        Aes = 26129,
        Aes128 = 26126,
        Aes192 = 26127,
        Aes256 = 26128,
        Des = 26113,
        Rc2 = 26114,
        Rc4 = 26625,
        TripleDes = 26115,
      }
      export enum ExchangeAlgorithmType {
        None = 0,
        DiffieHellman = 43522,
        RsaKeyX = 41984,
        RsaSign = 9216,
      }
      export enum HashAlgorithmType {
        None = 0,
        Md5 = 32771,
        Sha1 = 32772,
        Sha256 = 32780,
        Sha384 = 32781,
        Sha512 = 32782,
      }
      export class InvalidCredentialException {
        constructor();
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum SslProtocols {
        None = 0,
        Ssl2 = 12,
        Ssl3 = 48,
        Tls = 192,
        Tls11 = 768,
        Tls12 = 3072,
        Tls13 = 12288,
        Default = 240,
      }
      export namespace ExtendedProtection {
        export class ServiceNameCollection {
          constructor(items: System.Collections.ICollection);
          Count: number;
          Merge(serviceName: string): System.Security.Authentication.ExtendedProtection.ServiceNameCollection;
          Merge(serviceNames: System.Collections.IEnumerable): System.Security.Authentication.ExtendedProtection.ServiceNameCollection;
          Contains(searchServiceName: string): boolean;
          GetEnumerator(): System.Collections.IEnumerator;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export enum TokenBindingType {
          Provided = 0,
          Referred = 1,
        }
        export class TokenBinding {
          BindingType: System.Security.Authentication.ExtendedProtection.TokenBindingType;
          GetRawTokenBindingId(): Byte[];
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ChannelBinding {
          Size: number;
          IsInvalid: boolean;
          IsClosed: boolean;
          DangerousGetHandle(): System.IntPtr;
          Close(): void;
          Dispose(): void;
          SetHandleAsInvalid(): void;
          DangerousRelease(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export enum ChannelBindingKind {
          Unknown = 0,
          Unique = 25,
          Endpoint = 26,
        }
        export class ExtendedProtectionPolicy {
          constructor(policyEnforcement: System.Security.Authentication.ExtendedProtection.PolicyEnforcement);
          constructor(policyEnforcement: System.Security.Authentication.ExtendedProtection.PolicyEnforcement, customChannelBinding: System.Security.Authentication.ExtendedProtection.ChannelBinding);
          constructor(policyEnforcement: System.Security.Authentication.ExtendedProtection.PolicyEnforcement, protectionScenario: System.Security.Authentication.ExtendedProtection.ProtectionScenario, customServiceNames: System.Collections.ICollection);
          constructor(policyEnforcement: System.Security.Authentication.ExtendedProtection.PolicyEnforcement, protectionScenario: System.Security.Authentication.ExtendedProtection.ProtectionScenario, customServiceNames: System.Security.Authentication.ExtendedProtection.ServiceNameCollection);
          CustomChannelBinding: System.Security.Authentication.ExtendedProtection.ChannelBinding;
          CustomServiceNames: System.Security.Authentication.ExtendedProtection.ServiceNameCollection;
          static OSSupportsExtendedProtection: boolean;
          PolicyEnforcement: System.Security.Authentication.ExtendedProtection.PolicyEnforcement;
          ProtectionScenario: System.Security.Authentication.ExtendedProtection.ProtectionScenario;
          ToString(): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
        }
        export class ExtendedProtectionPolicyTypeConverter {
          constructor();
          CanConvertTo(context: System.ComponentModel.ITypeDescriptorContext, destinationType: System.Type): boolean;
          ConvertTo(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any, destinationType: System.Type): any;
          CanConvertFrom(sourceType: System.Type): boolean;
          CanConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, sourceType: System.Type): boolean;
          CanConvertTo(destinationType: System.Type): boolean;
          ConvertFrom(value: any): any;
          ConvertFrom(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): any;
          ConvertFromInvariantString(text: string): any;
          ConvertFromInvariantString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
          ConvertFromString(text: string): any;
          ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, text: string): any;
          ConvertFromString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, text: string): any;
          ConvertTo(value: any, destinationType: System.Type): any;
          ConvertToInvariantString(value: any): string;
          ConvertToInvariantString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
          ConvertToString(value: any): string;
          ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, value: any): string;
          ConvertToString(context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: any): string;
          CreateInstance(propertyValues: System.Collections.IDictionary): any;
          CreateInstance(context: System.ComponentModel.ITypeDescriptorContext, propertyValues: System.Collections.IDictionary): any;
          GetCreateInstanceSupported(): boolean;
          GetCreateInstanceSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
          GetProperties(value: any): System.ComponentModel.PropertyDescriptorCollection;
          GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any): System.ComponentModel.PropertyDescriptorCollection;
          GetProperties(context: System.ComponentModel.ITypeDescriptorContext, value: any, attributes: any[]): System.ComponentModel.PropertyDescriptorCollection;
          GetPropertiesSupported(): boolean;
          GetPropertiesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
          GetStandardValues(): System.Collections.ICollection;
          GetStandardValues(context: System.ComponentModel.ITypeDescriptorContext): System.ComponentModel.TypeConverter_StandardValuesCollection;
          GetStandardValuesExclusive(): boolean;
          GetStandardValuesExclusive(context: System.ComponentModel.ITypeDescriptorContext): boolean;
          GetStandardValuesSupported(): boolean;
          GetStandardValuesSupported(context: System.ComponentModel.ITypeDescriptorContext): boolean;
          IsValid(value: any): boolean;
          IsValid(context: System.ComponentModel.ITypeDescriptorContext, value: any): boolean;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export enum PolicyEnforcement {
          Never = 0,
          WhenSupported = 1,
          Always = 2,
        }
        export enum ProtectionScenario {
          TransportSelected = 0,
          TrustedProxy = 1,
        }
        export namespace Configuration {
          export class ExtendedProtectionPolicyElement {
            constructor();
            CustomServiceNames: System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElementCollection;
            PolicyEnforcement: System.Security.Authentication.ExtendedProtection.PolicyEnforcement;
            ProtectionScenario: System.Security.Authentication.ExtendedProtection.ProtectionScenario;
            ElementInformation: any; // System.Configuration.ElementInformation
            LockAllAttributesExcept: any; // System.Configuration.ConfigurationLockCollection
            LockAllElementsExcept: any; // System.Configuration.ConfigurationLockCollection
            LockAttributes: any; // System.Configuration.ConfigurationLockCollection
            LockElements: any; // System.Configuration.ConfigurationLockCollection
            LockItem: boolean;
            CurrentConfiguration: any; // System.Configuration.Configuration
            BuildPolicy(): System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy;
            Equals(compareTo: any): boolean;
            GetHashCode(): number;
            IsReadOnly(): boolean;
            GetType(): System.Type;
            ToString(): string;
          }
          export class ServiceNameElement {
            constructor();
            Name: string;
            ElementInformation: any; // System.Configuration.ElementInformation
            LockAllAttributesExcept: any; // System.Configuration.ConfigurationLockCollection
            LockAllElementsExcept: any; // System.Configuration.ConfigurationLockCollection
            LockAttributes: any; // System.Configuration.ConfigurationLockCollection
            LockElements: any; // System.Configuration.ConfigurationLockCollection
            LockItem: boolean;
            CurrentConfiguration: any; // System.Configuration.Configuration
            Equals(compareTo: any): boolean;
            GetHashCode(): number;
            IsReadOnly(): boolean;
            GetType(): System.Type;
            ToString(): string;
          }
          export class ServiceNameElementCollection {
            constructor();
            CollectionType: any; // System.Configuration.ConfigurationElementCollectionType
            Count: number;
            EmitClear: boolean;
            IsSynchronized: boolean;
            SyncRoot: any; // System.Object
            ElementInformation: any; // System.Configuration.ElementInformation
            LockAllAttributesExcept: any; // System.Configuration.ConfigurationLockCollection
            LockAllElementsExcept: any; // System.Configuration.ConfigurationLockCollection
            LockAttributes: any; // System.Configuration.ConfigurationLockCollection
            LockElements: any; // System.Configuration.ConfigurationLockCollection
            LockItem: boolean;
            CurrentConfiguration: any; // System.Configuration.Configuration
            Add(element: System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElement): void;
            Clear(): void;
            IndexOf(element: System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElement): number;
            Remove(name: string): void;
            Remove(element: System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElement): void;
            RemoveAt(index: number): void;
            CopyTo(array: any[], index: number): void;
            Equals(compareTo: any): boolean;
            GetHashCode(): number;
            GetEnumerator(): System.Collections.IEnumerator;
            IsReadOnly(): boolean;
            GetType(): System.Type;
            ToString(): string;
          }
        }
      }
    }
    export namespace Claims {
      export class ClaimTypes {
        static AuthenticationInstant: string;
        static AuthenticationMethod: string;
        static CookiePath: string;
        static DenyOnlyPrimarySid: string;
        static DenyOnlyPrimaryGroupSid: string;
        static DenyOnlyWindowsDeviceGroup: string;
        static Dsa: string;
        static Expiration: string;
        static Expired: string;
        static GroupSid: string;
        static IsPersistent: string;
        static PrimaryGroupSid: string;
        static PrimarySid: string;
        static Role: string;
        static SerialNumber: string;
        static UserData: string;
        static Version: string;
        static WindowsAccountName: string;
        static WindowsDeviceClaim: string;
        static WindowsDeviceGroup: string;
        static WindowsUserClaim: string;
        static WindowsFqbnVersion: string;
        static WindowsSubAuthority: string;
        static Anonymous: string;
        static Authentication: string;
        static AuthorizationDecision: string;
        static Country: string;
        static DateOfBirth: string;
        static Dns: string;
        static DenyOnlySid: string;
        static Email: string;
        static Gender: string;
        static GivenName: string;
        static Hash: string;
        static HomePhone: string;
        static Locality: string;
        static MobilePhone: string;
        static Name: string;
        static NameIdentifier: string;
        static OtherPhone: string;
        static PostalCode: string;
        static Rsa: string;
        static Sid: string;
        static Spn: string;
        static StateOrProvince: string;
        static StreetAddress: string;
        static Surname: string;
        static System: string;
        static Thumbprint: string;
        static Upn: string;
        static Uri: string;
        static Webpage: string;
        static X500DistinguishedName: string;
        static Actor: string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Claim {
        constructor(reader: System.IO.BinaryReader);
        constructor(reader: System.IO.BinaryReader, subject: System.Security.Claims.ClaimsIdentity);
        constructor(type: string, value: string);
        constructor(type: string, value: string, valueType: string);
        constructor(type: string, value: string, valueType: string, issuer: string);
        constructor(type: string, value: string, valueType: string, issuer: string, originalIssuer: string);
        constructor(type: string, value: string, valueType: string, issuer: string, originalIssuer: string, subject: System.Security.Claims.ClaimsIdentity);
        Issuer: string;
        OriginalIssuer: string;
        Properties: Record<string, string>;
        Subject: System.Security.Claims.ClaimsIdentity;
        Type: string;
        Value: string;
        ValueType: string;
        Clone(): System.Security.Claims.Claim;
        Clone(identity: System.Security.Claims.ClaimsIdentity): System.Security.Claims.Claim;
        WriteTo(writer: System.IO.BinaryWriter): void;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class ClaimValueTypes {
        static Base64Binary: string;
        static Base64Octet: string;
        static Boolean: string;
        static Date: string;
        static DateTime: string;
        static Double: string;
        static Fqbn: string;
        static HexBinary: string;
        static Integer: string;
        static Integer32: string;
        static Integer64: string;
        static Sid: string;
        static String: string;
        static Time: string;
        static UInteger32: string;
        static UInteger64: string;
        static DnsName: string;
        static Email: string;
        static Rsa: string;
        static UpnName: string;
        static DsaKeyValue: string;
        static KeyInfo: string;
        static RsaKeyValue: string;
        static DaytimeDuration: string;
        static YearMonthDuration: string;
        static Rfc822Name: string;
        static X500Name: string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ClaimsIdentity {
        constructor();
        constructor(identity: System.Security.Principal.IIdentity);
        constructor(claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>);
        constructor(authenticationType: string);
        constructor(claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, authenticationType: string);
        constructor(identity: System.Security.Principal.IIdentity, claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>);
        constructor(authenticationType: string, nameType: string, roleType: string);
        constructor(claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, authenticationType: string, nameType: string, roleType: string);
        constructor(identity: System.Security.Principal.IIdentity, claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, authenticationType: string, nameType: string, roleType: string);
        constructor(reader: System.IO.BinaryReader);
        AuthenticationType: string;
        IsAuthenticated: boolean;
        Actor: System.Security.Claims.ClaimsIdentity;
        BootstrapContext: any; // System.Object
        Claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        Label: string;
        Name: string;
        NameClaimType: string;
        RoleClaimType: string;
        static DefaultIssuer: string;
        static DefaultNameClaimType: string;
        static DefaultRoleClaimType: string;
        Clone(): System.Security.Claims.ClaimsIdentity;
        AddClaim(claim: System.Security.Claims.Claim): void;
        AddClaims(claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>): void;
        TryRemoveClaim(claim: System.Security.Claims.Claim): boolean;
        RemoveClaim(claim: System.Security.Claims.Claim): void;
        FindAll(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        FindAll(type: string): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        HasClaim(match: ((obj: System.Security.Claims.Claim) => boolean)): boolean;
        HasClaim(type: string, value: string): boolean;
        FindFirst(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Security.Claims.Claim;
        FindFirst(type: string): System.Security.Claims.Claim;
        WriteTo(writer: System.IO.BinaryWriter): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ClaimsPrincipal {
        constructor();
        constructor(identities: System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>);
        constructor(identity: System.Security.Principal.IIdentity);
        constructor(principal: System.Security.Principal.IPrincipal);
        constructor(reader: System.IO.BinaryReader);
        static PrimaryIdentitySelector: ((arg: any) => System.Security.Claims.ClaimsIdentity);
        static ClaimsPrincipalSelector: (() => System.Security.Claims.ClaimsPrincipal);
        Claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        static Current: System.Security.Claims.ClaimsPrincipal;
        Identities: System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>;
        Identity: System.Security.Principal.IIdentity;
        Clone(): System.Security.Claims.ClaimsPrincipal;
        AddIdentity(identity: System.Security.Claims.ClaimsIdentity): void;
        AddIdentities(identities: System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>): void;
        FindAll(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        FindAll(type: string): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        FindFirst(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Security.Claims.Claim;
        FindFirst(type: string): System.Security.Claims.Claim;
        HasClaim(match: ((obj: System.Security.Claims.Claim) => boolean)): boolean;
        HasClaim(type: string, value: string): boolean;
        IsInRole(role: string): boolean;
        WriteTo(writer: System.IO.BinaryWriter): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DynamicRoleClaimProvider {
        static AddDynamicRoleClaims(claimsIdentity: System.Security.Claims.ClaimsIdentity, claims: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
    export namespace Cryptography {
      export class Rfc2898DeriveBytes {
        constructor(password: Byte[], salt: Byte[], iterations: number);
        constructor(password: Byte[], salt: Byte[], iterations: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName);
        constructor(password: string, salt: Byte[]);
        constructor(password: string, salt: Byte[], iterations: number);
        constructor(password: string, salt: Byte[], iterations: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName);
        constructor(password: string, saltSize: number);
        constructor(password: string, saltSize: number, iterations: number);
        constructor(password: string, saltSize: number, iterations: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName);
        HashAlgorithm: System.Security.Cryptography.HashAlgorithmName;
        IterationCount: number;
        Salt: Byte[];
        GetBytes(cb: number): Byte[];
        CryptDeriveKey(algname: string, alghashname: string, keySize: number, rgbIV: Byte[]): Byte[];
        Reset(): void;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface ICspAsymmetricAlgorithm {
        CspKeyContainerInfo: System.Security.Cryptography.CspKeyContainerInfo;
        ExportCspBlob(includePrivateParameters: boolean): Byte[];
        ImportCspBlob(rawData: Byte[]): void;
      }
      export enum KeyNumber {
        Exchange = 1,
        Signature = 2,
      }
      export class CryptoStream {
        constructor(stream: System.IO.Stream, transform: System.Security.Cryptography.ICryptoTransform, mode: System.Security.Cryptography.CryptoStreamMode);
        constructor(stream: System.IO.Stream, transform: System.Security.Cryptography.ICryptoTransform, mode: System.Security.Cryptography.CryptoStreamMode, leaveOpen: boolean);
        CanRead: boolean;
        CanSeek: boolean;
        CanWrite: boolean;
        Length: number;
        Position: number;
        HasFlushedFinalBlock: boolean;
        CanTimeout: boolean;
        ReadTimeout: number;
        WriteTimeout: number;
        FlushFinalBlock(): void;
        Flush(): void;
        FlushAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        Seek(offset: number, origin: System.IO.SeekOrigin): number;
        SetLength(value: number): void;
        ReadAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<number>;
        BeginRead(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndRead(asyncResult: System.IAsyncResult): number;
        ReadByte(): number;
        WriteByte(value: Byte): void;
        Read(buffer: Byte[], offset: number, count: number): number;
        WriteAsync(buffer: Byte[], offset: number, count: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        BeginWrite(buffer: Byte[], offset: number, count: number, callback: ((ar: System.IAsyncResult) => void), state: any): System.IAsyncResult;
        EndWrite(asyncResult: System.IAsyncResult): void;
        Write(buffer: Byte[], offset: number, count: number): void;
        Clear(): void;
        CopyToAsync(destination: System.IO.Stream): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        CopyTo(destination: System.IO.Stream): void;
        CopyTo(destination: System.IO.Stream, bufferSize: number): void;
        Close(): void;
        Dispose(): void;
        FlushAsync(): System.Threading.Tasks.Task;
        ReadAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task<number>;
        ReadAsync(buffer: System.Memory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask<number>;
        WriteAsync(buffer: Byte[], offset: number, count: number): System.Threading.Tasks.Task;
        WriteAsync(buffer: System.ReadOnlyMemory<Byte>, cancellationToken?: System.Threading.CancellationToken): System.Threading.Tasks.ValueTask;
        Read(buffer: System.Span<Byte>): number;
        Write(buffer: System.ReadOnlySpan<Byte>): void;
        DisposeAsync(): System.Threading.Tasks.ValueTask;
        CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
        GetLifetimeService(): any;
        InitializeLifetimeService(): any;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum CryptoStreamMode {
        Read = 0,
        Write = 1,
      }
      export class CryptographicOperations {
        static FixedTimeEquals(left: any, right: any): boolean;
        static ZeroMemory(buffer: any): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HashAlgorithm {
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        static Create(): System.Security.Cryptography.HashAlgorithm;
        static Create(hashName: string): System.Security.Cryptography.HashAlgorithm;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Initialize(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HashAlgorithmName {
        constructor(name: string);
        static MD5: System.Security.Cryptography.HashAlgorithmName;
        static SHA1: System.Security.Cryptography.HashAlgorithmName;
        static SHA256: System.Security.Cryptography.HashAlgorithmName;
        static SHA384: System.Security.Cryptography.HashAlgorithmName;
        static SHA512: System.Security.Cryptography.HashAlgorithmName;
        Name: string;
        ToString(): string;
        Equals(obj: any): boolean;
        Equals(other: System.Security.Cryptography.HashAlgorithmName): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class RSAEncryptionPadding {
        static Pkcs1: System.Security.Cryptography.RSAEncryptionPadding;
        static OaepSHA1: System.Security.Cryptography.RSAEncryptionPadding;
        static OaepSHA256: System.Security.Cryptography.RSAEncryptionPadding;
        static OaepSHA384: System.Security.Cryptography.RSAEncryptionPadding;
        static OaepSHA512: System.Security.Cryptography.RSAEncryptionPadding;
        Mode: System.Security.Cryptography.RSAEncryptionPaddingMode;
        OaepHashAlgorithm: System.Security.Cryptography.HashAlgorithmName;
        static CreateOaep(hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): System.Security.Cryptography.RSAEncryptionPadding;
        GetHashCode(): number;
        Equals(obj: any): boolean;
        Equals(other: System.Security.Cryptography.RSAEncryptionPadding): boolean;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum RSAEncryptionPaddingMode {
        Pkcs1 = 0,
        Oaep = 1,
      }
      export class RSASignaturePadding {
        static Pkcs1: System.Security.Cryptography.RSASignaturePadding;
        static Pss: System.Security.Cryptography.RSASignaturePadding;
        Mode: System.Security.Cryptography.RSASignaturePaddingMode;
        GetHashCode(): number;
        Equals(obj: any): boolean;
        Equals(other: System.Security.Cryptography.RSASignaturePadding): boolean;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum RSASignaturePaddingMode {
        Pkcs1 = 0,
        Pss = 1,
      }
      export class Aes {
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        Key: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        KeySize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        static Create(): System.Security.Cryptography.Aes;
        static Create(algorithmName: string): System.Security.Cryptography.Aes;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AsymmetricAlgorithm {
        KeySize: number;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        SignatureAlgorithm: string;
        KeyExchangeAlgorithm: string;
        Dispose(): void;
        Clear(): void;
        static Create(): System.Security.Cryptography.AsymmetricAlgorithm;
        static Create(algName: string): System.Security.Cryptography.AsymmetricAlgorithm;
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AsymmetricKeyExchangeDeformatter {
        Parameters: string;
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        DecryptKeyExchange(rgb: Byte[]): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AsymmetricKeyExchangeFormatter {
        Parameters: string;
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        CreateKeyExchange(data: Byte[]): Byte[];
        CreateKeyExchange(data: Byte[], symAlgType: System.Type): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AsymmetricSignatureDeformatter {
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        SetHashAlgorithm(strName: string): void;
        VerifySignature(hash: System.Security.Cryptography.HashAlgorithm, rgbSignature: Byte[]): boolean;
        VerifySignature(rgbHash: Byte[], rgbSignature: Byte[]): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AsymmetricSignatureFormatter {
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        SetHashAlgorithm(strName: string): void;
        CreateSignature(hash: System.Security.Cryptography.HashAlgorithm): Byte[];
        CreateSignature(rgbHash: Byte[]): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum FromBase64TransformMode {
        IgnoreWhiteSpaces = 0,
        DoNotIgnoreWhiteSpaces = 1,
      }
      export class ToBase64Transform {
        constructor();
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Dispose(): void;
        Clear(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FromBase64Transform {
        constructor();
        constructor(whitespaces: System.Security.Cryptography.FromBase64TransformMode);
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Dispose(): void;
        Clear(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum CipherMode {
        CBC = 1,
        ECB = 2,
        OFB = 3,
        CFB = 4,
        CTS = 5,
      }
      export enum PaddingMode {
        None = 1,
        PKCS7 = 2,
        Zeros = 3,
        ANSIX923 = 4,
        ISO10126 = 5,
      }
      export class KeySizes {
        constructor(minSize: number, maxSize: number, skipSize: number);
        MinSize: number;
        MaxSize: number;
        SkipSize: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CryptographicException {
        constructor();
        constructor(message: string);
        constructor(format: string, insert: string);
        constructor(message: string, inner: System.Exception);
        constructor(hr: number);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class CryptographicUnexpectedOperationException {
        constructor();
        constructor(message: string);
        constructor(format: string, insert: string);
        constructor(message: string, inner: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum CspProviderFlags {
        NoFlags = 0,
        UseMachineKeyStore = 1,
        UseDefaultKeyContainer = 2,
        UseNonExportableKey = 4,
        UseExistingKey = 8,
        UseArchivableKey = 16,
        UseUserProtectedKey = 32,
        NoPrompt = 64,
        CreateEphemeralKey = 128,
      }
      export class CspParameters {
        constructor();
        constructor(dwTypeIn: number);
        constructor(dwTypeIn: number, strProviderNameIn: string);
        constructor(dwTypeIn: number, strProviderNameIn: string, strContainerNameIn: string);
        constructor(providerType: number, providerName: string, keyContainerName: string, cryptoKeySecurity: System.Security.AccessControl.CryptoKeySecurity, keyPassword: System.Security.SecureString);
        constructor(providerType: number, providerName: string, keyContainerName: string, cryptoKeySecurity: System.Security.AccessControl.CryptoKeySecurity, parentWindowHandle: System.IntPtr);
        Flags: System.Security.Cryptography.CspProviderFlags;
        CryptoKeySecurity: System.Security.AccessControl.CryptoKeySecurity;
        KeyPassword: System.Security.SecureString;
        ParentWindowHandle: System.IntPtr;
        ProviderType: number;
        ProviderName: string;
        KeyContainerName: string;
        KeyNumber: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DeriveBytes {
        GetBytes(cb: number): Byte[];
        Reset(): void;
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DES {
        Key: Byte[];
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        KeySize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        static Create(): System.Security.Cryptography.DES;
        static Create(algName: string): System.Security.Cryptography.DES;
        static IsWeakKey(rgbKey: Byte[]): boolean;
        static IsSemiWeakKey(rgbKey: Byte[]): boolean;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DESCryptoServiceProvider {
        constructor();
        Key: Byte[];
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        KeySize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DSAParameters {
        P: Byte[];
        Q: Byte[];
        G: Byte[];
        Y: Byte[];
        J: Byte[];
        X: Byte[];
        Seed: Byte[];
        Counter: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class DSA {
        KeySize: number;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        SignatureAlgorithm: string;
        KeyExchangeAlgorithm: string;
        static Create(): System.Security.Cryptography.DSA;
        static Create(algName: string): System.Security.Cryptography.DSA;
        CreateSignature(rgbHash: Byte[]): Byte[];
        VerifySignature(rgbHash: Byte[], rgbSignature: Byte[]): boolean;
        SignData(data: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: Byte[], offset: number, count: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: System.IO.Stream, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        VerifyData(data: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: Byte[], offset: number, count: number, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: System.IO.Stream, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.DSAParameters;
        ImportParameters(parameters: System.Security.Cryptography.DSAParameters): void;
        static Create(keySizeInBits: number): System.Security.Cryptography.DSA;
        static Create(parameters: System.Security.Cryptography.DSAParameters): System.Security.Cryptography.DSA;
        VerifyData(data: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifySignature(hash: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>): boolean;
        Dispose(): void;
        Clear(): void;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DSASignatureDeformatter {
        constructor();
        constructor(key: System.Security.Cryptography.AsymmetricAlgorithm);
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        SetHashAlgorithm(strName: string): void;
        VerifySignature(rgbHash: Byte[], rgbSignature: Byte[]): boolean;
        VerifySignature(hash: System.Security.Cryptography.HashAlgorithm, rgbSignature: Byte[]): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DSASignatureFormatter {
        constructor();
        constructor(key: System.Security.Cryptography.AsymmetricAlgorithm);
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        SetHashAlgorithm(strName: string): void;
        CreateSignature(rgbHash: Byte[]): Byte[];
        CreateSignature(hash: System.Security.Cryptography.HashAlgorithm): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HMAC {
        Key: Byte[];
        HashName: string;
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        static Create(): System.Security.Cryptography.HMAC;
        static Create(algorithmName: string): System.Security.Cryptography.HMAC;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HMACMD5 {
        constructor();
        constructor(key: Byte[]);
        Key: Byte[];
        HashName: string;
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HMACRIPEMD160 {
        constructor();
        constructor(key: Byte[]);
        Key: Byte[];
        HashName: string;
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HMACSHA1 {
        constructor();
        constructor(key: Byte[]);
        constructor(key: Byte[], useManagedSha1: boolean);
        Key: Byte[];
        HashName: string;
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HMACSHA256 {
        constructor();
        constructor(key: Byte[]);
        Key: Byte[];
        HashName: string;
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HMACSHA384 {
        constructor();
        constructor(key: Byte[]);
        ProduceLegacyHmacValues: boolean;
        Key: Byte[];
        HashName: string;
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class HMACSHA512 {
        constructor();
        constructor(key: Byte[]);
        ProduceLegacyHmacValues: boolean;
        Key: Byte[];
        HashName: string;
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export interface ICryptoTransform {
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
      }
      export class KeyedHashAlgorithm {
        Key: Byte[];
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        static Create(): System.Security.Cryptography.KeyedHashAlgorithm;
        static Create(algName: string): System.Security.Cryptography.KeyedHashAlgorithm;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Initialize(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MACTripleDES {
        constructor();
        constructor(rgbKey: Byte[]);
        constructor(strTripleDES: string, rgbKey: Byte[]);
        Padding: System.Security.Cryptography.PaddingMode;
        Key: Byte[];
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MaskGenerationMethod {
        GenerateMask(rgbSeed: Byte[], cbReturn: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MD5 {
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        static Create(): System.Security.Cryptography.MD5;
        static Create(algName: string): System.Security.Cryptography.MD5;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Initialize(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class PasswordDeriveBytes {
        constructor(strPassword: string, rgbSalt: Byte[]);
        constructor(password: Byte[], salt: Byte[]);
        constructor(strPassword: string, rgbSalt: Byte[], strHashName: string, iterations: number);
        constructor(password: Byte[], salt: Byte[], hashName: string, iterations: number);
        constructor(strPassword: string, rgbSalt: Byte[], cspParams: System.Security.Cryptography.CspParameters);
        constructor(password: Byte[], salt: Byte[], cspParams: System.Security.Cryptography.CspParameters);
        constructor(strPassword: string, rgbSalt: Byte[], strHashName: string, iterations: number, cspParams: System.Security.Cryptography.CspParameters);
        constructor(password: Byte[], salt: Byte[], hashName: string, iterations: number, cspParams: System.Security.Cryptography.CspParameters);
        HashName: string;
        IterationCount: number;
        Salt: Byte[];
        GetBytes(cb: number): Byte[];
        Reset(): void;
        CryptDeriveKey(algname: string, alghashname: string, keySize: number, rgbIV: Byte[]): Byte[];
        Dispose(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class PKCS1MaskGenerationMethod {
        constructor();
        HashName: string;
        GenerateMask(rgbSeed: Byte[], cbReturn: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RandomNumberGenerator {
        static Create(): System.Security.Cryptography.RandomNumberGenerator;
        static Create(rngName: string): System.Security.Cryptography.RandomNumberGenerator;
        Dispose(): void;
        GetBytes(data: Byte[]): void;
        GetBytes(data: Byte[], offset: number, count: number): void;
        GetNonZeroBytes(data: Byte[]): void;
        static Fill(data: any): void;
        GetBytes(data: System.Span<Byte>): void;
        GetNonZeroBytes(data: System.Span<Byte>): void;
        static GetInt32(fromInclusive: number, toExclusive: number): number;
        static GetInt32(toExclusive: number): number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RC2 {
        EffectiveKeySize: number;
        KeySize: number;
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        Key: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        static Create(): System.Security.Cryptography.RC2;
        static Create(AlgName: string): System.Security.Cryptography.RC2;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RC2CryptoServiceProvider {
        constructor();
        EffectiveKeySize: number;
        UseSalt: boolean;
        KeySize: number;
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        Key: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Rijndael {
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        Key: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        KeySize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        static Create(): System.Security.Cryptography.Rijndael;
        static Create(algName: string): System.Security.Cryptography.Rijndael;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RijndaelManaged {
        constructor();
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        Key: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        KeySize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RijndaelManagedTransform {
        BlockSizeValue: number;
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Reset(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RIPEMD160 {
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        static Create(): System.Security.Cryptography.RIPEMD160;
        static Create(hashName: string): System.Security.Cryptography.RIPEMD160;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Initialize(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RIPEMD160Managed {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RSAParameters {
        Exponent: Byte[];
        Modulus: Byte[];
        P: Byte[];
        Q: Byte[];
        DP: Byte[];
        DQ: Byte[];
        InverseQ: Byte[];
        D: Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class RSA {
        KeyExchangeAlgorithm: string;
        SignatureAlgorithm: string;
        KeySize: number;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        static Create(): System.Security.Cryptography.RSA;
        static Create(algName: string): System.Security.Cryptography.RSA;
        Encrypt(data: Byte[], padding: System.Security.Cryptography.RSAEncryptionPadding): Byte[];
        Decrypt(data: Byte[], padding: System.Security.Cryptography.RSAEncryptionPadding): Byte[];
        SignHash(hash: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        VerifyHash(hash: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        SignData(data: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        SignData(data: Byte[], offset: number, count: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        SignData(data: System.IO.Stream, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        VerifyData(data: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        VerifyData(data: Byte[], offset: number, count: number, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        VerifyData(data: System.IO.Stream, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        DecryptValue(rgb: Byte[]): Byte[];
        EncryptValue(rgb: Byte[]): Byte[];
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.RSAParameters;
        ImportParameters(parameters: System.Security.Cryptography.RSAParameters): void;
        static Create(keySizeInBits: number): System.Security.Cryptography.RSA;
        static Create(parameters: System.Security.Cryptography.RSAParameters): System.Security.Cryptography.RSA;
        VerifyData(data: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        VerifyHash(hash: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        ExportRSAPrivateKey(): Byte[];
        ExportRSAPublicKey(): Byte[];
        Dispose(): void;
        Clear(): void;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RSACryptoServiceProvider {
        constructor();
        constructor(parameters: System.Security.Cryptography.CspParameters);
        constructor(dwKeySize: number);
        constructor(dwKeySize: number, parameters: System.Security.Cryptography.CspParameters);
        SignatureAlgorithm: string;
        static UseMachineKeyStore: boolean;
        KeyExchangeAlgorithm: string;
        KeySize: number;
        PersistKeyInCsp: boolean;
        PublicOnly: boolean;
        CspKeyContainerInfo: System.Security.Cryptography.CspKeyContainerInfo;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        Encrypt(data: Byte[], padding: System.Security.Cryptography.RSAEncryptionPadding): Byte[];
        Decrypt(data: Byte[], padding: System.Security.Cryptography.RSAEncryptionPadding): Byte[];
        SignHash(hash: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        VerifyHash(hash: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        Decrypt(rgb: Byte[], fOAEP: boolean): Byte[];
        DecryptValue(rgb: Byte[]): Byte[];
        Encrypt(rgb: Byte[], fOAEP: boolean): Byte[];
        EncryptValue(rgb: Byte[]): Byte[];
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.RSAParameters;
        ImportParameters(parameters: System.Security.Cryptography.RSAParameters): void;
        SignData(buffer: Byte[], halg: any): Byte[];
        SignData(inputStream: System.IO.Stream, halg: any): Byte[];
        SignData(buffer: Byte[], offset: number, count: number, halg: any): Byte[];
        SignHash(rgbHash: Byte[], str: string): Byte[];
        VerifyData(buffer: Byte[], halg: any, signature: Byte[]): boolean;
        VerifyHash(rgbHash: Byte[], str: string, rgbSignature: Byte[]): boolean;
        ExportCspBlob(includePrivateParameters: boolean): Byte[];
        ImportCspBlob(keyBlob: Byte[]): void;
        SignData(data: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        SignData(data: Byte[], offset: number, count: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        SignData(data: System.IO.Stream, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        VerifyData(data: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        VerifyData(data: Byte[], offset: number, count: number, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        VerifyData(data: System.IO.Stream, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        VerifyData(data: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        VerifyHash(hash: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        ExportRSAPrivateKey(): Byte[];
        ExportRSAPublicKey(): Byte[];
        Dispose(): void;
        Clear(): void;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RSAOAEPKeyExchangeDeformatter {
        constructor();
        constructor(key: System.Security.Cryptography.AsymmetricAlgorithm);
        Parameters: string;
        DecryptKeyExchange(rgbData: Byte[]): Byte[];
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RSAOAEPKeyExchangeFormatter {
        constructor();
        constructor(key: System.Security.Cryptography.AsymmetricAlgorithm);
        Parameter: Byte[];
        Parameters: string;
        Rng: System.Security.Cryptography.RandomNumberGenerator;
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        CreateKeyExchange(rgbData: Byte[]): Byte[];
        CreateKeyExchange(rgbData: Byte[], symAlgType: System.Type): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RSAPKCS1KeyExchangeDeformatter {
        constructor();
        constructor(key: System.Security.Cryptography.AsymmetricAlgorithm);
        RNG: System.Security.Cryptography.RandomNumberGenerator;
        Parameters: string;
        DecryptKeyExchange(rgbIn: Byte[]): Byte[];
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RSAPKCS1KeyExchangeFormatter {
        constructor();
        constructor(key: System.Security.Cryptography.AsymmetricAlgorithm);
        Parameters: string;
        Rng: System.Security.Cryptography.RandomNumberGenerator;
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        CreateKeyExchange(rgbData: Byte[]): Byte[];
        CreateKeyExchange(rgbData: Byte[], symAlgType: System.Type): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA1 {
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        static Create(): System.Security.Cryptography.SHA1;
        static Create(hashName: string): System.Security.Cryptography.SHA1;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Initialize(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA1Managed {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA256 {
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        static Create(): System.Security.Cryptography.SHA256;
        static Create(hashName: string): System.Security.Cryptography.SHA256;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Initialize(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA256Managed {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA384 {
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        static Create(): System.Security.Cryptography.SHA384;
        static Create(hashName: string): System.Security.Cryptography.SHA384;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Initialize(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA384Managed {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA512 {
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        static Create(): System.Security.Cryptography.SHA512;
        static Create(hashName: string): System.Security.Cryptography.SHA512;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Initialize(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA512Managed {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SignatureDescription {
        constructor();
        constructor(el: System.Security.SecurityElement);
        KeyAlgorithm: string;
        DigestAlgorithm: string;
        FormatterAlgorithm: string;
        DeformatterAlgorithm: string;
        CreateDeformatter(key: System.Security.Cryptography.AsymmetricAlgorithm): System.Security.Cryptography.AsymmetricSignatureDeformatter;
        CreateFormatter(key: System.Security.Cryptography.AsymmetricAlgorithm): System.Security.Cryptography.AsymmetricSignatureFormatter;
        CreateDigest(): System.Security.Cryptography.HashAlgorithm;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SymmetricAlgorithm {
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        Key: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        KeySize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        static Create(): System.Security.Cryptography.SymmetricAlgorithm;
        static Create(algName: string): System.Security.Cryptography.SymmetricAlgorithm;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class TripleDES {
        Key: Byte[];
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        KeySize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        static Create(): System.Security.Cryptography.TripleDES;
        static Create(str: string): System.Security.Cryptography.TripleDES;
        static IsWeakKey(rgbKey: Byte[]): boolean;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class TripleDESCryptoServiceProvider {
        constructor();
        Key: Byte[];
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        KeySize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateKey(): void;
        GenerateIV(): void;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CryptoAPITransform {
        CanReuseTransform: boolean;
        CanTransformMultipleBlocks: boolean;
        InputBlockSize: number;
        KeyHandle: System.IntPtr;
        OutputBlockSize: number;
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Reset(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CryptoConfig {
        constructor();
        static AllowOnlyFipsAlgorithms: boolean;
        static AddOID(oid: string, ...names: string[]): void;
        static CreateFromName(name: string): any;
        static CreateFromName(name: string, ...args: any[]): any;
        static MapNameToOID(name: string): string;
        static AddAlgorithm(algorithm: System.Type, ...names: string[]): void;
        static EncodeOID(str: string): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CspKeyContainerInfo {
        constructor(parameters: System.Security.Cryptography.CspParameters);
        Accessible: boolean;
        CryptoKeySecurity: System.Security.AccessControl.CryptoKeySecurity;
        Exportable: boolean;
        HardwareDevice: boolean;
        KeyContainerName: string;
        KeyNumber: System.Security.Cryptography.KeyNumber;
        MachineKeyStore: boolean;
        Protected: boolean;
        ProviderName: string;
        ProviderType: number;
        RandomlyGenerated: boolean;
        Removable: boolean;
        UniqueKeyContainerName: string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DSACryptoServiceProvider {
        constructor();
        constructor(parameters: System.Security.Cryptography.CspParameters);
        constructor(dwKeySize: number);
        constructor(dwKeySize: number, parameters: System.Security.Cryptography.CspParameters);
        KeyExchangeAlgorithm: string;
        KeySize: number;
        PersistKeyInCsp: boolean;
        PublicOnly: boolean;
        SignatureAlgorithm: string;
        static UseMachineKeyStore: boolean;
        CspKeyContainerInfo: System.Security.Cryptography.CspKeyContainerInfo;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.DSAParameters;
        ImportParameters(parameters: System.Security.Cryptography.DSAParameters): void;
        CreateSignature(rgbHash: Byte[]): Byte[];
        SignData(buffer: Byte[]): Byte[];
        SignData(buffer: Byte[], offset: number, count: number): Byte[];
        SignData(inputStream: System.IO.Stream): Byte[];
        SignHash(rgbHash: Byte[], str: string): Byte[];
        VerifyData(rgbData: Byte[], rgbSignature: Byte[]): boolean;
        VerifyHash(rgbHash: Byte[], str: string, rgbSignature: Byte[]): boolean;
        VerifySignature(rgbHash: Byte[], rgbSignature: Byte[]): boolean;
        ExportCspBlob(includePrivateParameters: boolean): Byte[];
        ImportCspBlob(keyBlob: Byte[]): void;
        SignData(data: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: Byte[], offset: number, count: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: System.IO.Stream, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        VerifyData(data: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: Byte[], offset: number, count: number, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: System.IO.Stream, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        VerifyData(data: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifySignature(hash: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>): boolean;
        Dispose(): void;
        Clear(): void;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MD5CryptoServiceProvider {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RNGCryptoServiceProvider {
        constructor();
        constructor(rgb: Byte[]);
        constructor(cspParams: System.Security.Cryptography.CspParameters);
        constructor(str: string);
        GetBytes(data: Byte[]): void;
        GetNonZeroBytes(data: Byte[]): void;
        Dispose(): void;
        GetBytes(data: Byte[], offset: number, count: number): void;
        GetBytes(data: System.Span<Byte>): void;
        GetNonZeroBytes(data: System.Span<Byte>): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RSAPKCS1SignatureDeformatter {
        constructor();
        constructor(key: System.Security.Cryptography.AsymmetricAlgorithm);
        SetHashAlgorithm(strName: string): void;
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        VerifySignature(rgbHash: Byte[], rgbSignature: Byte[]): boolean;
        VerifySignature(hash: System.Security.Cryptography.HashAlgorithm, rgbSignature: Byte[]): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RSAPKCS1SignatureFormatter {
        constructor();
        constructor(key: System.Security.Cryptography.AsymmetricAlgorithm);
        CreateSignature(rgbHash: Byte[]): Byte[];
        SetHashAlgorithm(strName: string): void;
        SetKey(key: System.Security.Cryptography.AsymmetricAlgorithm): void;
        CreateSignature(hash: System.Security.Cryptography.HashAlgorithm): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA1CryptoServiceProvider {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AesCcm {
        constructor(key: Byte[]);
        constructor(key: System.ReadOnlySpan<Byte>);
        static NonceByteSizes: System.Security.Cryptography.KeySizes;
        static TagByteSizes: System.Security.Cryptography.KeySizes;
        Decrypt(nonce: Byte[], ciphertext: Byte[], tag: Byte[], plaintext: Byte[], associatedData?: Byte[]): void;
        Decrypt(nonce: System.ReadOnlySpan<Byte>, ciphertext: System.ReadOnlySpan<Byte>, tag: System.ReadOnlySpan<Byte>, plaintext: System.Span<Byte>, associatedData?: System.ReadOnlySpan<Byte>): void;
        Dispose(): void;
        Encrypt(nonce: Byte[], plaintext: Byte[], ciphertext: Byte[], tag: Byte[], associatedData?: Byte[]): void;
        Encrypt(nonce: System.ReadOnlySpan<Byte>, plaintext: System.ReadOnlySpan<Byte>, ciphertext: System.Span<Byte>, tag: System.Span<Byte>, associatedData?: System.ReadOnlySpan<Byte>): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AesGcm {
        constructor(key: Byte[]);
        constructor(key: System.ReadOnlySpan<Byte>);
        static NonceByteSizes: System.Security.Cryptography.KeySizes;
        static TagByteSizes: System.Security.Cryptography.KeySizes;
        Decrypt(nonce: Byte[], ciphertext: Byte[], tag: Byte[], plaintext: Byte[], associatedData?: Byte[]): void;
        Decrypt(nonce: System.ReadOnlySpan<Byte>, ciphertext: System.ReadOnlySpan<Byte>, tag: System.ReadOnlySpan<Byte>, plaintext: System.Span<Byte>, associatedData?: System.ReadOnlySpan<Byte>): void;
        Dispose(): void;
        Encrypt(nonce: Byte[], plaintext: Byte[], ciphertext: Byte[], tag: Byte[], associatedData?: Byte[]): void;
        Encrypt(nonce: System.ReadOnlySpan<Byte>, plaintext: System.ReadOnlySpan<Byte>, ciphertext: System.Span<Byte>, tag: System.Span<Byte>, associatedData?: System.ReadOnlySpan<Byte>): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum PbeEncryptionAlgorithm {
        Unknown = 0,
        Aes128Cbc = 1,
        Aes192Cbc = 2,
        Aes256Cbc = 3,
        TripleDes3KeyPkcs12 = 4,
      }
      export class PbeParameters {
        constructor(encryptionAlgorithm: System.Security.Cryptography.PbeEncryptionAlgorithm, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, iterationCount: number);
        EncryptionAlgorithm: System.Security.Cryptography.PbeEncryptionAlgorithm;
        HashAlgorithm: System.Security.Cryptography.HashAlgorithmName;
        IterationCount: number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ECCurve {
        Oid: System.Security.Cryptography.Oid;
        IsPrime: boolean;
        IsCharacteristic2: boolean;
        IsExplicit: boolean;
        IsNamed: boolean;
        A: Byte[];
        B: Byte[];
        G: System.Security.Cryptography.ECPoint;
        Order: Byte[];
        Cofactor: Byte[];
        Seed: Byte[];
        CurveType: System.Security.Cryptography.ECCurve_ECCurveType;
        Hash?: System.Security.Cryptography.HashAlgorithmName | undefined;
        Polynomial: Byte[];
        Prime: Byte[];
        static CreateFromOid(curveOid: System.Security.Cryptography.Oid): System.Security.Cryptography.ECCurve;
        static CreateFromFriendlyName(oidFriendlyName: string): System.Security.Cryptography.ECCurve;
        static CreateFromValue(oidValue: string): System.Security.Cryptography.ECCurve;
        Validate(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum ECCurve_ECCurveType {
        Implicit = 0,
        PrimeShortWeierstrass = 1,
        PrimeTwistedEdwards = 2,
        PrimeMontgomery = 3,
        Characteristic2 = 4,
        Named = 5,
      }
      export class ECCurve_NamedCurves {
        static brainpoolP160r1: System.Security.Cryptography.ECCurve;
        static brainpoolP160t1: System.Security.Cryptography.ECCurve;
        static brainpoolP192r1: System.Security.Cryptography.ECCurve;
        static brainpoolP192t1: System.Security.Cryptography.ECCurve;
        static brainpoolP224r1: System.Security.Cryptography.ECCurve;
        static brainpoolP224t1: System.Security.Cryptography.ECCurve;
        static brainpoolP256r1: System.Security.Cryptography.ECCurve;
        static brainpoolP256t1: System.Security.Cryptography.ECCurve;
        static brainpoolP320r1: System.Security.Cryptography.ECCurve;
        static brainpoolP320t1: System.Security.Cryptography.ECCurve;
        static brainpoolP384r1: System.Security.Cryptography.ECCurve;
        static brainpoolP384t1: System.Security.Cryptography.ECCurve;
        static brainpoolP512r1: System.Security.Cryptography.ECCurve;
        static brainpoolP512t1: System.Security.Cryptography.ECCurve;
        static nistP256: System.Security.Cryptography.ECCurve;
        static nistP384: System.Security.Cryptography.ECCurve;
        static nistP521: System.Security.Cryptography.ECCurve;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ECParameters {
        Q: System.Security.Cryptography.ECPoint;
        D: Byte[];
        Curve: System.Security.Cryptography.ECCurve;
        Validate(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ECPoint {
        X: Byte[];
        Y: Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class IncrementalHash {
        AlgorithmName: System.Security.Cryptography.HashAlgorithmName;
        AppendData(data: Byte[]): void;
        AppendData(data: Byte[], offset: number, count: number): void;
        GetHashAndReset(): Byte[];
        Dispose(): void;
        static CreateHash(hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): System.Security.Cryptography.IncrementalHash;
        static CreateHMAC(hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, key: Byte[]): System.Security.Cryptography.IncrementalHash;
        AppendData(data: System.ReadOnlySpan<Byte>): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AesManaged {
        constructor();
        FeedbackSize: number;
        IV: Byte[];
        Key: Byte[];
        KeySize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        BlockSize: number;
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(key: Byte[], iv: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(key: Byte[], iv: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateIV(): void;
        GenerateKey(): void;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CngAlgorithm {
        constructor(algorithm: string);
        Algorithm: string;
        static Rsa: System.Security.Cryptography.CngAlgorithm;
        static ECDiffieHellman: System.Security.Cryptography.CngAlgorithm;
        static ECDiffieHellmanP256: System.Security.Cryptography.CngAlgorithm;
        static ECDiffieHellmanP384: System.Security.Cryptography.CngAlgorithm;
        static ECDiffieHellmanP521: System.Security.Cryptography.CngAlgorithm;
        static ECDsa: System.Security.Cryptography.CngAlgorithm;
        static ECDsaP256: System.Security.Cryptography.CngAlgorithm;
        static ECDsaP384: System.Security.Cryptography.CngAlgorithm;
        static ECDsaP521: System.Security.Cryptography.CngAlgorithm;
        static MD5: System.Security.Cryptography.CngAlgorithm;
        static Sha1: System.Security.Cryptography.CngAlgorithm;
        static Sha256: System.Security.Cryptography.CngAlgorithm;
        static Sha384: System.Security.Cryptography.CngAlgorithm;
        static Sha512: System.Security.Cryptography.CngAlgorithm;
        Equals(obj: any): boolean;
        Equals(other: System.Security.Cryptography.CngAlgorithm): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class CngAlgorithmGroup {
        constructor(algorithmGroup: string);
        AlgorithmGroup: string;
        static DiffieHellman: System.Security.Cryptography.CngAlgorithmGroup;
        static Dsa: System.Security.Cryptography.CngAlgorithmGroup;
        static ECDiffieHellman: System.Security.Cryptography.CngAlgorithmGroup;
        static ECDsa: System.Security.Cryptography.CngAlgorithmGroup;
        static Rsa: System.Security.Cryptography.CngAlgorithmGroup;
        Equals(obj: any): boolean;
        Equals(other: System.Security.Cryptography.CngAlgorithmGroup): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export enum CngKeyHandleOpenOptions {
        None = 0,
        EphemeralKey = 1,
      }
      export class CngKey {
        constructor();
        AlgorithmGroup: System.Security.Cryptography.CngAlgorithmGroup;
        Algorithm: System.Security.Cryptography.CngAlgorithm;
        ExportPolicy: System.Security.Cryptography.CngExportPolicies;
        Handle: any; // Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle
        IsEphemeral: boolean;
        IsMachineKey: boolean;
        KeyName: string;
        KeySize: number;
        KeyUsage: System.Security.Cryptography.CngKeyUsages;
        ParentWindowHandle: System.IntPtr;
        Provider: System.Security.Cryptography.CngProvider;
        ProviderHandle: any; // Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle
        UniqueName: string;
        UIPolicy: System.Security.Cryptography.CngUIPolicy;
        static Create(algorithm: System.Security.Cryptography.CngAlgorithm): System.Security.Cryptography.CngKey;
        static Create(algorithm: System.Security.Cryptography.CngAlgorithm, keyName: string): System.Security.Cryptography.CngKey;
        static Create(algorithm: System.Security.Cryptography.CngAlgorithm, keyName: string, creationParameters: System.Security.Cryptography.CngKeyCreationParameters): System.Security.Cryptography.CngKey;
        Delete(): void;
        Dispose(): void;
        static Exists(keyName: string): boolean;
        static Exists(keyName: string, provider: System.Security.Cryptography.CngProvider): boolean;
        static Exists(keyName: string, provider: System.Security.Cryptography.CngProvider, options: System.Security.Cryptography.CngKeyOpenOptions): boolean;
        static Import(keyBlob: Byte[], format: System.Security.Cryptography.CngKeyBlobFormat): System.Security.Cryptography.CngKey;
        static Import(keyBlob: Byte[], format: System.Security.Cryptography.CngKeyBlobFormat, provider: System.Security.Cryptography.CngProvider): System.Security.Cryptography.CngKey;
        Export(format: System.Security.Cryptography.CngKeyBlobFormat): Byte[];
        GetProperty(name: string, options: System.Security.Cryptography.CngPropertyOptions): System.Security.Cryptography.CngProperty;
        HasProperty(name: string, options: System.Security.Cryptography.CngPropertyOptions): boolean;
        static Open(keyName: string): System.Security.Cryptography.CngKey;
        static Open(keyName: string, provider: System.Security.Cryptography.CngProvider): System.Security.Cryptography.CngKey;
        static Open(keyName: string, provider: System.Security.Cryptography.CngProvider, openOptions: System.Security.Cryptography.CngKeyOpenOptions): System.Security.Cryptography.CngKey;
        static Open(keyHandle: any, keyHandleOpenOptions: System.Security.Cryptography.CngKeyHandleOpenOptions): System.Security.Cryptography.CngKey;
        SetProperty(property: System.Security.Cryptography.CngProperty): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CngKeyBlobFormat {
        constructor(format: string);
        Format: string;
        static EccPrivateBlob: System.Security.Cryptography.CngKeyBlobFormat;
        static EccPublicBlob: System.Security.Cryptography.CngKeyBlobFormat;
        static EccFullPrivateBlob: System.Security.Cryptography.CngKeyBlobFormat;
        static EccFullPublicBlob: System.Security.Cryptography.CngKeyBlobFormat;
        static GenericPrivateBlob: System.Security.Cryptography.CngKeyBlobFormat;
        static GenericPublicBlob: System.Security.Cryptography.CngKeyBlobFormat;
        static OpaqueTransportBlob: System.Security.Cryptography.CngKeyBlobFormat;
        static Pkcs8PrivateBlob: System.Security.Cryptography.CngKeyBlobFormat;
        Equals(obj: any): boolean;
        Equals(other: System.Security.Cryptography.CngKeyBlobFormat): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class CngKeyCreationParameters {
        constructor();
        ExportPolicy?: System.Security.Cryptography.CngExportPolicies | undefined;
        KeyCreationOptions: System.Security.Cryptography.CngKeyCreationOptions;
        KeyUsage?: System.Security.Cryptography.CngKeyUsages | undefined;
        ParentWindowHandle: System.IntPtr;
        Parameters: System.Security.Cryptography.CngProperty[];
        Provider: System.Security.Cryptography.CngProvider;
        UIPolicy: System.Security.Cryptography.CngUIPolicy;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CngProperty {
        constructor(name: string, value: Byte[], options: System.Security.Cryptography.CngPropertyOptions);
        Name: string;
        Options: System.Security.Cryptography.CngPropertyOptions;
        GetValue(): Byte[];
        Equals(obj: any): boolean;
        Equals(other: System.Security.Cryptography.CngProperty): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class CngPropertyCollection {
        constructor();
        Count: number;
        Add(item: System.Security.Cryptography.CngProperty): void;
        Clear(): void;
        CopyTo(array: System.Security.Cryptography.CngProperty[], index: number): void;
        Contains(item: System.Security.Cryptography.CngProperty): boolean;
        GetEnumerator(): System.Collections.Generic.IEnumerator<System.Security.Cryptography.CngProperty>;
        IndexOf(item: System.Security.Cryptography.CngProperty): number;
        Insert(index: number, item: System.Security.Cryptography.CngProperty): void;
        Remove(item: System.Security.Cryptography.CngProperty): boolean;
        RemoveAt(index: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CngProvider {
        constructor(provider: string);
        Provider: string;
        static MicrosoftSmartCardKeyStorageProvider: System.Security.Cryptography.CngProvider;
        static MicrosoftSoftwareKeyStorageProvider: System.Security.Cryptography.CngProvider;
        Equals(obj: any): boolean;
        Equals(other: System.Security.Cryptography.CngProvider): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class CngUIPolicy {
        constructor(protectionLevel: System.Security.Cryptography.CngUIProtectionLevels);
        constructor(protectionLevel: System.Security.Cryptography.CngUIProtectionLevels, friendlyName: string);
        constructor(protectionLevel: System.Security.Cryptography.CngUIProtectionLevels, friendlyName: string, description: string);
        constructor(protectionLevel: System.Security.Cryptography.CngUIProtectionLevels, friendlyName: string, description: string, useContext: string);
        constructor(protectionLevel: System.Security.Cryptography.CngUIProtectionLevels, friendlyName: string, description: string, useContext: string, creationTitle: string);
        CreationTitle: string;
        Description: string;
        FriendlyName: string;
        ProtectionLevel: System.Security.Cryptography.CngUIProtectionLevels;
        UseContext: string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ECDiffieHellman {
        KeyExchangeAlgorithm: string;
        SignatureAlgorithm: string;
        PublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey;
        KeySize: number;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        static Create(): System.Security.Cryptography.ECDiffieHellman;
        static Create(algorithm: string): System.Security.Cryptography.ECDiffieHellman;
        static Create(curve: System.Security.Cryptography.ECCurve): System.Security.Cryptography.ECDiffieHellman;
        static Create(parameters: System.Security.Cryptography.ECParameters): System.Security.Cryptography.ECDiffieHellman;
        DeriveKeyMaterial(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey): Byte[];
        DeriveKeyFromHash(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        DeriveKeyFromHash(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, secretPrepend: Byte[], secretAppend: Byte[]): Byte[];
        DeriveKeyFromHmac(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, hmacKey: Byte[]): Byte[];
        DeriveKeyFromHmac(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, hmacKey: Byte[], secretPrepend: Byte[], secretAppend: Byte[]): Byte[];
        DeriveKeyTls(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, prfLabel: Byte[], prfSeed: Byte[]): Byte[];
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.ECParameters;
        ExportExplicitParameters(includePrivateParameters: boolean): System.Security.Cryptography.ECParameters;
        ImportParameters(parameters: System.Security.Cryptography.ECParameters): void;
        GenerateKey(curve: System.Security.Cryptography.ECCurve): void;
        ExportECPrivateKey(): Byte[];
        Dispose(): void;
        Clear(): void;
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ECDiffieHellmanPublicKey {
        Dispose(): void;
        ToByteArray(): Byte[];
        ToXmlString(): string;
        ExportParameters(): System.Security.Cryptography.ECParameters;
        ExportExplicitParameters(): System.Security.Cryptography.ECParameters;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ECDsa {
        KeyExchangeAlgorithm: string;
        SignatureAlgorithm: string;
        KeySize: number;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        static Create(): System.Security.Cryptography.ECDsa;
        static Create(algorithm: string): System.Security.Cryptography.ECDsa;
        static Create(curve: System.Security.Cryptography.ECCurve): System.Security.Cryptography.ECDsa;
        static Create(parameters: System.Security.Cryptography.ECParameters): System.Security.Cryptography.ECDsa;
        SignHash(hash: Byte[]): Byte[];
        VerifyHash(hash: Byte[], signature: Byte[]): boolean;
        SignData(data: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: Byte[], offset: number, count: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: System.IO.Stream, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        VerifyData(data: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: Byte[], offset: number, count: number, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: System.IO.Stream, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.ECParameters;
        ExportExplicitParameters(includePrivateParameters: boolean): System.Security.Cryptography.ECParameters;
        ImportParameters(parameters: System.Security.Cryptography.ECParameters): void;
        GenerateKey(curve: System.Security.Cryptography.ECCurve): void;
        VerifyHash(hash: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>): boolean;
        VerifyData(data: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        ExportECPrivateKey(): Byte[];
        Dispose(): void;
        Clear(): void;
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ECDsaCng {
        constructor();
        constructor(keySize: number);
        constructor(key: System.Security.Cryptography.CngKey);
        constructor(curve: System.Security.Cryptography.ECCurve);
        HashAlgorithm: System.Security.Cryptography.CngAlgorithm;
        Key: System.Security.Cryptography.CngKey;
        KeyExchangeAlgorithm: string;
        SignatureAlgorithm: string;
        KeySize: number;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        SignHash(hash: Byte[]): Byte[];
        VerifyHash(hash: Byte[], signature: Byte[]): boolean;
        FromXmlString(xml: string, format: System.Security.Cryptography.ECKeyXmlFormat): void;
        SignData(data: Byte[]): Byte[];
        SignData(data: System.IO.Stream): Byte[];
        SignData(data: Byte[], offset: number, count: number): Byte[];
        ToXmlString(format: System.Security.Cryptography.ECKeyXmlFormat): string;
        VerifyData(data: Byte[], signature: Byte[]): boolean;
        VerifyData(data: System.IO.Stream, signature: Byte[]): boolean;
        VerifyData(data: Byte[], offset: number, count: number, signature: Byte[]): boolean;
        SignData(data: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: Byte[], offset: number, count: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: System.IO.Stream, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        VerifyData(data: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: Byte[], offset: number, count: number, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: System.IO.Stream, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.ECParameters;
        ExportExplicitParameters(includePrivateParameters: boolean): System.Security.Cryptography.ECParameters;
        ImportParameters(parameters: System.Security.Cryptography.ECParameters): void;
        GenerateKey(curve: System.Security.Cryptography.ECCurve): void;
        VerifyHash(hash: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>): boolean;
        VerifyData(data: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        ExportECPrivateKey(): Byte[];
        Dispose(): void;
        Clear(): void;
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum ECKeyXmlFormat {
        Rfc4050 = 0,
      }
      export enum CngExportPolicies {
        None = 0,
        AllowExport = 1,
        AllowPlaintextExport = 2,
        AllowArchiving = 4,
        AllowPlaintextArchiving = 8,
      }
      export enum CngKeyCreationOptions {
        None = 0,
        MachineKey = 32,
        OverwriteExistingKey = 128,
      }
      export enum CngKeyOpenOptions {
        None = 0,
        UserKey = 0,
        MachineKey = 32,
        Silent = 64,
      }
      export enum CngKeyUsages {
        None = 0,
        Decryption = 1,
        Signing = 2,
        KeyAgreement = 4,
        AllUsages = 16777215,
      }
      export enum CngPropertyOptions {
        None = 0,
        CustomProperty = 1073741824,
        Persist = -2147483648,
      }
      export enum CngUIProtectionLevels {
        None = 0,
        ProtectKey = 1,
        ForceHighProtection = 2,
      }
      export class RSACng {
        constructor();
        constructor(keySize: number);
        constructor(key: System.Security.Cryptography.CngKey);
        Key: System.Security.Cryptography.CngKey;
        KeyExchangeAlgorithm: string;
        SignatureAlgorithm: string;
        KeySize: number;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.RSAParameters;
        ImportParameters(parameters: System.Security.Cryptography.RSAParameters): void;
        Encrypt(data: Byte[], padding: System.Security.Cryptography.RSAEncryptionPadding): Byte[];
        Decrypt(data: Byte[], padding: System.Security.Cryptography.RSAEncryptionPadding): Byte[];
        SignHash(hash: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        VerifyHash(hash: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        SignData(data: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        SignData(data: Byte[], offset: number, count: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        SignData(data: System.IO.Stream, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): Byte[];
        VerifyData(data: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        VerifyData(data: Byte[], offset: number, count: number, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        VerifyData(data: System.IO.Stream, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        DecryptValue(rgb: Byte[]): Byte[];
        EncryptValue(rgb: Byte[]): Byte[];
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        VerifyData(data: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        VerifyHash(hash: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding): boolean;
        ExportRSAPrivateKey(): Byte[];
        ExportRSAPublicKey(): Byte[];
        Dispose(): void;
        Clear(): void;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AesCng {
        constructor();
        constructor(keyName: string);
        constructor(keyName: string, provider: System.Security.Cryptography.CngProvider);
        constructor(keyName: string, provider: System.Security.Cryptography.CngProvider, openOptions: System.Security.Cryptography.CngKeyOpenOptions);
        Key: Byte[];
        KeySize: number;
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateIV(): void;
        GenerateKey(): void;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AesCryptoServiceProvider {
        constructor();
        IV: Byte[];
        Key: Byte[];
        KeySize: number;
        FeedbackSize: number;
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        BlockSize: number;
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        GenerateIV(): void;
        GenerateKey(): void;
        CreateDecryptor(key: Byte[], iv: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(key: Byte[], iv: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class MD5Cng {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA1Cng {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA256Cng {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA256CryptoServiceProvider {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA384Cng {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA384CryptoServiceProvider {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA512Cng {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class SHA512CryptoServiceProvider {
        constructor();
        HashSize: number;
        Hash: Byte[];
        InputBlockSize: number;
        OutputBlockSize: number;
        CanTransformMultipleBlocks: boolean;
        CanReuseTransform: boolean;
        Initialize(): void;
        ComputeHash(buffer: Byte[]): Byte[];
        ComputeHash(buffer: Byte[], offset: number, count: number): Byte[];
        ComputeHash(inputStream: System.IO.Stream): Byte[];
        Dispose(): void;
        Clear(): void;
        TransformBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number, outputBuffer: Byte[], outputOffset: number): number;
        TransformFinalBlock(inputBuffer: Byte[], inputOffset: number, inputCount: number): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class TripleDESCng {
        constructor();
        constructor(keyName: string);
        constructor(keyName: string, provider: System.Security.Cryptography.CngProvider);
        constructor(keyName: string, provider: System.Security.Cryptography.CngProvider, openOptions: System.Security.Cryptography.CngKeyOpenOptions);
        Key: Byte[];
        KeySize: number;
        BlockSize: number;
        FeedbackSize: number;
        IV: Byte[];
        LegalBlockSizes: System.Security.Cryptography.KeySizes[];
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        Mode: System.Security.Cryptography.CipherMode;
        Padding: System.Security.Cryptography.PaddingMode;
        CreateDecryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateDecryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(): System.Security.Cryptography.ICryptoTransform;
        CreateEncryptor(rgbKey: Byte[], rgbIV: Byte[]): System.Security.Cryptography.ICryptoTransform;
        GenerateIV(): void;
        GenerateKey(): void;
        Dispose(): void;
        Clear(): void;
        ValidKeySize(bitLength: number): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class DSACng {
        constructor();
        constructor(keySize: number);
        constructor(key: System.Security.Cryptography.CngKey);
        Key: System.Security.Cryptography.CngKey;
        KeySize: number;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        SignatureAlgorithm: string;
        KeyExchangeAlgorithm: string;
        CreateSignature(rgbHash: Byte[]): Byte[];
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.DSAParameters;
        ImportParameters(parameters: System.Security.Cryptography.DSAParameters): void;
        VerifySignature(rgbHash: Byte[], rgbSignature: Byte[]): boolean;
        SignData(data: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: Byte[], offset: number, count: number, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        SignData(data: System.IO.Stream, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        VerifyData(data: Byte[], signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: Byte[], offset: number, count: number, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifyData(data: System.IO.Stream, signature: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        VerifyData(data: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): boolean;
        VerifySignature(hash: System.ReadOnlySpan<Byte>, signature: System.ReadOnlySpan<Byte>): boolean;
        Dispose(): void;
        Clear(): void;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ECDiffieHellmanCng {
        constructor();
        constructor(keySize: number);
        constructor(key: System.Security.Cryptography.CngKey);
        constructor(curve: System.Security.Cryptography.ECCurve);
        HashAlgorithm: System.Security.Cryptography.CngAlgorithm;
        HmacKey: Byte[];
        Key: System.Security.Cryptography.CngKey;
        KeyDerivationFunction: System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction;
        Label: Byte[];
        PublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey;
        SecretAppend: Byte[];
        SecretPrepend: Byte[];
        Seed: Byte[];
        UseSecretAgreementAsHmacKey: boolean;
        KeyExchangeAlgorithm: string;
        SignatureAlgorithm: string;
        KeySize: number;
        LegalKeySizes: System.Security.Cryptography.KeySizes[];
        DeriveKeyMaterial(otherPartyPublicKey: System.Security.Cryptography.CngKey): Byte[];
        DeriveSecretAgreementHandle(otherPartyPublicKey: System.Security.Cryptography.CngKey): any;
        DeriveSecretAgreementHandle(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey): any;
        FromXmlString(xml: string, format: System.Security.Cryptography.ECKeyXmlFormat): void;
        ToXmlString(format: System.Security.Cryptography.ECKeyXmlFormat): string;
        DeriveKeyMaterial(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey): Byte[];
        DeriveKeyFromHash(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
        DeriveKeyFromHash(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, secretPrepend: Byte[], secretAppend: Byte[]): Byte[];
        DeriveKeyFromHmac(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, hmacKey: Byte[]): Byte[];
        DeriveKeyFromHmac(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, hmacKey: Byte[], secretPrepend: Byte[], secretAppend: Byte[]): Byte[];
        DeriveKeyTls(otherPartyPublicKey: System.Security.Cryptography.ECDiffieHellmanPublicKey, prfLabel: Byte[], prfSeed: Byte[]): Byte[];
        ExportParameters(includePrivateParameters: boolean): System.Security.Cryptography.ECParameters;
        ExportExplicitParameters(includePrivateParameters: boolean): System.Security.Cryptography.ECParameters;
        ImportParameters(parameters: System.Security.Cryptography.ECParameters): void;
        GenerateKey(curve: System.Security.Cryptography.ECCurve): void;
        ExportECPrivateKey(): Byte[];
        Dispose(): void;
        Clear(): void;
        FromXmlString(xmlString: string): void;
        ToXmlString(includePrivateParameters: boolean): string;
        ExportEncryptedPkcs8PrivateKey(passwordBytes: System.ReadOnlySpan<Byte>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportEncryptedPkcs8PrivateKey(password: System.ReadOnlySpan<System.Char>, pbeParameters: System.Security.Cryptography.PbeParameters): Byte[];
        ExportPkcs8PrivateKey(): Byte[];
        ExportSubjectPublicKeyInfo(): Byte[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum ECDiffieHellmanKeyDerivationFunction {
        Hash = 0,
        Hmac = 1,
        Tls = 2,
      }
      export class ECDiffieHellmanCngPublicKey {
        BlobFormat: System.Security.Cryptography.CngKeyBlobFormat;
        static FromByteArray(publicKeyBlob: Byte[], format: System.Security.Cryptography.CngKeyBlobFormat): System.Security.Cryptography.ECDiffieHellmanPublicKey;
        static FromXmlString(xml: string): System.Security.Cryptography.ECDiffieHellmanCngPublicKey;
        Import(): System.Security.Cryptography.CngKey;
        Dispose(): void;
        ToByteArray(): Byte[];
        ToXmlString(): string;
        ExportParameters(): System.Security.Cryptography.ECParameters;
        ExportExplicitParameters(): System.Security.Cryptography.ECParameters;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ManifestSignatureInformation {
        AuthenticodeSignature: System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation;
        Manifest: System.Security.ManifestKinds;
        StrongNameSignature: System.Security.Cryptography.StrongNameSignatureInformation;
        static VerifySignature(application: System.ActivationContext): System.Security.Cryptography.ManifestSignatureInformation[];
        static VerifySignature(application: System.ActivationContext, manifests: System.Security.ManifestKinds): System.Security.Cryptography.ManifestSignatureInformation[];
        static VerifySignature(application: System.ActivationContext, manifests: System.Security.ManifestKinds, revocationFlag: System.Security.Cryptography.X509Certificates.X509RevocationFlag, revocationMode: System.Security.Cryptography.X509Certificates.X509RevocationMode): System.Security.Cryptography.ManifestSignatureInformation[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum SignatureVerificationResult {
        AssemblyIdentityMismatch = 1,
        BadDigest = -2146869232,
        BadSignatureFormat = -2146762749,
        BasicConstraintsNotObserved = -2146869223,
        CertificateExpired = -2146762495,
        CertificateExplicitlyDistrusted = -2146762479,
        CertificateMalformed = -2146762488,
        CertificateNotExplicitlyTrusted = -2146762748,
        CertificateRevoked = -2146762484,
        CertificateUsageNotAllowed = -2146762490,
        ContainingSignatureInvalid = 2,
        CouldNotBuildChain = -2146762486,
        GenericTrustFailure = -2146762485,
        InvalidCertificateName = -2146762476,
        InvalidCertificatePolicy = -2146762477,
        InvalidCertificateRole = -2146762493,
        InvalidCertificateSignature = -2146869244,
        InvalidCertificateUsage = -2146762480,
        InvalidCountersignature = -2146869245,
        InvalidSignerCertificate = -2146869246,
        InvalidTimePeriodNesting = -2146762494,
        InvalidTimestamp = -2146869243,
        IssuerChainingError = -2146762489,
        MissingSignature = -2146762496,
        PathLengthConstraintViolated = -2146762492,
        PublicKeyTokenMismatch = 3,
        PublisherMismatch = 4,
        RevocationCheckFailure = -2146762482,
        SystemError = -2146869247,
        UnknownCriticalExtension = -2146762491,
        UnknownTrustProvider = -2146762751,
        UnknownVerificationAction = -2146762750,
        UntrustedCertificationAuthority = -2146762478,
        UntrustedRootCertificate = -2146762487,
        UntrustedTestRootCertificate = -2146762483,
        Valid = 0,
      }
      export class StrongNameSignatureInformation {
        HashAlgorithm: string;
        HResult: number;
        IsValid: boolean;
        PublicKey: System.Security.Cryptography.AsymmetricAlgorithm;
        VerificationResult: System.Security.Cryptography.SignatureVerificationResult;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ManifestSignatureInformationCollection {
        Count: number;
        Contains(value: System.Security.Cryptography.ManifestSignatureInformation): boolean;
        CopyTo(array: System.Security.Cryptography.ManifestSignatureInformation[], index: number): void;
        GetEnumerator(): System.Collections.Generic.IEnumerator<System.Security.Cryptography.ManifestSignatureInformation>;
        IndexOf(value: System.Security.Cryptography.ManifestSignatureInformation): number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AsnEncodedDataCollection {
        constructor();
        constructor(asnEncodedData: System.Security.Cryptography.AsnEncodedData);
        Count: number;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        Add(asnEncodedData: System.Security.Cryptography.AsnEncodedData): number;
        Remove(asnEncodedData: System.Security.Cryptography.AsnEncodedData): void;
        GetEnumerator(): System.Security.Cryptography.AsnEncodedDataEnumerator;
        CopyTo(array: System.Security.Cryptography.AsnEncodedData[], index: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class AsnEncodedDataEnumerator {
        Current: System.Security.Cryptography.AsnEncodedData;
        MoveNext(): boolean;
        Reset(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Oid {
        constructor();
        constructor(oid: string);
        constructor(value: string, friendlyName: string);
        constructor(oid: System.Security.Cryptography.Oid);
        Value: string;
        FriendlyName: string;
        static FromFriendlyName(friendlyName: string, group: System.Security.Cryptography.OidGroup): System.Security.Cryptography.Oid;
        static FromOidValue(oidValue: string, group: System.Security.Cryptography.OidGroup): System.Security.Cryptography.Oid;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class OidCollection {
        constructor();
        Count: number;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        Add(oid: System.Security.Cryptography.Oid): number;
        GetEnumerator(): System.Security.Cryptography.OidEnumerator;
        CopyTo(array: System.Security.Cryptography.Oid[], index: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class OidEnumerator {
        Current: System.Security.Cryptography.Oid;
        MoveNext(): boolean;
        Reset(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum OidGroup {
        All = 0,
        HashAlgorithm = 1,
        EncryptionAlgorithm = 2,
        PublicKeyAlgorithm = 3,
        SignatureAlgorithm = 4,
        Attribute = 5,
        ExtensionOrAttribute = 6,
        EnhancedKeyUsage = 7,
        Policy = 8,
        Template = 9,
        KeyDerivationFunction = 10,
      }
      export class AsnEncodedData {
        constructor(oid: string, rawData: Byte[]);
        constructor(oid: System.Security.Cryptography.Oid, rawData: Byte[]);
        constructor(asnEncodedData: System.Security.Cryptography.AsnEncodedData);
        constructor(rawData: Byte[]);
        Oid: System.Security.Cryptography.Oid;
        RawData: Byte[];
        CopyFrom(asnEncodedData: System.Security.Cryptography.AsnEncodedData): void;
        Format(multiLine: boolean): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export namespace X509Certificates {
        export enum X509ContentType {
          Unknown = 0,
          Cert = 1,
          SerializedCert = 2,
          Pfx = 3,
          Pkcs12 = 3,
          SerializedStore = 4,
          Pkcs7 = 5,
          Authenticode = 6,
        }
        export enum X509KeyStorageFlags {
          DefaultKeySet = 0,
          UserKeySet = 1,
          MachineKeySet = 2,
          Exportable = 4,
          UserProtected = 8,
          PersistKeySet = 16,
          EphemeralKeySet = 32,
        }
        export class X509Certificate {
          constructor();
          constructor(data: Byte[]);
          constructor(rawData: Byte[], password: string);
          constructor(rawData: Byte[], password: System.Security.SecureString);
          constructor(rawData: Byte[], password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags);
          constructor(rawData: Byte[], password: System.Security.SecureString, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags);
          constructor(handle: System.IntPtr);
          constructor(fileName: string);
          constructor(fileName: string, password: string);
          constructor(fileName: string, password: System.Security.SecureString);
          constructor(fileName: string, password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags);
          constructor(fileName: string, password: System.Security.SecureString, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags);
          constructor(cert: System.Security.Cryptography.X509Certificates.X509Certificate);
          constructor(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext);
          Handle: System.IntPtr;
          Issuer: string;
          Subject: string;
          Reset(): void;
          static CreateFromCertFile(filename: string): System.Security.Cryptography.X509Certificates.X509Certificate;
          static CreateFromSignedFile(filename: string): System.Security.Cryptography.X509Certificates.X509Certificate;
          Dispose(): void;
          Equals(obj: any): boolean;
          Equals(other: System.Security.Cryptography.X509Certificates.X509Certificate): boolean;
          Export(contentType: System.Security.Cryptography.X509Certificates.X509ContentType): Byte[];
          Export(contentType: System.Security.Cryptography.X509Certificates.X509ContentType, password: string): Byte[];
          Export(contentType: System.Security.Cryptography.X509Certificates.X509ContentType, password: System.Security.SecureString): Byte[];
          GetRawCertDataString(): string;
          GetCertHash(): Byte[];
          GetCertHash(hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
          GetCertHashString(): string;
          GetCertHashString(hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): string;
          GetEffectiveDateString(): string;
          GetExpirationDateString(): string;
          GetFormat(): string;
          GetPublicKeyString(): string;
          GetRawCertData(): Byte[];
          GetHashCode(): number;
          GetKeyAlgorithm(): string;
          GetKeyAlgorithmParameters(): Byte[];
          GetKeyAlgorithmParametersString(): string;
          GetPublicKey(): Byte[];
          GetSerialNumber(): Byte[];
          GetSerialNumberString(): string;
          GetName(): string;
          GetIssuerName(): string;
          ToString(): string;
          ToString(fVerbose: boolean): string;
          Import(rawData: Byte[]): void;
          Import(rawData: Byte[], password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          Import(rawData: Byte[], password: System.Security.SecureString, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          Import(fileName: string): void;
          Import(fileName: string, password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          Import(fileName: string, password: System.Security.SecureString, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          GetType(): System.Type;
        }
        export enum TrustStatus {
          Untrusted = 0,
          UnknownIdentity = 1,
          KnownIdentity = 2,
          Trusted = 3,
        }
        export class DSACertificateExtensions {
          static GetDSAPublicKey(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): System.Security.Cryptography.DSA;
          static GetDSAPrivateKey(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): System.Security.Cryptography.DSA;
          static CopyWithPrivateKey(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2, privateKey: System.Security.Cryptography.DSA): System.Security.Cryptography.X509Certificates.X509Certificate2;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class ECDsaCertificateExtensions {
          static GetECDsaPrivateKey(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): System.Security.Cryptography.ECDsa;
          static GetECDsaPublicKey(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): System.Security.Cryptography.ECDsa;
          static CopyWithPrivateKey(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2, privateKey: System.Security.Cryptography.ECDsa): System.Security.Cryptography.X509Certificates.X509Certificate2;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class RSACertificateExtensions {
          static GetRSAPrivateKey(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): System.Security.Cryptography.RSA;
          static GetRSAPublicKey(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): System.Security.Cryptography.RSA;
          static CopyWithPrivateKey(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2, privateKey: System.Security.Cryptography.RSA): System.Security.Cryptography.X509Certificates.X509Certificate2;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class AuthenticodeSignatureInformation {
          Description: string;
          DescriptionUrl: System.Uri;
          HashAlgorithm: string;
          HResult: number;
          SignatureChain: System.Security.Cryptography.X509Certificates.X509Chain;
          SigningCertificate: System.Security.Cryptography.X509Certificates.X509Certificate2;
          Timestamp: System.Security.Cryptography.X509Certificates.TimestampInformation;
          TrustStatus: System.Security.Cryptography.X509Certificates.TrustStatus;
          VerificationResult: System.Security.Cryptography.SignatureVerificationResult;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class TimestampInformation {
          HashAlgorithm: string;
          HResult: number;
          IsValid: boolean;
          SignatureChain: System.Security.Cryptography.X509Certificates.X509Chain;
          SigningCertificate: System.Security.Cryptography.X509Certificates.X509Certificate2;
          Timestamp: System.DateTime;
          VerificationResult: System.Security.Cryptography.SignatureVerificationResult;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export enum OpenFlags {
          ReadOnly = 0,
          ReadWrite = 1,
          MaxAllowed = 2,
          OpenExistingOnly = 4,
          IncludeArchived = 8,
        }
        export enum StoreLocation {
          CurrentUser = 1,
          LocalMachine = 2,
        }
        export enum StoreName {
          AddressBook = 1,
          AuthRoot = 2,
          CertificateAuthority = 3,
          Disallowed = 4,
          My = 5,
          Root = 6,
          TrustedPeople = 7,
          TrustedPublisher = 8,
        }
        export class SubjectAlternativeNameBuilder {
          constructor();
          AddEmailAddress(emailAddress: string): void;
          AddDnsName(dnsName: string): void;
          AddUri(uri: System.Uri): void;
          AddIpAddress(ipAddress: any): void;
          AddUserPrincipalName(upn: string): void;
          Build(critical?: boolean): System.Security.Cryptography.X509Certificates.X509Extension;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export enum X500DistinguishedNameFlags {
          None = 0,
          Reversed = 1,
          UseSemicolons = 16,
          DoNotUsePlusSign = 32,
          DoNotUseQuotes = 64,
          UseCommas = 128,
          UseNewLines = 256,
          UseUTF8Encoding = 4096,
          UseT61Encoding = 8192,
          ForceUTF8Encoding = 16384,
        }
        export enum X509ChainStatusFlags {
          NoError = 0,
          NotTimeValid = 1,
          NotTimeNested = 2,
          Revoked = 4,
          NotSignatureValid = 8,
          NotValidForUsage = 16,
          UntrustedRoot = 32,
          RevocationStatusUnknown = 64,
          Cyclic = 128,
          InvalidExtension = 256,
          InvalidPolicyConstraints = 512,
          InvalidBasicConstraints = 1024,
          InvalidNameConstraints = 2048,
          HasNotSupportedNameConstraint = 4096,
          HasNotDefinedNameConstraint = 8192,
          HasNotPermittedNameConstraint = 16384,
          HasExcludedNameConstraint = 32768,
          PartialChain = 65536,
          CtlNotTimeValid = 131072,
          CtlNotSignatureValid = 262144,
          CtlNotValidForUsage = 524288,
          OfflineRevocation = 16777216,
          NoIssuanceChainPolicy = 33554432,
          ExplicitDistrust = 67108864,
          HasNotSupportedCriticalExtension = 134217728,
          HasWeakSignature = 1048576,
        }
        export enum X509FindType {
          FindByThumbprint = 0,
          FindBySubjectName = 1,
          FindBySubjectDistinguishedName = 2,
          FindByIssuerName = 3,
          FindByIssuerDistinguishedName = 4,
          FindBySerialNumber = 5,
          FindByTimeValid = 6,
          FindByTimeNotYetValid = 7,
          FindByTimeExpired = 8,
          FindByTemplateName = 9,
          FindByApplicationPolicy = 10,
          FindByCertificatePolicy = 11,
          FindByExtension = 12,
          FindByKeyUsage = 13,
          FindBySubjectKeyIdentifier = 14,
        }
        export enum X509IncludeOption {
          None = 0,
          ExcludeRoot = 1,
          EndCertOnly = 2,
          WholeChain = 3,
        }
        export enum X509KeyUsageFlags {
          None = 0,
          EncipherOnly = 1,
          CrlSign = 2,
          KeyCertSign = 4,
          KeyAgreement = 8,
          DataEncipherment = 16,
          KeyEncipherment = 32,
          NonRepudiation = 64,
          DigitalSignature = 128,
          DecipherOnly = 32768,
        }
        export enum X509NameType {
          SimpleName = 0,
          EmailName = 1,
          UpnName = 2,
          DnsName = 3,
          DnsFromAlternativeName = 4,
          UrlName = 5,
        }
        export enum X509RevocationFlag {
          EndCertificateOnly = 0,
          EntireChain = 1,
          ExcludeRoot = 2,
        }
        export enum X509RevocationMode {
          NoCheck = 0,
          Online = 1,
          Offline = 2,
        }
        export enum X509SubjectKeyIdentifierHashAlgorithm {
          Sha1 = 0,
          ShortSha1 = 1,
          CapiSha1 = 2,
        }
        export enum X509VerificationFlags {
          NoFlag = 0,
          IgnoreNotTimeValid = 1,
          IgnoreCtlNotTimeValid = 2,
          IgnoreNotTimeNested = 4,
          IgnoreInvalidBasicConstraints = 8,
          AllowUnknownCertificateAuthority = 16,
          IgnoreWrongUsage = 32,
          IgnoreInvalidName = 64,
          IgnoreInvalidPolicy = 128,
          IgnoreEndRevocationUnknown = 256,
          IgnoreCtlSignerRevocationUnknown = 512,
          IgnoreCertificateAuthorityRevocationUnknown = 1024,
          IgnoreRootRevocationUnknown = 2048,
          AllFlags = 4095,
        }
        export class PublicKey {
          constructor(oid: System.Security.Cryptography.Oid, parameters: System.Security.Cryptography.AsnEncodedData, keyValue: System.Security.Cryptography.AsnEncodedData);
          EncodedKeyValue: System.Security.Cryptography.AsnEncodedData;
          EncodedParameters: System.Security.Cryptography.AsnEncodedData;
          Key: System.Security.Cryptography.AsymmetricAlgorithm;
          Oid: System.Security.Cryptography.Oid;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X500DistinguishedName {
          constructor(encodedDistinguishedName: System.Security.Cryptography.AsnEncodedData);
          constructor(encodedDistinguishedName: Byte[]);
          constructor(distinguishedName: string);
          constructor(distinguishedName: string, flag: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags);
          constructor(distinguishedName: System.Security.Cryptography.X509Certificates.X500DistinguishedName);
          Name: string;
          Oid: System.Security.Cryptography.Oid;
          RawData: Byte[];
          Decode(flag: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags): string;
          Format(multiLine: boolean): string;
          CopyFrom(asnEncodedData: System.Security.Cryptography.AsnEncodedData): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509BasicConstraintsExtension {
          constructor();
          constructor(encodedBasicConstraints: System.Security.Cryptography.AsnEncodedData, critical: boolean);
          constructor(certificateAuthority: boolean, hasPathLengthConstraint: boolean, pathLengthConstraint: number, critical: boolean);
          CertificateAuthority: boolean;
          HasPathLengthConstraint: boolean;
          PathLengthConstraint: number;
          Critical: boolean;
          Oid: System.Security.Cryptography.Oid;
          RawData: Byte[];
          CopyFrom(asnEncodedData: System.Security.Cryptography.AsnEncodedData): void;
          Format(multiLine: boolean): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509Certificate2 {
          constructor();
          constructor(rawData: Byte[]);
          constructor(rawData: Byte[], password: string);
          constructor(rawData: Byte[], password: System.Security.SecureString);
          constructor(rawData: Byte[], password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags);
          constructor(rawData: Byte[], password: System.Security.SecureString, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags);
          constructor(handle: System.IntPtr);
          constructor(fileName: string);
          constructor(fileName: string, password: string);
          constructor(fileName: string, password: System.Security.SecureString);
          constructor(fileName: string, password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags);
          constructor(fileName: string, password: System.Security.SecureString, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags);
          constructor(certificate: System.Security.Cryptography.X509Certificates.X509Certificate);
          Archived: boolean;
          Extensions: System.Security.Cryptography.X509Certificates.X509ExtensionCollection;
          FriendlyName: string;
          HasPrivateKey: boolean;
          PrivateKey: System.Security.Cryptography.AsymmetricAlgorithm;
          IssuerName: System.Security.Cryptography.X509Certificates.X500DistinguishedName;
          NotAfter: System.DateTime;
          NotBefore: System.DateTime;
          PublicKey: System.Security.Cryptography.X509Certificates.PublicKey;
          RawData: Byte[];
          SerialNumber: string;
          SignatureAlgorithm: System.Security.Cryptography.Oid;
          SubjectName: System.Security.Cryptography.X509Certificates.X500DistinguishedName;
          Thumbprint: string;
          Version: number;
          Handle: System.IntPtr;
          Issuer: string;
          Subject: string;
          Reset(): void;
          static GetCertContentType(rawData: Byte[]): System.Security.Cryptography.X509Certificates.X509ContentType;
          static GetCertContentType(fileName: string): System.Security.Cryptography.X509Certificates.X509ContentType;
          GetNameInfo(nameType: System.Security.Cryptography.X509Certificates.X509NameType, forIssuer: boolean): string;
          ToString(): string;
          ToString(verbose: boolean): string;
          Import(rawData: Byte[]): void;
          Import(rawData: Byte[], password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          Import(rawData: Byte[], password: System.Security.SecureString, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          Import(fileName: string): void;
          Import(fileName: string, password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          Import(fileName: string, password: System.Security.SecureString, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          Verify(): boolean;
          Dispose(): void;
          Equals(obj: any): boolean;
          Equals(other: System.Security.Cryptography.X509Certificates.X509Certificate): boolean;
          Export(contentType: System.Security.Cryptography.X509Certificates.X509ContentType): Byte[];
          Export(contentType: System.Security.Cryptography.X509Certificates.X509ContentType, password: string): Byte[];
          Export(contentType: System.Security.Cryptography.X509Certificates.X509ContentType, password: System.Security.SecureString): Byte[];
          GetRawCertDataString(): string;
          GetCertHash(): Byte[];
          GetCertHash(hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
          GetCertHashString(): string;
          GetCertHashString(hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): string;
          GetEffectiveDateString(): string;
          GetExpirationDateString(): string;
          GetFormat(): string;
          GetPublicKeyString(): string;
          GetRawCertData(): Byte[];
          GetHashCode(): number;
          GetKeyAlgorithm(): string;
          GetKeyAlgorithmParameters(): Byte[];
          GetKeyAlgorithmParametersString(): string;
          GetPublicKey(): Byte[];
          GetSerialNumber(): Byte[];
          GetSerialNumberString(): string;
          GetName(): string;
          GetIssuerName(): string;
          GetType(): System.Type;
        }
        export class X509Certificate2Collection {
          constructor();
          constructor(certificates: System.Security.Cryptography.X509Certificates.X509Certificate2Collection);
          constructor(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2);
          constructor(certificates: System.Security.Cryptography.X509Certificates.X509Certificate2[]);
          Capacity: number;
          Count: number;
          Add(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): number;
          AddRange(certificates: System.Security.Cryptography.X509Certificates.X509Certificate2[]): void;
          AddRange(certificates: System.Security.Cryptography.X509Certificates.X509Certificate2Collection): void;
          Contains(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): boolean;
          Export(contentType: System.Security.Cryptography.X509Certificates.X509ContentType): Byte[];
          Export(contentType: System.Security.Cryptography.X509Certificates.X509ContentType, password: string): Byte[];
          Find(findType: System.Security.Cryptography.X509Certificates.X509FindType, findValue: any, validOnly: boolean): System.Security.Cryptography.X509Certificates.X509Certificate2Collection;
          GetEnumerator(): System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator;
          Import(rawData: Byte[]): void;
          Import(rawData: Byte[], password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          Import(fileName: string): void;
          Import(fileName: string, password: string, keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags): void;
          Insert(index: number, certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): void;
          Remove(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): void;
          RemoveRange(certificates: System.Security.Cryptography.X509Certificates.X509Certificate2[]): void;
          RemoveRange(certificates: System.Security.Cryptography.X509Certificates.X509Certificate2Collection): void;
          Add(value: System.Security.Cryptography.X509Certificates.X509Certificate): number;
          AddRange(value: System.Security.Cryptography.X509Certificates.X509Certificate[]): void;
          AddRange(value: System.Security.Cryptography.X509Certificates.X509CertificateCollection): void;
          Contains(value: System.Security.Cryptography.X509Certificates.X509Certificate): boolean;
          CopyTo(array: System.Security.Cryptography.X509Certificates.X509Certificate[], index: number): void;
          GetEnumerator(): System.Security.Cryptography.X509Certificates.X509CertificateCollection_X509CertificateEnumerator;
          GetHashCode(): number;
          IndexOf(value: System.Security.Cryptography.X509Certificates.X509Certificate): number;
          Insert(index: number, value: System.Security.Cryptography.X509Certificates.X509Certificate): void;
          Remove(value: System.Security.Cryptography.X509Certificates.X509Certificate): void;
          Clear(): void;
          RemoveAt(index: number): void;
          GetEnumerator(): System.Collections.IEnumerator;
          Equals(obj: any): boolean;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509Certificate2Enumerator {
          Current: System.Security.Cryptography.X509Certificates.X509Certificate2;
          MoveNext(): boolean;
          Reset(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509CertificateCollection {
          constructor();
          constructor(value: System.Security.Cryptography.X509Certificates.X509Certificate[]);
          constructor(value: System.Security.Cryptography.X509Certificates.X509CertificateCollection);
          Capacity: number;
          Count: number;
          Add(value: System.Security.Cryptography.X509Certificates.X509Certificate): number;
          AddRange(value: System.Security.Cryptography.X509Certificates.X509Certificate[]): void;
          AddRange(value: System.Security.Cryptography.X509Certificates.X509CertificateCollection): void;
          Contains(value: System.Security.Cryptography.X509Certificates.X509Certificate): boolean;
          CopyTo(array: System.Security.Cryptography.X509Certificates.X509Certificate[], index: number): void;
          GetEnumerator(): System.Security.Cryptography.X509Certificates.X509CertificateCollection_X509CertificateEnumerator;
          GetHashCode(): number;
          IndexOf(value: System.Security.Cryptography.X509Certificates.X509Certificate): number;
          Insert(index: number, value: System.Security.Cryptography.X509Certificates.X509Certificate): void;
          Remove(value: System.Security.Cryptography.X509Certificates.X509Certificate): void;
          Clear(): void;
          RemoveAt(index: number): void;
          GetEnumerator(): System.Collections.IEnumerator;
          Equals(obj: any): boolean;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509CertificateCollection_X509CertificateEnumerator {
          constructor(mappings: System.Security.Cryptography.X509Certificates.X509CertificateCollection);
          Current: System.Security.Cryptography.X509Certificates.X509Certificate;
          MoveNext(): boolean;
          Reset(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509Chain {
          constructor();
          constructor(useMachineContext: boolean);
          constructor(chainContext: System.IntPtr);
          ChainContext: System.IntPtr;
          ChainElements: System.Security.Cryptography.X509Certificates.X509ChainElementCollection;
          ChainPolicy: System.Security.Cryptography.X509Certificates.X509ChainPolicy;
          ChainStatus: System.Security.Cryptography.X509Certificates.X509ChainStatus[];
          SafeHandle: any; // Microsoft.Win32.SafeHandles.SafeX509ChainHandle
          Build(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): boolean;
          Reset(): void;
          static Create(): System.Security.Cryptography.X509Certificates.X509Chain;
          Dispose(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509ChainElement {
          Certificate: System.Security.Cryptography.X509Certificates.X509Certificate2;
          ChainElementStatus: System.Security.Cryptography.X509Certificates.X509ChainStatus[];
          Information: string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509ChainElementCollection {
          Count: number;
          IsSynchronized: boolean;
          SyncRoot: any; // System.Object
          CopyTo(array: System.Security.Cryptography.X509Certificates.X509ChainElement[], index: number): void;
          GetEnumerator(): System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509ChainElementEnumerator {
          Current: System.Security.Cryptography.X509Certificates.X509ChainElement;
          MoveNext(): boolean;
          Reset(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509ChainPolicy {
          constructor();
          ApplicationPolicy: System.Security.Cryptography.OidCollection;
          CertificatePolicy: System.Security.Cryptography.OidCollection;
          ExtraStore: System.Security.Cryptography.X509Certificates.X509Certificate2Collection;
          RevocationFlag: System.Security.Cryptography.X509Certificates.X509RevocationFlag;
          RevocationMode: System.Security.Cryptography.X509Certificates.X509RevocationMode;
          UrlRetrievalTimeout: System.TimeSpan;
          VerificationFlags: System.Security.Cryptography.X509Certificates.X509VerificationFlags;
          VerificationTime: System.DateTime;
          Reset(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509ChainStatus {
          Status: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags;
          StatusInformation: string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
        export class X509EnhancedKeyUsageExtension {
          constructor();
          constructor(encodedEnhancedKeyUsages: System.Security.Cryptography.AsnEncodedData, critical: boolean);
          constructor(enhancedKeyUsages: System.Security.Cryptography.OidCollection, critical: boolean);
          EnhancedKeyUsages: System.Security.Cryptography.OidCollection;
          Critical: boolean;
          Oid: System.Security.Cryptography.Oid;
          RawData: Byte[];
          CopyFrom(asnEncodedData: System.Security.Cryptography.AsnEncodedData): void;
          Format(multiLine: boolean): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509Extension {
          constructor(encodedExtension: System.Security.Cryptography.AsnEncodedData, critical: boolean);
          constructor(oid: System.Security.Cryptography.Oid, rawData: Byte[], critical: boolean);
          constructor(oid: string, rawData: Byte[], critical: boolean);
          Critical: boolean;
          Oid: System.Security.Cryptography.Oid;
          RawData: Byte[];
          CopyFrom(asnEncodedData: System.Security.Cryptography.AsnEncodedData): void;
          Format(multiLine: boolean): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509ExtensionCollection {
          constructor();
          Count: number;
          IsSynchronized: boolean;
          SyncRoot: any; // System.Object
          Add(extension: System.Security.Cryptography.X509Certificates.X509Extension): number;
          CopyTo(array: System.Security.Cryptography.X509Certificates.X509Extension[], index: number): void;
          GetEnumerator(): System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509ExtensionEnumerator {
          Current: System.Security.Cryptography.X509Certificates.X509Extension;
          MoveNext(): boolean;
          Reset(): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509KeyUsageExtension {
          constructor();
          constructor(encodedKeyUsage: System.Security.Cryptography.AsnEncodedData, critical: boolean);
          constructor(keyUsages: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags, critical: boolean);
          KeyUsages: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags;
          Critical: boolean;
          Oid: System.Security.Cryptography.Oid;
          RawData: Byte[];
          CopyFrom(asnEncodedData: System.Security.Cryptography.AsnEncodedData): void;
          Format(multiLine: boolean): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509Store {
          constructor();
          constructor(storeName: string);
          constructor(storeName: System.Security.Cryptography.X509Certificates.StoreName);
          constructor(storeLocation: System.Security.Cryptography.X509Certificates.StoreLocation);
          constructor(storeName: System.Security.Cryptography.X509Certificates.StoreName, storeLocation: System.Security.Cryptography.X509Certificates.StoreLocation);
          constructor(storeName: System.Security.Cryptography.X509Certificates.StoreName, storeLocation: System.Security.Cryptography.X509Certificates.StoreLocation, openFlags: System.Security.Cryptography.X509Certificates.OpenFlags);
          constructor(storeName: string, storeLocation: System.Security.Cryptography.X509Certificates.StoreLocation, openFlags: System.Security.Cryptography.X509Certificates.OpenFlags);
          constructor(storeHandle: System.IntPtr);
          constructor(storeName: string, storeLocation: System.Security.Cryptography.X509Certificates.StoreLocation);
          Certificates: System.Security.Cryptography.X509Certificates.X509Certificate2Collection;
          Location: System.Security.Cryptography.X509Certificates.StoreLocation;
          Name: string;
          IsOpen: boolean;
          StoreHandle: System.IntPtr;
          Add(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): void;
          AddRange(certificates: System.Security.Cryptography.X509Certificates.X509Certificate2Collection): void;
          Close(): void;
          Dispose(): void;
          Open(flags: System.Security.Cryptography.X509Certificates.OpenFlags): void;
          Remove(certificate: System.Security.Cryptography.X509Certificates.X509Certificate2): void;
          RemoveRange(certificates: System.Security.Cryptography.X509Certificates.X509Certificate2Collection): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509SubjectKeyIdentifierExtension {
          constructor();
          constructor(encodedSubjectKeyIdentifier: System.Security.Cryptography.AsnEncodedData, critical: boolean);
          constructor(subjectKeyIdentifier: Byte[], critical: boolean);
          constructor(subjectKeyIdentifier: string, critical: boolean);
          constructor(key: System.Security.Cryptography.X509Certificates.PublicKey, critical: boolean);
          constructor(key: System.Security.Cryptography.X509Certificates.PublicKey, algorithm: System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm, critical: boolean);
          SubjectKeyIdentifier: string;
          Critical: boolean;
          Oid: System.Security.Cryptography.Oid;
          RawData: Byte[];
          CopyFrom(asnEncodedData: System.Security.Cryptography.AsnEncodedData): void;
          Format(multiLine: boolean): string;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class CertificateRequest {
          constructor(subjectName: System.Security.Cryptography.X509Certificates.X500DistinguishedName, key: System.Security.Cryptography.ECDsa, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName);
          constructor(subjectName: System.Security.Cryptography.X509Certificates.X500DistinguishedName, key: System.Security.Cryptography.RSA, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding);
          constructor(subjectName: System.Security.Cryptography.X509Certificates.X500DistinguishedName, publicKey: System.Security.Cryptography.X509Certificates.PublicKey, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName);
          constructor(subjectName: string, key: System.Security.Cryptography.ECDsa, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName);
          constructor(subjectName: string, key: System.Security.Cryptography.RSA, hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, padding: System.Security.Cryptography.RSASignaturePadding);
          CertificateExtensions: System.Security.Cryptography.X509Certificates.X509Extension[];
          HashAlgorithm: System.Security.Cryptography.HashAlgorithmName;
          PublicKey: System.Security.Cryptography.X509Certificates.PublicKey;
          SubjectName: System.Security.Cryptography.X509Certificates.X500DistinguishedName;
          Create(issuerName: System.Security.Cryptography.X509Certificates.X500DistinguishedName, generator: System.Security.Cryptography.X509Certificates.X509SignatureGenerator, notBefore: System.DateTimeOffset, notAfter: System.DateTimeOffset, serialNumber: Byte[]): System.Security.Cryptography.X509Certificates.X509Certificate2;
          Create(issuerCertificate: System.Security.Cryptography.X509Certificates.X509Certificate2, notBefore: System.DateTimeOffset, notAfter: System.DateTimeOffset, serialNumber: Byte[]): System.Security.Cryptography.X509Certificates.X509Certificate2;
          CreateSelfSigned(notBefore: System.DateTimeOffset, notAfter: System.DateTimeOffset): System.Security.Cryptography.X509Certificates.X509Certificate2;
          CreateSigningRequest(): Byte[];
          CreateSigningRequest(signatureGenerator: System.Security.Cryptography.X509Certificates.X509SignatureGenerator): Byte[];
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
        export class X509SignatureGenerator {
          PublicKey: System.Security.Cryptography.X509Certificates.PublicKey;
          static CreateForECDsa(key: System.Security.Cryptography.ECDsa): System.Security.Cryptography.X509Certificates.X509SignatureGenerator;
          static CreateForRSA(key: System.Security.Cryptography.RSA, signaturePadding: System.Security.Cryptography.RSASignaturePadding): System.Security.Cryptography.X509Certificates.X509SignatureGenerator;
          GetSignatureAlgorithmIdentifier(hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
          SignData(data: Byte[], hashAlgorithm: System.Security.Cryptography.HashAlgorithmName): Byte[];
          Equals(obj: any): boolean;
          GetHashCode(): number;
          GetType(): System.Type;
          ToString(): string;
        }
      }
    }
    export namespace Permissions {
      export enum FileDialogPermissionAccess {
        None = 0,
        Open = 1,
        OpenSave = 3,
        Save = 2,
      }
      export enum HostProtectionResource {
        All = 511,
        ExternalProcessMgmt = 4,
        ExternalThreading = 16,
        MayLeakOnAbort = 256,
        None = 0,
        SecurityInfrastructure = 64,
        SelfAffectingProcessMgmt = 8,
        SelfAffectingThreading = 32,
        SharedState = 2,
        Synchronization = 1,
        UI = 128,
      }
      export interface IUnrestrictedPermission {
        IsUnrestricted(): boolean;
      }
      export enum IsolatedStorageContainment {
        None = 0,
        DomainIsolationByUser = 16,
        ApplicationIsolationByUser = 21,
        AssemblyIsolationByUser = 32,
        DomainIsolationByMachine = 48,
        AssemblyIsolationByMachine = 64,
        ApplicationIsolationByMachine = 69,
        DomainIsolationByRoamingUser = 80,
        AssemblyIsolationByRoamingUser = 96,
        ApplicationIsolationByRoamingUser = 101,
        AdministerIsolatedStorageByUser = 112,
        UnrestrictedIsolatedStorage = 240,
      }
      export enum PermissionState {
        None = 0,
        Unrestricted = 1,
      }
      export enum ReflectionPermissionFlag {
        AllFlags = 7,
        MemberAccess = 2,
        NoFlags = 0,
        ReflectionEmit = 4,
        RestrictedMemberAccess = 8,
        TypeInformation = 1,
      }
      export enum RegistryPermissionAccess {
        AllAccess = 7,
        Create = 4,
        NoAccess = 0,
        Read = 1,
        Write = 2,
      }
      export enum UIPermissionClipboard {
        AllClipboard = 2,
        NoClipboard = 0,
        OwnClipboard = 1,
      }
      export enum UIPermissionWindow {
        AllWindows = 3,
        NoWindows = 0,
        SafeSubWindows = 1,
        SafeTopLevelWindows = 2,
      }
      export class EnvironmentPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(flag: System.Security.Permissions.EnvironmentPermissionAccess, pathList: string);
        AddPathList(flag: System.Security.Permissions.EnvironmentPermissionAccess, pathList: string): void;
        Copy(): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        GetPathList(flag: System.Security.Permissions.EnvironmentPermissionAccess): string;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        IsUnrestricted(): boolean;
        SetPathList(flag: System.Security.Permissions.EnvironmentPermissionAccess, pathList: string): void;
        ToXml(): System.Security.SecurityElement;
        Union(other: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export enum EnvironmentPermissionAccess {
        NoAccess = 0,
        Read = 1,
        Write = 2,
        AllAccess = 3,
      }
      export class FileDialogPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(access: System.Security.Permissions.FileDialogPermissionAccess);
        Access: System.Security.Permissions.FileDialogPermissionAccess;
        Copy(): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        IsUnrestricted(): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class FileIOPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(access: System.Security.Permissions.FileIOPermissionAccess, path: string);
        constructor(access: System.Security.Permissions.FileIOPermissionAccess, pathList: string[]);
        constructor(access: System.Security.Permissions.FileIOPermissionAccess, control: System.Security.AccessControl.AccessControlActions, path: string);
        constructor(access: System.Security.Permissions.FileIOPermissionAccess, control: System.Security.AccessControl.AccessControlActions, pathList: string[]);
        AllFiles: System.Security.Permissions.FileIOPermissionAccess;
        AllLocalFiles: System.Security.Permissions.FileIOPermissionAccess;
        AddPathList(access: System.Security.Permissions.FileIOPermissionAccess, path: string): void;
        AddPathList(access: System.Security.Permissions.FileIOPermissionAccess, pathList: string[]): void;
        Copy(): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        GetPathList(access: System.Security.Permissions.FileIOPermissionAccess): string[];
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        IsUnrestricted(): boolean;
        SetPathList(access: System.Security.Permissions.FileIOPermissionAccess, path: string): void;
        SetPathList(access: System.Security.Permissions.FileIOPermissionAccess, pathList: string[]): void;
        ToXml(): System.Security.SecurityElement;
        Union(other: System.Security.IPermission): System.Security.IPermission;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export enum FileIOPermissionAccess {
        NoAccess = 0,
        Read = 1,
        Write = 2,
        Append = 4,
        PathDiscovery = 8,
        AllAccess = 15,
      }
      export class GacIdentityPermission {
        constructor();
        constructor(state: System.Security.Permissions.PermissionState);
        Copy(): System.Security.IPermission;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        FromXml(securityElement: System.Security.SecurityElement): void;
        ToXml(): System.Security.SecurityElement;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class IsolatedStorageFilePermission {
        constructor(state: System.Security.Permissions.PermissionState);
        UserQuota: number;
        UsageAllowed: System.Security.Permissions.IsolatedStorageContainment;
        Copy(): System.Security.IPermission;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        ToXml(): System.Security.SecurityElement;
        IsUnrestricted(): boolean;
        FromXml(esd: System.Security.SecurityElement): void;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class IsolatedStoragePermission {
        UserQuota: number;
        UsageAllowed: System.Security.Permissions.IsolatedStorageContainment;
        IsUnrestricted(): boolean;
        ToXml(): System.Security.SecurityElement;
        FromXml(esd: System.Security.SecurityElement): void;
        Assert(): void;
        Copy(): System.Security.IPermission;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        ToString(): string;
        Union(other: System.Security.IPermission): System.Security.IPermission;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class KeyContainerPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(flags: System.Security.Permissions.KeyContainerPermissionFlags);
        constructor(flags: System.Security.Permissions.KeyContainerPermissionFlags, accessList: System.Security.Permissions.KeyContainerPermissionAccessEntry[]);
        AccessEntries: System.Security.Permissions.KeyContainerPermissionAccessEntryCollection;
        Flags: System.Security.Permissions.KeyContainerPermissionFlags;
        Copy(): System.Security.IPermission;
        FromXml(securityElement: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        IsUnrestricted(): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class KeyContainerPermissionAccessEntry {
        constructor(parameters: System.Security.Cryptography.CspParameters, flags: System.Security.Permissions.KeyContainerPermissionFlags);
        constructor(keyContainerName: string, flags: System.Security.Permissions.KeyContainerPermissionFlags);
        constructor(keyStore: string, providerName: string, providerType: number, keyContainerName: string, keySpec: number, flags: System.Security.Permissions.KeyContainerPermissionFlags);
        Flags: System.Security.Permissions.KeyContainerPermissionFlags;
        KeyContainerName: string;
        KeySpec: number;
        KeyStore: string;
        ProviderName: string;
        ProviderType: number;
        Equals(o: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class KeyContainerPermissionAccessEntryCollection {
        Count: number;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        Add(accessEntry: System.Security.Permissions.KeyContainerPermissionAccessEntry): number;
        Clear(): void;
        CopyTo(array: System.Security.Permissions.KeyContainerPermissionAccessEntry[], index: number): void;
        GetEnumerator(): System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator;
        IndexOf(accessEntry: System.Security.Permissions.KeyContainerPermissionAccessEntry): number;
        Remove(accessEntry: System.Security.Permissions.KeyContainerPermissionAccessEntry): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class KeyContainerPermissionAccessEntryEnumerator {
        Current: System.Security.Permissions.KeyContainerPermissionAccessEntry;
        MoveNext(): boolean;
        Reset(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum KeyContainerPermissionFlags {
        NoFlags = 0,
        Create = 1,
        Open = 2,
        Delete = 4,
        Import = 16,
        Export = 32,
        Sign = 256,
        Decrypt = 512,
        ViewAcl = 4096,
        ChangeAcl = 8192,
        AllFlags = 13111,
      }
      export class PrincipalPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(name: string, role: string);
        constructor(name: string, role: string, isAuthenticated: boolean);
        Copy(): System.Security.IPermission;
        Demand(): void;
        FromXml(elem: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        IsUnrestricted(): boolean;
        ToString(): string;
        ToXml(): System.Security.SecurityElement;
        Union(other: System.Security.IPermission): System.Security.IPermission;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class PublisherIdentityPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(certificate: System.Security.Cryptography.X509Certificates.X509Certificate);
        Certificate: System.Security.Cryptography.X509Certificates.X509Certificate;
        Copy(): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class ReflectionPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(flag: System.Security.Permissions.ReflectionPermissionFlag);
        Flags: System.Security.Permissions.ReflectionPermissionFlag;
        Copy(): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        IsUnrestricted(): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(other: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class RegistryPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(access: System.Security.Permissions.RegistryPermissionAccess, pathList: string);
        constructor(access: System.Security.Permissions.RegistryPermissionAccess, control: System.Security.AccessControl.AccessControlActions, pathList: string);
        AddPathList(access: System.Security.Permissions.RegistryPermissionAccess, pathList: string): void;
        AddPathList(access: System.Security.Permissions.RegistryPermissionAccess, control: System.Security.AccessControl.AccessControlActions, pathList: string): void;
        GetPathList(access: System.Security.Permissions.RegistryPermissionAccess): string;
        SetPathList(access: System.Security.Permissions.RegistryPermissionAccess, pathList: string): void;
        Copy(): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        IsUnrestricted(): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(other: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export enum SecurityAction {
        Demand = 2,
        Assert = 3,
        Deny = 4,
        PermitOnly = 5,
        LinkDemand = 6,
        InheritanceDemand = 7,
        RequestMinimum = 8,
        RequestOptional = 9,
        RequestRefuse = 10,
      }
      export class SecurityPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(flag: System.Security.Permissions.SecurityPermissionFlag);
        Flags: System.Security.Permissions.SecurityPermissionFlag;
        IsUnrestricted(): boolean;
        Copy(): System.Security.IPermission;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        FromXml(esd: System.Security.SecurityElement): void;
        ToXml(): System.Security.SecurityElement;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export enum SecurityPermissionFlag {
        NoFlags = 0,
        Assertion = 1,
        UnmanagedCode = 2,
        SkipVerification = 4,
        Execution = 8,
        ControlThread = 16,
        ControlEvidence = 32,
        ControlPolicy = 64,
        SerializationFormatter = 128,
        ControlDomainPolicy = 256,
        ControlPrincipal = 512,
        ControlAppDomain = 1024,
        RemotingConfiguration = 2048,
        Infrastructure = 4096,
        BindingRedirects = 8192,
        AllFlags = 16383,
      }
      export class SiteIdentityPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(site: string);
        Site: string;
        Copy(): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class StrongNameIdentityPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(blob: System.Security.Permissions.StrongNamePublicKeyBlob, name: string, version: System.Version);
        Name: string;
        PublicKey: System.Security.Permissions.StrongNamePublicKeyBlob;
        Version: System.Version;
        Copy(): System.Security.IPermission;
        FromXml(e: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class StrongNamePublicKeyBlob {
        constructor(publicKey: Byte[]);
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class UIPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(clipboardFlag: System.Security.Permissions.UIPermissionClipboard);
        constructor(windowFlag: System.Security.Permissions.UIPermissionWindow);
        constructor(windowFlag: System.Security.Permissions.UIPermissionWindow, clipboardFlag: System.Security.Permissions.UIPermissionClipboard);
        Clipboard: System.Security.Permissions.UIPermissionClipboard;
        Window: System.Security.Permissions.UIPermissionWindow;
        Copy(): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        IsUnrestricted(): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class UrlIdentityPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(site: string);
        Url: string;
        Copy(): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class ZoneIdentityPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(zone: System.Security.SecurityZone);
        SecurityZone: System.Security.SecurityZone;
        Copy(): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        FromXml(esd: System.Security.SecurityElement): void;
        ToXml(): System.Security.SecurityElement;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export enum TypeDescriptorPermissionFlags {
        NoFlags = 0,
        RestrictedRegistrationAccess = 1,
      }
      export class TypeDescriptorPermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(flag: System.Security.Permissions.TypeDescriptorPermissionFlags);
        Flags: System.Security.Permissions.TypeDescriptorPermissionFlags;
        IsUnrestricted(): boolean;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        Copy(): System.Security.IPermission;
        ToXml(): System.Security.SecurityElement;
        FromXml(securityElement: System.Security.SecurityElement): void;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class ResourcePermissionBase {
        static Any: string;
        static Local: string;
        Copy(): System.Security.IPermission;
        FromXml(securityElement: System.Security.SecurityElement): void;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        IsUnrestricted(): boolean;
        ToXml(): System.Security.SecurityElement;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export class ResourcePermissionBaseEntry {
        constructor();
        constructor(permissionAccess: number, permissionAccessPath: string[]);
        PermissionAccess: number;
        PermissionAccessPath: string[];
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class StorePermission {
        constructor(state: System.Security.Permissions.PermissionState);
        constructor(flag: System.Security.Permissions.StorePermissionFlags);
        Flags: System.Security.Permissions.StorePermissionFlags;
        IsUnrestricted(): boolean;
        Copy(): System.Security.IPermission;
        Intersect(target: System.Security.IPermission): System.Security.IPermission;
        Union(target: System.Security.IPermission): System.Security.IPermission;
        IsSubsetOf(target: System.Security.IPermission): boolean;
        FromXml(securityElement: System.Security.SecurityElement): void;
        ToXml(): System.Security.SecurityElement;
        Assert(): void;
        Demand(): void;
        Deny(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        PermitOnly(): void;
        GetType(): System.Type;
      }
      export enum StorePermissionFlags {
        NoFlags = 0,
        CreateStore = 1,
        DeleteStore = 2,
        EnumerateStores = 4,
        OpenStore = 16,
        AddToStore = 32,
        RemoveFromStore = 64,
        EnumerateCertificates = 128,
        AllFlags = 247,
      }
    }
    export namespace Policy {
      export enum ApplicationVersionMatch {
        MatchAllVersions = 1,
        MatchExactVersion = 0,
      }
      export interface IIdentityPermissionFactory {
        CreateIdentityPermission(evidence: System.Security.Policy.Evidence): System.Security.IPermission;
      }
      export interface IMembershipCondition {
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(obj: any): boolean;
        ToString(): string;
      }
      export enum PolicyStatementAttribute {
        All = 3,
        Exclusive = 1,
        LevelFinal = 2,
        Nothing = 0,
      }
      export class Publisher {
        constructor(cert: System.Security.Cryptography.X509Certificates.X509Certificate);
        Certificate: System.Security.Cryptography.X509Certificates.X509Certificate;
        Copy(): any;
        CreateIdentityPermission(evidence: System.Security.Policy.Evidence): System.Security.IPermission;
        Equals(o: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        Clone(): System.Security.Policy.EvidenceBase;
        GetType(): System.Type;
      }
      export class PublisherMembershipCondition {
        constructor(certificate: System.Security.Cryptography.X509Certificates.X509Certificate);
        Certificate: System.Security.Cryptography.X509Certificates.X509Certificate;
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(o: any): boolean;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        GetHashCode(): number;
        ToString(): string;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
      }
      export class AllMembershipCondition {
        constructor();
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(o: any): boolean;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        GetHashCode(): number;
        ToString(): string;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
      }
      export class ApplicationDirectory {
        constructor(name: string);
        Directory: string;
        Copy(): any;
        Equals(o: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        Clone(): System.Security.Policy.EvidenceBase;
        GetType(): System.Type;
      }
      export class ApplicationDirectoryMembershipCondition {
        constructor();
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(o: any): boolean;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        GetHashCode(): number;
        ToString(): string;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
      }
      export class ApplicationSecurityInfo {
        constructor(activationContext: System.ActivationContext);
        ApplicationEvidence: System.Security.Policy.Evidence;
        ApplicationId: System.ApplicationId;
        DefaultRequestSet: System.Security.PermissionSet;
        DeploymentId: System.ApplicationId;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ApplicationSecurityManager {
        static ApplicationTrustManager: System.Security.Policy.IApplicationTrustManager;
        static UserApplicationTrusts: System.Security.Policy.ApplicationTrustCollection;
        static DetermineApplicationTrust(activationContext: System.ActivationContext, context: System.Security.Policy.TrustManagerContext): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ApplicationTrust {
        constructor();
        constructor(applicationIdentity: System.ApplicationIdentity);
        constructor(defaultGrantSet: System.Security.PermissionSet, fullTrustAssemblies: System.Collections.Generic.IEnumerable<System.Security.Policy.StrongName>);
        ApplicationIdentity: System.ApplicationIdentity;
        DefaultGrantSet: System.Security.Policy.PolicyStatement;
        ExtraInfo: any; // System.Object
        IsApplicationTrustedToRun: boolean;
        Persist: boolean;
        FullTrustAssemblies: System.Security.Policy.StrongName[];
        FromXml(element: System.Security.SecurityElement): void;
        ToXml(): System.Security.SecurityElement;
        Clone(): System.Security.Policy.EvidenceBase;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ApplicationTrustCollection {
        Count: number;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        Add(trust: System.Security.Policy.ApplicationTrust): number;
        AddRange(trusts: System.Security.Policy.ApplicationTrust[]): void;
        AddRange(trusts: System.Security.Policy.ApplicationTrustCollection): void;
        Clear(): void;
        CopyTo(array: System.Security.Policy.ApplicationTrust[], index: number): void;
        Find(applicationIdentity: System.ApplicationIdentity, versionMatch: System.Security.Policy.ApplicationVersionMatch): System.Security.Policy.ApplicationTrustCollection;
        GetEnumerator(): System.Security.Policy.ApplicationTrustEnumerator;
        Remove(trust: System.Security.Policy.ApplicationTrust): void;
        Remove(applicationIdentity: System.ApplicationIdentity, versionMatch: System.Security.Policy.ApplicationVersionMatch): void;
        RemoveRange(trusts: System.Security.Policy.ApplicationTrust[]): void;
        RemoveRange(trusts: System.Security.Policy.ApplicationTrustCollection): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ApplicationTrustEnumerator {
        Current: System.Security.Policy.ApplicationTrust;
        Reset(): void;
        MoveNext(): boolean;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CodeConnectAccess {
        constructor(allowScheme: string, allowPort: number);
        Port: number;
        Scheme: string;
        static AnyScheme: string;
        static DefaultPort: number;
        static OriginPort: number;
        static OriginScheme: string;
        Equals(o: any): boolean;
        GetHashCode(): number;
        static CreateAnySchemeAccess(allowPort: number): System.Security.Policy.CodeConnectAccess;
        static CreateOriginSchemeAccess(allowPort: number): System.Security.Policy.CodeConnectAccess;
        GetType(): System.Type;
        ToString(): string;
      }
      export class CodeGroup {
        MergeLogic: string;
        PolicyStatement: System.Security.Policy.PolicyStatement;
        Description: string;
        MembershipCondition: System.Security.Policy.IMembershipCondition;
        Name: string;
        Children: System.Collections.IList;
        AttributeString: string;
        PermissionSetName: string;
        Copy(): System.Security.Policy.CodeGroup;
        Resolve(evidence: System.Security.Policy.Evidence): System.Security.Policy.PolicyStatement;
        ResolveMatchingCodeGroups(evidence: System.Security.Policy.Evidence): System.Security.Policy.CodeGroup;
        AddChild(group: System.Security.Policy.CodeGroup): void;
        Equals(o: any): boolean;
        Equals(cg: System.Security.Policy.CodeGroup, compareChildren: boolean): boolean;
        RemoveChild(group: System.Security.Policy.CodeGroup): void;
        GetHashCode(): number;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Evidence {
        constructor();
        constructor(evidence: System.Security.Policy.Evidence);
        constructor(hostEvidence: System.Security.Policy.EvidenceBase[], assemblyEvidence: System.Security.Policy.EvidenceBase[]);
        constructor(hostEvidence: any[], assemblyEvidence: any[]);
        Count: number;
        IsReadOnly: boolean;
        IsSynchronized: boolean;
        Locked: boolean;
        SyncRoot: any; // System.Object
        AddAssembly(id: any): void;
        AddHost(id: any): void;
        Clear(): void;
        Clone(): System.Security.Policy.Evidence;
        CopyTo(array: System.Array, index: number): void;
        GetEnumerator(): System.Collections.IEnumerator;
        GetAssemblyEnumerator(): System.Collections.IEnumerator;
        GetHostEnumerator(): System.Collections.IEnumerator;
        Merge(evidence: System.Security.Policy.Evidence): void;
        RemoveType(t: System.Type): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class EvidenceBase {
        Clone(): System.Security.Policy.EvidenceBase;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FileCodeGroup {
        constructor(membershipCondition: System.Security.Policy.IMembershipCondition, access: System.Security.Permissions.FileIOPermissionAccess);
        MergeLogic: string;
        AttributeString: string;
        PermissionSetName: string;
        PolicyStatement: System.Security.Policy.PolicyStatement;
        Description: string;
        MembershipCondition: System.Security.Policy.IMembershipCondition;
        Name: string;
        Children: System.Collections.IList;
        Copy(): System.Security.Policy.CodeGroup;
        Resolve(evidence: System.Security.Policy.Evidence): System.Security.Policy.PolicyStatement;
        ResolveMatchingCodeGroups(evidence: System.Security.Policy.Evidence): System.Security.Policy.CodeGroup;
        Equals(o: any): boolean;
        GetHashCode(): number;
        AddChild(group: System.Security.Policy.CodeGroup): void;
        Equals(cg: System.Security.Policy.CodeGroup, compareChildren: boolean): boolean;
        RemoveChild(group: System.Security.Policy.CodeGroup): void;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
        ToString(): string;
      }
      export class FirstMatchCodeGroup {
        constructor(membershipCondition: System.Security.Policy.IMembershipCondition, policy: System.Security.Policy.PolicyStatement);
        MergeLogic: string;
        PolicyStatement: System.Security.Policy.PolicyStatement;
        Description: string;
        MembershipCondition: System.Security.Policy.IMembershipCondition;
        Name: string;
        Children: System.Collections.IList;
        AttributeString: string;
        PermissionSetName: string;
        Copy(): System.Security.Policy.CodeGroup;
        Resolve(evidence: System.Security.Policy.Evidence): System.Security.Policy.PolicyStatement;
        ResolveMatchingCodeGroups(evidence: System.Security.Policy.Evidence): System.Security.Policy.CodeGroup;
        AddChild(group: System.Security.Policy.CodeGroup): void;
        Equals(o: any): boolean;
        Equals(cg: System.Security.Policy.CodeGroup, compareChildren: boolean): boolean;
        RemoveChild(group: System.Security.Policy.CodeGroup): void;
        GetHashCode(): number;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
        ToString(): string;
      }
      export class GacInstalled {
        constructor();
        Copy(): any;
        CreateIdentityPermission(evidence: System.Security.Policy.Evidence): System.Security.IPermission;
        Equals(o: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        Clone(): System.Security.Policy.EvidenceBase;
        GetType(): System.Type;
      }
      export class GacMembershipCondition {
        constructor();
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(o: any): boolean;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        GetHashCode(): number;
        ToString(): string;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
      }
      export class Hash {
        constructor(assembly: System.Reflection.Assembly);
        MD5: Byte[];
        SHA1: Byte[];
        SHA256: Byte[];
        GenerateHash(hashAlg: System.Security.Cryptography.HashAlgorithm): Byte[];
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        ToString(): string;
        static CreateMD5(md5: Byte[]): System.Security.Policy.Hash;
        static CreateSHA1(sha1: Byte[]): System.Security.Policy.Hash;
        static CreateSHA256(sha256: Byte[]): System.Security.Policy.Hash;
        Clone(): System.Security.Policy.EvidenceBase;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class HashMembershipCondition {
        constructor(hashAlg: System.Security.Cryptography.HashAlgorithm, value: Byte[]);
        HashAlgorithm: System.Security.Cryptography.HashAlgorithm;
        HashValue: Byte[];
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(o: any): boolean;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export interface IApplicationTrustManager {
        DetermineApplicationTrust(activationContext: System.ActivationContext, context: System.Security.Policy.TrustManagerContext): System.Security.Policy.ApplicationTrust;
      }
      export class NetCodeGroup {
        constructor(membershipCondition: System.Security.Policy.IMembershipCondition);
        AttributeString: string;
        MergeLogic: string;
        PermissionSetName: string;
        PolicyStatement: System.Security.Policy.PolicyStatement;
        Description: string;
        MembershipCondition: System.Security.Policy.IMembershipCondition;
        Name: string;
        Children: System.Collections.IList;
        static AbsentOriginScheme: string;
        static AnyOtherOriginScheme: string;
        AddConnectAccess(originScheme: string, connectAccess: System.Security.Policy.CodeConnectAccess): void;
        Copy(): System.Security.Policy.CodeGroup;
        Equals(o: any): boolean;
        GetConnectAccessRules(): System.Collections.DictionaryEntry[];
        GetHashCode(): number;
        Resolve(evidence: System.Security.Policy.Evidence): System.Security.Policy.PolicyStatement;
        ResetConnectAccess(): void;
        ResolveMatchingCodeGroups(evidence: System.Security.Policy.Evidence): System.Security.Policy.CodeGroup;
        AddChild(group: System.Security.Policy.CodeGroup): void;
        Equals(cg: System.Security.Policy.CodeGroup, compareChildren: boolean): boolean;
        RemoveChild(group: System.Security.Policy.CodeGroup): void;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
        ToString(): string;
      }
      export class PermissionRequestEvidence {
        constructor(request: System.Security.PermissionSet, optional: System.Security.PermissionSet, denied: System.Security.PermissionSet);
        DeniedPermissions: System.Security.PermissionSet;
        OptionalPermissions: System.Security.PermissionSet;
        RequestedPermissions: System.Security.PermissionSet;
        Copy(): System.Security.Policy.PermissionRequestEvidence;
        ToString(): string;
        Clone(): System.Security.Policy.EvidenceBase;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class PolicyException {
        constructor();
        constructor(message: string);
        constructor(message: string, exception: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class PolicyLevel {
        FullTrustAssemblies: System.Collections.IList;
        Label: string;
        NamedPermissionSets: System.Collections.IList;
        RootCodeGroup: System.Security.Policy.CodeGroup;
        StoreLocation: string;
        Type: System.Security.PolicyLevelType;
        AddFullTrustAssembly(sn: System.Security.Policy.StrongName): void;
        AddFullTrustAssembly(snMC: System.Security.Policy.StrongNameMembershipCondition): void;
        AddNamedPermissionSet(permSet: System.Security.NamedPermissionSet): void;
        ChangeNamedPermissionSet(name: string, pSet: System.Security.PermissionSet): System.Security.NamedPermissionSet;
        static CreateAppDomainLevel(): System.Security.Policy.PolicyLevel;
        FromXml(e: System.Security.SecurityElement): void;
        GetNamedPermissionSet(name: string): System.Security.NamedPermissionSet;
        Recover(): void;
        RemoveFullTrustAssembly(sn: System.Security.Policy.StrongName): void;
        RemoveFullTrustAssembly(snMC: System.Security.Policy.StrongNameMembershipCondition): void;
        RemoveNamedPermissionSet(permSet: System.Security.NamedPermissionSet): System.Security.NamedPermissionSet;
        RemoveNamedPermissionSet(name: string): System.Security.NamedPermissionSet;
        Reset(): void;
        Resolve(evidence: System.Security.Policy.Evidence): System.Security.Policy.PolicyStatement;
        ResolveMatchingCodeGroups(evidence: System.Security.Policy.Evidence): System.Security.Policy.CodeGroup;
        ToXml(): System.Security.SecurityElement;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class PolicyStatement {
        constructor(permSet: System.Security.PermissionSet);
        constructor(permSet: System.Security.PermissionSet, attributes: System.Security.Policy.PolicyStatementAttribute);
        PermissionSet: System.Security.PermissionSet;
        Attributes: System.Security.Policy.PolicyStatementAttribute;
        AttributeString: string;
        Copy(): System.Security.Policy.PolicyStatement;
        FromXml(et: System.Security.SecurityElement): void;
        FromXml(et: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Site {
        constructor(name: string);
        Name: string;
        static CreateFromUrl(url: string): System.Security.Policy.Site;
        Copy(): any;
        CreateIdentityPermission(evidence: System.Security.Policy.Evidence): System.Security.IPermission;
        Equals(o: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        Clone(): System.Security.Policy.EvidenceBase;
        GetType(): System.Type;
      }
      export class SiteMembershipCondition {
        constructor(site: string);
        Site: string;
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(o: any): boolean;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        GetHashCode(): number;
        ToString(): string;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
      }
      export class StrongName {
        constructor(blob: System.Security.Permissions.StrongNamePublicKeyBlob, name: string, version: System.Version);
        Name: string;
        PublicKey: System.Security.Permissions.StrongNamePublicKeyBlob;
        Version: System.Version;
        Copy(): any;
        CreateIdentityPermission(evidence: System.Security.Policy.Evidence): System.Security.IPermission;
        Equals(o: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        Clone(): System.Security.Policy.EvidenceBase;
        GetType(): System.Type;
      }
      export class StrongNameMembershipCondition {
        constructor(blob: System.Security.Permissions.StrongNamePublicKeyBlob, name: string, version: System.Version);
        Name: string;
        Version: System.Version;
        PublicKey: System.Security.Permissions.StrongNamePublicKeyBlob;
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(o: any): boolean;
        GetHashCode(): number;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        ToString(): string;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
      }
      export class TrustManagerContext {
        constructor();
        constructor(uiContext: System.Security.Policy.TrustManagerUIContext);
        IgnorePersistedDecision: boolean;
        KeepAlive: boolean;
        NoPrompt: boolean;
        Persist: boolean;
        PreviousApplicationIdentity: System.ApplicationIdentity;
        UIContext: System.Security.Policy.TrustManagerUIContext;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum TrustManagerUIContext {
        Install = 0,
        Upgrade = 1,
        Run = 2,
      }
      export class UnionCodeGroup {
        constructor(membershipCondition: System.Security.Policy.IMembershipCondition, policy: System.Security.Policy.PolicyStatement);
        MergeLogic: string;
        PolicyStatement: System.Security.Policy.PolicyStatement;
        Description: string;
        MembershipCondition: System.Security.Policy.IMembershipCondition;
        Name: string;
        Children: System.Collections.IList;
        AttributeString: string;
        PermissionSetName: string;
        Copy(): System.Security.Policy.CodeGroup;
        Resolve(evidence: System.Security.Policy.Evidence): System.Security.Policy.PolicyStatement;
        ResolveMatchingCodeGroups(evidence: System.Security.Policy.Evidence): System.Security.Policy.CodeGroup;
        AddChild(group: System.Security.Policy.CodeGroup): void;
        Equals(o: any): boolean;
        Equals(cg: System.Security.Policy.CodeGroup, compareChildren: boolean): boolean;
        RemoveChild(group: System.Security.Policy.CodeGroup): void;
        GetHashCode(): number;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Url {
        constructor(name: string);
        Value: string;
        Copy(): any;
        CreateIdentityPermission(evidence: System.Security.Policy.Evidence): System.Security.IPermission;
        Equals(o: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        Clone(): System.Security.Policy.EvidenceBase;
        GetType(): System.Type;
      }
      export class UrlMembershipCondition {
        constructor(url: string);
        Url: string;
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(o: any): boolean;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        GetHashCode(): number;
        ToString(): string;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
      }
      export class Zone {
        constructor(zone: System.Security.SecurityZone);
        SecurityZone: System.Security.SecurityZone;
        Copy(): any;
        CreateIdentityPermission(evidence: System.Security.Policy.Evidence): System.Security.IPermission;
        static CreateFromUrl(url: string): System.Security.Policy.Zone;
        Equals(o: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        Clone(): System.Security.Policy.EvidenceBase;
        GetType(): System.Type;
      }
      export class ZoneMembershipCondition {
        constructor(zone: System.Security.SecurityZone);
        SecurityZone: System.Security.SecurityZone;
        Check(evidence: System.Security.Policy.Evidence): boolean;
        Copy(): System.Security.Policy.IMembershipCondition;
        Equals(o: any): boolean;
        FromXml(e: System.Security.SecurityElement): void;
        FromXml(e: System.Security.SecurityElement, level: System.Security.Policy.PolicyLevel): void;
        GetHashCode(): number;
        ToString(): string;
        ToXml(): System.Security.SecurityElement;
        ToXml(level: System.Security.Policy.PolicyLevel): System.Security.SecurityElement;
        GetType(): System.Type;
      }
    }
    export namespace Principal {
      export class GenericIdentity {
        constructor(name: string);
        constructor(name: string, type: string);
        Claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        Name: string;
        AuthenticationType: string;
        IsAuthenticated: boolean;
        Actor: System.Security.Claims.ClaimsIdentity;
        BootstrapContext: any; // System.Object
        Label: string;
        NameClaimType: string;
        RoleClaimType: string;
        Clone(): System.Security.Claims.ClaimsIdentity;
        AddClaim(claim: System.Security.Claims.Claim): void;
        AddClaims(claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>): void;
        TryRemoveClaim(claim: System.Security.Claims.Claim): boolean;
        RemoveClaim(claim: System.Security.Claims.Claim): void;
        FindAll(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        FindAll(type: string): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        HasClaim(match: ((obj: System.Security.Claims.Claim) => boolean)): boolean;
        HasClaim(type: string, value: string): boolean;
        FindFirst(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Security.Claims.Claim;
        FindFirst(type: string): System.Security.Claims.Claim;
        WriteTo(writer: System.IO.BinaryWriter): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum TokenAccessLevels {
        AssignPrimary = 1,
        Duplicate = 2,
        Impersonate = 4,
        Query = 8,
        QuerySource = 16,
        AdjustPrivileges = 32,
        AdjustGroups = 64,
        AdjustDefault = 128,
        AdjustSessionId = 256,
        Read = 131080,
        Write = 131296,
        AllAccess = 983551,
        MaximumAllowed = 33554432,
      }
      export interface IIdentity {
        Name: string;
        AuthenticationType: string;
        IsAuthenticated: boolean;
      }
      export interface IPrincipal {
        Identity: System.Security.Principal.IIdentity;
        IsInRole(role: string): boolean;
      }
      export enum PrincipalPolicy {
        UnauthenticatedPrincipal = 0,
        NoPrincipal = 1,
        WindowsPrincipal = 2,
      }
      export enum TokenImpersonationLevel {
        None = 0,
        Anonymous = 1,
        Identification = 2,
        Impersonation = 3,
        Delegation = 4,
      }
      export class GenericPrincipal {
        constructor(identity: System.Security.Principal.IIdentity, roles: string[]);
        Identity: System.Security.Principal.IIdentity;
        Claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        Identities: System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>;
        IsInRole(role: string): boolean;
        Clone(): System.Security.Claims.ClaimsPrincipal;
        AddIdentity(identity: System.Security.Claims.ClaimsIdentity): void;
        AddIdentities(identities: System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>): void;
        FindAll(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        FindAll(type: string): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        FindFirst(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Security.Claims.Claim;
        FindFirst(type: string): System.Security.Claims.Claim;
        HasClaim(match: ((obj: System.Security.Claims.Claim) => boolean)): boolean;
        HasClaim(type: string, value: string): boolean;
        WriteTo(writer: System.IO.BinaryWriter): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class IdentityNotMappedException {
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        UnmappedIdentities: System.Security.Principal.IdentityReferenceCollection;
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetObjectData(serializationInfo: System.Runtime.Serialization.SerializationInfo, streamingContext: System.Runtime.Serialization.StreamingContext): void;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class IdentityReference {
        Value: string;
        Equals(o: any): boolean;
        GetHashCode(): number;
        IsValidTargetType(targetType: System.Type): boolean;
        ToString(): string;
        Translate(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetType(): System.Type;
      }
      export class IdentityReferenceCollection {
        constructor();
        constructor(capacity: number);
        Count: number;
        IsReadOnly: boolean;
        Add(identity: System.Security.Principal.IdentityReference): void;
        Clear(): void;
        Contains(identity: System.Security.Principal.IdentityReference): boolean;
        CopyTo(array: System.Security.Principal.IdentityReference[], offset: number): void;
        GetEnumerator(): System.Collections.Generic.IEnumerator<System.Security.Principal.IdentityReference>;
        Remove(identity: System.Security.Principal.IdentityReference): boolean;
        Translate(targetType: System.Type): System.Security.Principal.IdentityReferenceCollection;
        Translate(targetType: System.Type, forceSuccess: boolean): System.Security.Principal.IdentityReferenceCollection;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class NTAccount {
        constructor(name: string);
        constructor(domainName: string, accountName: string);
        Value: string;
        Equals(o: any): boolean;
        GetHashCode(): number;
        IsValidTargetType(targetType: System.Type): boolean;
        ToString(): string;
        Translate(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetType(): System.Type;
      }
      export class SecurityIdentifier {
        constructor(sddlForm: string);
        constructor(binaryForm: Byte[], offset: number);
        constructor(binaryForm: System.IntPtr);
        constructor(sidType: System.Security.Principal.WellKnownSidType, domainSid: System.Security.Principal.SecurityIdentifier);
        AccountDomainSid: System.Security.Principal.SecurityIdentifier;
        BinaryLength: number;
        Value: string;
        static MaxBinaryLength: number;
        static MinBinaryLength: number;
        CompareTo(sid: System.Security.Principal.SecurityIdentifier): number;
        Equals(o: any): boolean;
        Equals(sid: System.Security.Principal.SecurityIdentifier): boolean;
        GetBinaryForm(binaryForm: Byte[], offset: number): void;
        GetHashCode(): number;
        IsAccountSid(): boolean;
        IsEqualDomainSid(sid: System.Security.Principal.SecurityIdentifier): boolean;
        IsValidTargetType(targetType: System.Type): boolean;
        IsWellKnown(type: System.Security.Principal.WellKnownSidType): boolean;
        ToString(): string;
        Translate(targetType: System.Type): System.Security.Principal.IdentityReference;
        GetType(): System.Type;
      }
      export enum WellKnownSidType {
        NullSid = 0,
        WorldSid = 1,
        LocalSid = 2,
        CreatorOwnerSid = 3,
        CreatorGroupSid = 4,
        CreatorOwnerServerSid = 5,
        CreatorGroupServerSid = 6,
        NTAuthoritySid = 7,
        DialupSid = 8,
        NetworkSid = 9,
        BatchSid = 10,
        InteractiveSid = 11,
        ServiceSid = 12,
        AnonymousSid = 13,
        ProxySid = 14,
        EnterpriseControllersSid = 15,
        SelfSid = 16,
        AuthenticatedUserSid = 17,
        RestrictedCodeSid = 18,
        TerminalServerSid = 19,
        RemoteLogonIdSid = 20,
        LogonIdsSid = 21,
        LocalSystemSid = 22,
        LocalServiceSid = 23,
        NetworkServiceSid = 24,
        BuiltinDomainSid = 25,
        BuiltinAdministratorsSid = 26,
        BuiltinUsersSid = 27,
        BuiltinGuestsSid = 28,
        BuiltinPowerUsersSid = 29,
        BuiltinAccountOperatorsSid = 30,
        BuiltinSystemOperatorsSid = 31,
        BuiltinPrintOperatorsSid = 32,
        BuiltinBackupOperatorsSid = 33,
        BuiltinReplicatorSid = 34,
        BuiltinPreWindows2000CompatibleAccessSid = 35,
        BuiltinRemoteDesktopUsersSid = 36,
        BuiltinNetworkConfigurationOperatorsSid = 37,
        AccountAdministratorSid = 38,
        AccountGuestSid = 39,
        AccountKrbtgtSid = 40,
        AccountDomainAdminsSid = 41,
        AccountDomainUsersSid = 42,
        AccountDomainGuestsSid = 43,
        AccountComputersSid = 44,
        AccountControllersSid = 45,
        AccountCertAdminsSid = 46,
        AccountSchemaAdminsSid = 47,
        AccountEnterpriseAdminsSid = 48,
        AccountPolicyAdminsSid = 49,
        AccountRasAndIasServersSid = 50,
        NtlmAuthenticationSid = 51,
        DigestAuthenticationSid = 52,
        SChannelAuthenticationSid = 53,
        ThisOrganizationSid = 54,
        OtherOrganizationSid = 55,
        BuiltinIncomingForestTrustBuildersSid = 56,
        BuiltinPerformanceMonitoringUsersSid = 57,
        BuiltinPerformanceLoggingUsersSid = 58,
        BuiltinAuthorizationAccessSid = 59,
        WinBuiltinTerminalServerLicenseServersSid = 60,
        MaxDefined = 60,
        WinBuiltinDCOMUsersSid = 61,
        WinBuiltinIUsersSid = 62,
        WinIUserSid = 63,
        WinBuiltinCryptoOperatorsSid = 64,
        WinUntrustedLabelSid = 65,
        WinLowLabelSid = 66,
        WinMediumLabelSid = 67,
        WinHighLabelSid = 68,
        WinSystemLabelSid = 69,
        WinWriteRestrictedCodeSid = 70,
        WinCreatorOwnerRightsSid = 71,
        WinCacheablePrincipalsGroupSid = 72,
        WinNonCacheablePrincipalsGroupSid = 73,
        WinEnterpriseReadonlyControllersSid = 74,
        WinAccountReadonlyControllersSid = 75,
        WinBuiltinEventLogReadersGroup = 76,
        WinNewEnterpriseReadonlyControllersSid = 77,
        WinBuiltinCertSvcDComAccessGroup = 78,
        WinMediumPlusLabelSid = 79,
        WinLocalLogonSid = 80,
        WinConsoleLogonSid = 81,
        WinThisOrganizationCertificateSid = 82,
        WinApplicationPackageAuthoritySid = 83,
        WinBuiltinAnyPackageSid = 84,
        WinCapabilityInternetClientSid = 85,
        WinCapabilityInternetClientServerSid = 86,
        WinCapabilityPrivateNetworkClientServerSid = 87,
        WinCapabilityPicturesLibrarySid = 88,
        WinCapabilityVideosLibrarySid = 89,
        WinCapabilityMusicLibrarySid = 90,
        WinCapabilityDocumentsLibrarySid = 91,
        WinCapabilitySharedUserCertificatesSid = 92,
        WinCapabilityEnterpriseAuthenticationSid = 93,
        WinCapabilityRemovableStorageSid = 94,
      }
      export enum WindowsAccountType {
        Normal = 0,
        Guest = 1,
        System = 2,
        Anonymous = 3,
      }
      export enum WindowsBuiltInRole {
        Administrator = 544,
        User = 545,
        Guest = 546,
        PowerUser = 547,
        AccountOperator = 548,
        SystemOperator = 549,
        PrintOperator = 550,
        BackupOperator = 551,
        Replicator = 552,
      }
      export class WindowsIdentity {
        constructor(userToken: System.IntPtr);
        constructor(userToken: System.IntPtr, type: string);
        constructor(userToken: System.IntPtr, type: string, acctType: System.Security.Principal.WindowsAccountType);
        constructor(userToken: System.IntPtr, type: string, acctType: System.Security.Principal.WindowsAccountType, isAuthenticated: boolean);
        constructor(sUserPrincipalName: string);
        constructor(sUserPrincipalName: string, type: string);
        constructor(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext);
        AuthenticationType: string;
        IsAnonymous: boolean;
        IsAuthenticated: boolean;
        IsGuest: boolean;
        IsSystem: boolean;
        Name: string;
        Token: System.IntPtr;
        Groups: System.Security.Principal.IdentityReferenceCollection;
        ImpersonationLevel: System.Security.Principal.TokenImpersonationLevel;
        Owner: System.Security.Principal.SecurityIdentifier;
        User: System.Security.Principal.SecurityIdentifier;
        AccessToken: any; // Microsoft.Win32.SafeHandles.SafeAccessTokenHandle
        DeviceClaims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        UserClaims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        Actor: System.Security.Claims.ClaimsIdentity;
        BootstrapContext: any; // System.Object
        Claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        Label: string;
        NameClaimType: string;
        RoleClaimType: string;
        static DefaultIssuer: string;
        Dispose(): void;
        static GetAnonymous(): System.Security.Principal.WindowsIdentity;
        static GetCurrent(): System.Security.Principal.WindowsIdentity;
        static GetCurrent(ifImpersonating: boolean): System.Security.Principal.WindowsIdentity;
        static GetCurrent(desiredAccess: System.Security.Principal.TokenAccessLevels): System.Security.Principal.WindowsIdentity;
        Impersonate(): System.Security.Principal.WindowsImpersonationContext;
        static Impersonate(userToken: System.IntPtr): System.Security.Principal.WindowsImpersonationContext;
        static RunImpersonated(safeAccessTokenHandle: any, action: (() => void)): void;
        Clone(): System.Security.Claims.ClaimsIdentity;
        AddClaim(claim: System.Security.Claims.Claim): void;
        AddClaims(claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>): void;
        TryRemoveClaim(claim: System.Security.Claims.Claim): boolean;
        RemoveClaim(claim: System.Security.Claims.Claim): void;
        FindAll(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        FindAll(type: string): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        HasClaim(match: ((obj: System.Security.Claims.Claim) => boolean)): boolean;
        HasClaim(type: string, value: string): boolean;
        FindFirst(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Security.Claims.Claim;
        FindFirst(type: string): System.Security.Claims.Claim;
        WriteTo(writer: System.IO.BinaryWriter): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class WindowsImpersonationContext {
        Dispose(): void;
        Undo(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class WindowsPrincipal {
        constructor(ntIdentity: System.Security.Principal.WindowsIdentity);
        Identity: System.Security.Principal.IIdentity;
        DeviceClaims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        UserClaims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        Claims: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        Identities: System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>;
        IsInRole(rid: number): boolean;
        IsInRole(role: string): boolean;
        IsInRole(role: System.Security.Principal.WindowsBuiltInRole): boolean;
        IsInRole(sid: System.Security.Principal.SecurityIdentifier): boolean;
        Clone(): System.Security.Claims.ClaimsPrincipal;
        AddIdentity(identity: System.Security.Claims.ClaimsIdentity): void;
        AddIdentities(identities: System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>): void;
        FindAll(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        FindAll(type: string): System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>;
        FindFirst(match: ((obj: System.Security.Claims.Claim) => boolean)): System.Security.Claims.Claim;
        FindFirst(type: string): System.Security.Claims.Claim;
        HasClaim(match: ((obj: System.Security.Claims.Claim) => boolean)): boolean;
        HasClaim(type: string, value: string): boolean;
        WriteTo(writer: System.IO.BinaryWriter): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
  }
  export namespace Text {
    export class ASCIIEncoding {
      constructor();
      IsSingleByte: boolean;
      Preamble: System.ReadOnlySpan<Byte>;
      BodyName: string;
      EncodingName: string;
      HeaderName: string;
      WebName: string;
      WindowsCodePage: number;
      IsBrowserDisplay: boolean;
      IsBrowserSave: boolean;
      IsMailNewsDisplay: boolean;
      IsMailNewsSave: boolean;
      EncoderFallback: System.Text.EncoderFallback;
      DecoderFallback: System.Text.DecoderFallback;
      IsReadOnly: boolean;
      CodePage: number;
      GetByteCount(chars: System.Char[], index: number, count: number): number;
      GetByteCount(chars: string): number;
      GetBytes(chars: string, charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetBytes(chars: System.Char[], charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetCharCount(bytes: Byte[], index: number, count: number): number;
      GetChars(bytes: Byte[], byteIndex: number, byteCount: number, chars: System.Char[], charIndex: number): number;
      GetString(bytes: Byte[], byteIndex: number, byteCount: number): string;
      GetMaxByteCount(charCount: number): number;
      GetMaxCharCount(byteCount: number): number;
      GetDecoder(): System.Text.Decoder;
      GetEncoder(): System.Text.Encoder;
      GetPreamble(): Byte[];
      Clone(): any;
      GetByteCount(chars: System.Char[]): number;
      GetByteCount(str: string, index: number, count: number): number;
      GetBytes(chars: System.Char[]): Byte[];
      GetBytes(chars: System.Char[], index: number, count: number): Byte[];
      GetBytes(s: string): Byte[];
      GetCharCount(bytes: Byte[]): number;
      GetChars(bytes: Byte[]): System.Char[];
      GetChars(bytes: Byte[], index: number, count: number): System.Char[];
      GetChars(bytes: System.ReadOnlySpan<Byte>, chars: System.Span<System.Char>): number;
      GetString(bytes: System.ReadOnlySpan<Byte>): string;
      IsAlwaysNormalized(): boolean;
      IsAlwaysNormalized(form: System.Text.NormalizationForm): boolean;
      GetString(bytes: Byte[]): string;
      Equals(value: any): boolean;
      GetHashCode(): number;
      GetCharCount(bytes: System.ReadOnlySpan<Byte>): number;
      GetByteCount(chars: System.ReadOnlySpan<System.Char>): number;
      GetBytes(chars: System.ReadOnlySpan<System.Char>, bytes: System.Span<Byte>): number;
      GetBytes(s: string, index: number, count: number): Byte[];
      GetType(): System.Type;
      ToString(): string;
    }
    export class Decoder {
      Fallback: System.Text.DecoderFallback;
      FallbackBuffer: System.Text.DecoderFallbackBuffer;
      Reset(): void;
      GetCharCount(bytes: Byte[], index: number, count: number): number;
      GetCharCount(bytes: Byte[], index: number, count: number, flush: boolean): number;
      GetCharCount(bytes: System.ReadOnlySpan<Byte>, flush: boolean): number;
      GetChars(bytes: Byte[], byteIndex: number, byteCount: number, chars: System.Char[], charIndex: number): number;
      GetChars(bytes: Byte[], byteIndex: number, byteCount: number, chars: System.Char[], charIndex: number, flush: boolean): number;
      GetChars(bytes: System.ReadOnlySpan<Byte>, chars: System.Span<System.Char>, flush: boolean): number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DecoderExceptionFallback {
      constructor();
      MaxCharCount: number;
      CreateFallbackBuffer(): System.Text.DecoderFallbackBuffer;
      Equals(value: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DecoderExceptionFallbackBuffer {
      constructor();
      Remaining: number;
      Fallback(bytesUnknown: Byte[], index: number): boolean;
      GetNextChar(): System.Char;
      MovePrevious(): boolean;
      Reset(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DecoderFallbackException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      constructor(message: string, bytesUnknown: Byte[], index: number);
      BytesUnknown: Byte[];
      Index: number;
      Message: string;
      ParamName: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class DecoderFallback {
      static ReplacementFallback: System.Text.DecoderFallback;
      static ExceptionFallback: System.Text.DecoderFallback;
      MaxCharCount: number;
      CreateFallbackBuffer(): System.Text.DecoderFallbackBuffer;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DecoderFallbackBuffer {
      Remaining: number;
      Fallback(bytesUnknown: Byte[], index: number): boolean;
      GetNextChar(): System.Char;
      MovePrevious(): boolean;
      Reset(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DecoderReplacementFallback {
      constructor();
      constructor(replacement: string);
      DefaultString: string;
      MaxCharCount: number;
      CreateFallbackBuffer(): System.Text.DecoderFallbackBuffer;
      Equals(value: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class DecoderReplacementFallbackBuffer {
      constructor(fallback: System.Text.DecoderReplacementFallback);
      Remaining: number;
      Fallback(bytesUnknown: Byte[], index: number): boolean;
      GetNextChar(): System.Char;
      MovePrevious(): boolean;
      Reset(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Encoder {
      Fallback: System.Text.EncoderFallback;
      FallbackBuffer: System.Text.EncoderFallbackBuffer;
      Reset(): void;
      GetByteCount(chars: System.Char[], index: number, count: number, flush: boolean): number;
      GetByteCount(chars: System.ReadOnlySpan<System.Char>, flush: boolean): number;
      GetBytes(chars: System.Char[], charIndex: number, charCount: number, bytes: Byte[], byteIndex: number, flush: boolean): number;
      GetBytes(chars: System.ReadOnlySpan<System.Char>, bytes: System.Span<Byte>, flush: boolean): number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EncoderExceptionFallback {
      constructor();
      MaxCharCount: number;
      CreateFallbackBuffer(): System.Text.EncoderFallbackBuffer;
      Equals(value: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EncoderExceptionFallbackBuffer {
      constructor();
      Remaining: number;
      Fallback(charUnknown: System.Char, index: number): boolean;
      Fallback(charUnknownHigh: System.Char, charUnknownLow: System.Char, index: number): boolean;
      GetNextChar(): System.Char;
      MovePrevious(): boolean;
      Reset(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EncoderFallbackException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      CharUnknown: System.Char;
      CharUnknownHigh: System.Char;
      CharUnknownLow: System.Char;
      Index: number;
      Message: string;
      ParamName: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      IsUnknownSurrogate(): boolean;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class EncoderFallback {
      static ReplacementFallback: System.Text.EncoderFallback;
      static ExceptionFallback: System.Text.EncoderFallback;
      MaxCharCount: number;
      CreateFallbackBuffer(): System.Text.EncoderFallbackBuffer;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EncoderFallbackBuffer {
      Remaining: number;
      Fallback(charUnknown: System.Char, index: number): boolean;
      Fallback(charUnknownHigh: System.Char, charUnknownLow: System.Char, index: number): boolean;
      GetNextChar(): System.Char;
      MovePrevious(): boolean;
      Reset(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EncoderReplacementFallback {
      constructor();
      constructor(replacement: string);
      DefaultString: string;
      MaxCharCount: number;
      CreateFallbackBuffer(): System.Text.EncoderFallbackBuffer;
      Equals(value: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EncoderReplacementFallbackBuffer {
      constructor(fallback: System.Text.EncoderReplacementFallback);
      Remaining: number;
      Fallback(charUnknown: System.Char, index: number): boolean;
      Fallback(charUnknownHigh: System.Char, charUnknownLow: System.Char, index: number): boolean;
      GetNextChar(): System.Char;
      MovePrevious(): boolean;
      Reset(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EncodingInfo {
      CodePage: number;
      Name: string;
      DisplayName: string;
      GetEncoding(): System.Text.Encoding;
      Equals(value: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class EncodingProvider {
      constructor();
      GetEncoding(name: string): System.Text.Encoding;
      GetEncoding(codepage: number): System.Text.Encoding;
      GetEncoding(name: string, encoderFallback: System.Text.EncoderFallback, decoderFallback: System.Text.DecoderFallback): System.Text.Encoding;
      GetEncoding(codepage: number, encoderFallback: System.Text.EncoderFallback, decoderFallback: System.Text.DecoderFallback): System.Text.Encoding;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum NormalizationForm {
      FormC = 1,
      FormD = 2,
      FormKC = 5,
      FormKD = 6,
    }
    export class StringBuilder {
      constructor();
      constructor(capacity: number);
      constructor(value: string);
      constructor(value: string, capacity: number);
      constructor(value: string, startIndex: number, length: number, capacity: number);
      constructor(capacity: number, maxCapacity: number);
      Capacity: number;
      MaxCapacity: number;
      Length: number;
      EnsureCapacity(capacity: number): number;
      ToString(): string;
      ToString(startIndex: number, length: number): string;
      Clear(): System.Text.StringBuilder;
      Append(value: System.Char, repeatCount: number): System.Text.StringBuilder;
      Append(value: System.Char[], startIndex: number, charCount: number): System.Text.StringBuilder;
      Append(value: string): System.Text.StringBuilder;
      Append(value: string, startIndex: number, count: number): System.Text.StringBuilder;
      Append(value: System.Text.StringBuilder): System.Text.StringBuilder;
      Append(value: System.Text.StringBuilder, startIndex: number, count: number): System.Text.StringBuilder;
      AppendLine(): System.Text.StringBuilder;
      AppendLine(value: string): System.Text.StringBuilder;
      CopyTo(sourceIndex: number, destination: System.Char[], destinationIndex: number, count: number): void;
      CopyTo(sourceIndex: number, destination: System.Span<System.Char>, count: number): void;
      Insert(index: number, value: string, count: number): System.Text.StringBuilder;
      Remove(startIndex: number, length: number): System.Text.StringBuilder;
      Append(value: boolean): System.Text.StringBuilder;
      Append(value: System.Char): System.Text.StringBuilder;
      Append(value: System.SByte): System.Text.StringBuilder;
      Append(value: Byte): System.Text.StringBuilder;
      Append(value: number): System.Text.StringBuilder;
      Append(value: number): System.Text.StringBuilder;
      Append(value: number): System.Text.StringBuilder;
      Append(value: number): System.Text.StringBuilder;
      Append(value: number): System.Text.StringBuilder;
      Append(value: number): System.Text.StringBuilder;
      Append(value: number): System.Text.StringBuilder;
      Append(value: number): System.Text.StringBuilder;
      Append(value: number): System.Text.StringBuilder;
      Append(value: any): System.Text.StringBuilder;
      Append(value: System.Char[]): System.Text.StringBuilder;
      Append(value: System.ReadOnlySpan<System.Char>): System.Text.StringBuilder;
      AppendJoin(separator: string, ...values: any[]): System.Text.StringBuilder;
      AppendJoin(separator: string, ...values: string[]): System.Text.StringBuilder;
      AppendJoin(separator: System.Char, ...values: any[]): System.Text.StringBuilder;
      AppendJoin(separator: System.Char, ...values: string[]): System.Text.StringBuilder;
      Insert(index: number, value: string): System.Text.StringBuilder;
      Insert(index: number, value: boolean): System.Text.StringBuilder;
      Insert(index: number, value: System.SByte): System.Text.StringBuilder;
      Insert(index: number, value: Byte): System.Text.StringBuilder;
      Insert(index: number, value: number): System.Text.StringBuilder;
      Insert(index: number, value: System.Char): System.Text.StringBuilder;
      Insert(index: number, value: System.Char[]): System.Text.StringBuilder;
      Insert(index: number, value: System.Char[], startIndex: number, charCount: number): System.Text.StringBuilder;
      Insert(index: number, value: number): System.Text.StringBuilder;
      Insert(index: number, value: number): System.Text.StringBuilder;
      Insert(index: number, value: number): System.Text.StringBuilder;
      Insert(index: number, value: number): System.Text.StringBuilder;
      Insert(index: number, value: number): System.Text.StringBuilder;
      Insert(index: number, value: number): System.Text.StringBuilder;
      Insert(index: number, value: number): System.Text.StringBuilder;
      Insert(index: number, value: number): System.Text.StringBuilder;
      Insert(index: number, value: any): System.Text.StringBuilder;
      Insert(index: number, value: System.ReadOnlySpan<System.Char>): System.Text.StringBuilder;
      AppendFormat(format: string, arg0: any): System.Text.StringBuilder;
      AppendFormat(format: string, arg0: any, arg1: any): System.Text.StringBuilder;
      AppendFormat(format: string, arg0: any, arg1: any, arg2: any): System.Text.StringBuilder;
      AppendFormat(format: string, ...args: any[]): System.Text.StringBuilder;
      AppendFormat(provider: System.IFormatProvider, format: string, arg0: any): System.Text.StringBuilder;
      AppendFormat(provider: System.IFormatProvider, format: string, arg0: any, arg1: any): System.Text.StringBuilder;
      AppendFormat(provider: System.IFormatProvider, format: string, arg0: any, arg1: any, arg2: any): System.Text.StringBuilder;
      AppendFormat(provider: System.IFormatProvider, format: string, ...args: any[]): System.Text.StringBuilder;
      Replace(oldValue: string, newValue: string): System.Text.StringBuilder;
      Equals(sb: System.Text.StringBuilder): boolean;
      Equals(span: System.ReadOnlySpan<System.Char>): boolean;
      Replace(oldValue: string, newValue: string, startIndex: number, count: number): System.Text.StringBuilder;
      Replace(oldChar: System.Char, newChar: System.Char): System.Text.StringBuilder;
      Replace(oldChar: System.Char, newChar: System.Char, startIndex: number, count: number): System.Text.StringBuilder;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class UTF32Encoding {
      constructor();
      constructor(bigEndian: boolean, byteOrderMark: boolean);
      constructor(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidCharacters: boolean);
      Preamble: System.ReadOnlySpan<Byte>;
      BodyName: string;
      EncodingName: string;
      HeaderName: string;
      WebName: string;
      WindowsCodePage: number;
      IsBrowserDisplay: boolean;
      IsBrowserSave: boolean;
      IsMailNewsDisplay: boolean;
      IsMailNewsSave: boolean;
      IsSingleByte: boolean;
      EncoderFallback: System.Text.EncoderFallback;
      DecoderFallback: System.Text.DecoderFallback;
      IsReadOnly: boolean;
      CodePage: number;
      GetByteCount(chars: System.Char[], index: number, count: number): number;
      GetByteCount(s: string): number;
      GetBytes(s: string, charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetBytes(chars: System.Char[], charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetCharCount(bytes: Byte[], index: number, count: number): number;
      GetChars(bytes: Byte[], byteIndex: number, byteCount: number, chars: System.Char[], charIndex: number): number;
      GetString(bytes: Byte[], index: number, count: number): string;
      GetDecoder(): System.Text.Decoder;
      GetEncoder(): System.Text.Encoder;
      GetMaxByteCount(charCount: number): number;
      GetMaxCharCount(byteCount: number): number;
      GetPreamble(): Byte[];
      Equals(value: any): boolean;
      GetHashCode(): number;
      Clone(): any;
      GetByteCount(chars: System.Char[]): number;
      GetByteCount(str: string, index: number, count: number): number;
      GetBytes(chars: System.Char[]): Byte[];
      GetBytes(chars: System.Char[], index: number, count: number): Byte[];
      GetBytes(s: string): Byte[];
      GetCharCount(bytes: Byte[]): number;
      GetChars(bytes: Byte[]): System.Char[];
      GetChars(bytes: Byte[], index: number, count: number): System.Char[];
      GetChars(bytes: System.ReadOnlySpan<Byte>, chars: System.Span<System.Char>): number;
      GetString(bytes: System.ReadOnlySpan<Byte>): string;
      IsAlwaysNormalized(): boolean;
      IsAlwaysNormalized(form: System.Text.NormalizationForm): boolean;
      GetString(bytes: Byte[]): string;
      GetCharCount(bytes: System.ReadOnlySpan<Byte>): number;
      GetByteCount(chars: System.ReadOnlySpan<System.Char>): number;
      GetBytes(chars: System.ReadOnlySpan<System.Char>, bytes: System.Span<Byte>): number;
      GetBytes(s: string, index: number, count: number): Byte[];
      GetType(): System.Type;
      ToString(): string;
    }
    export class UTF7Encoding {
      constructor();
      constructor(allowOptionals: boolean);
      Preamble: System.ReadOnlySpan<Byte>;
      BodyName: string;
      EncodingName: string;
      HeaderName: string;
      WebName: string;
      WindowsCodePage: number;
      IsBrowserDisplay: boolean;
      IsBrowserSave: boolean;
      IsMailNewsDisplay: boolean;
      IsMailNewsSave: boolean;
      IsSingleByte: boolean;
      EncoderFallback: System.Text.EncoderFallback;
      DecoderFallback: System.Text.DecoderFallback;
      IsReadOnly: boolean;
      CodePage: number;
      Equals(value: any): boolean;
      GetHashCode(): number;
      GetByteCount(chars: System.Char[], index: number, count: number): number;
      GetByteCount(s: string): number;
      GetBytes(s: string, charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetBytes(chars: System.Char[], charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetCharCount(bytes: Byte[], index: number, count: number): number;
      GetChars(bytes: Byte[], byteIndex: number, byteCount: number, chars: System.Char[], charIndex: number): number;
      GetString(bytes: Byte[], index: number, count: number): string;
      GetDecoder(): System.Text.Decoder;
      GetEncoder(): System.Text.Encoder;
      GetMaxByteCount(charCount: number): number;
      GetMaxCharCount(byteCount: number): number;
      GetPreamble(): Byte[];
      Clone(): any;
      GetByteCount(chars: System.Char[]): number;
      GetByteCount(str: string, index: number, count: number): number;
      GetBytes(chars: System.Char[]): Byte[];
      GetBytes(chars: System.Char[], index: number, count: number): Byte[];
      GetBytes(s: string): Byte[];
      GetCharCount(bytes: Byte[]): number;
      GetChars(bytes: Byte[]): System.Char[];
      GetChars(bytes: Byte[], index: number, count: number): System.Char[];
      GetChars(bytes: System.ReadOnlySpan<Byte>, chars: System.Span<System.Char>): number;
      GetString(bytes: System.ReadOnlySpan<Byte>): string;
      IsAlwaysNormalized(): boolean;
      IsAlwaysNormalized(form: System.Text.NormalizationForm): boolean;
      GetString(bytes: Byte[]): string;
      GetCharCount(bytes: System.ReadOnlySpan<Byte>): number;
      GetByteCount(chars: System.ReadOnlySpan<System.Char>): number;
      GetBytes(chars: System.ReadOnlySpan<System.Char>, bytes: System.Span<Byte>): number;
      GetBytes(s: string, index: number, count: number): Byte[];
      GetType(): System.Type;
      ToString(): string;
    }
    export class UTF8Encoding {
      constructor();
      constructor(encoderShouldEmitUTF8Identifier: boolean);
      constructor(encoderShouldEmitUTF8Identifier: boolean, throwOnInvalidBytes: boolean);
      Preamble: System.ReadOnlySpan<Byte>;
      BodyName: string;
      EncodingName: string;
      HeaderName: string;
      WebName: string;
      WindowsCodePage: number;
      IsBrowserDisplay: boolean;
      IsBrowserSave: boolean;
      IsMailNewsDisplay: boolean;
      IsMailNewsSave: boolean;
      IsSingleByte: boolean;
      EncoderFallback: System.Text.EncoderFallback;
      DecoderFallback: System.Text.DecoderFallback;
      IsReadOnly: boolean;
      CodePage: number;
      GetByteCount(chars: System.Char[], index: number, count: number): number;
      GetByteCount(chars: string): number;
      GetBytes(s: string, charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetBytes(chars: System.Char[], charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetCharCount(bytes: Byte[], index: number, count: number): number;
      GetChars(bytes: Byte[], byteIndex: number, byteCount: number, chars: System.Char[], charIndex: number): number;
      GetString(bytes: Byte[], index: number, count: number): string;
      GetDecoder(): System.Text.Decoder;
      GetEncoder(): System.Text.Encoder;
      GetMaxByteCount(charCount: number): number;
      GetMaxCharCount(byteCount: number): number;
      GetPreamble(): Byte[];
      Equals(value: any): boolean;
      GetHashCode(): number;
      Clone(): any;
      GetByteCount(chars: System.Char[]): number;
      GetByteCount(str: string, index: number, count: number): number;
      GetBytes(chars: System.Char[]): Byte[];
      GetBytes(chars: System.Char[], index: number, count: number): Byte[];
      GetBytes(s: string): Byte[];
      GetCharCount(bytes: Byte[]): number;
      GetChars(bytes: Byte[]): System.Char[];
      GetChars(bytes: Byte[], index: number, count: number): System.Char[];
      GetChars(bytes: System.ReadOnlySpan<Byte>, chars: System.Span<System.Char>): number;
      GetString(bytes: System.ReadOnlySpan<Byte>): string;
      IsAlwaysNormalized(): boolean;
      IsAlwaysNormalized(form: System.Text.NormalizationForm): boolean;
      GetString(bytes: Byte[]): string;
      GetCharCount(bytes: System.ReadOnlySpan<Byte>): number;
      GetByteCount(chars: System.ReadOnlySpan<System.Char>): number;
      GetBytes(chars: System.ReadOnlySpan<System.Char>, bytes: System.Span<Byte>): number;
      GetBytes(s: string, index: number, count: number): Byte[];
      GetType(): System.Type;
      ToString(): string;
    }
    export class UnicodeEncoding {
      constructor();
      constructor(bigEndian: boolean, byteOrderMark: boolean);
      constructor(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidBytes: boolean);
      Preamble: System.ReadOnlySpan<Byte>;
      BodyName: string;
      EncodingName: string;
      HeaderName: string;
      WebName: string;
      WindowsCodePage: number;
      IsBrowserDisplay: boolean;
      IsBrowserSave: boolean;
      IsMailNewsDisplay: boolean;
      IsMailNewsSave: boolean;
      IsSingleByte: boolean;
      EncoderFallback: System.Text.EncoderFallback;
      DecoderFallback: System.Text.DecoderFallback;
      IsReadOnly: boolean;
      CodePage: number;
      static CharSize: number;
      GetByteCount(chars: System.Char[], index: number, count: number): number;
      GetByteCount(s: string): number;
      GetBytes(s: string, charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetBytes(chars: System.Char[], charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetCharCount(bytes: Byte[], index: number, count: number): number;
      GetChars(bytes: Byte[], byteIndex: number, byteCount: number, chars: System.Char[], charIndex: number): number;
      GetString(bytes: Byte[], index: number, count: number): string;
      GetEncoder(): System.Text.Encoder;
      GetDecoder(): System.Text.Decoder;
      GetPreamble(): Byte[];
      GetMaxByteCount(charCount: number): number;
      GetMaxCharCount(byteCount: number): number;
      Equals(value: any): boolean;
      GetHashCode(): number;
      Clone(): any;
      GetByteCount(chars: System.Char[]): number;
      GetByteCount(str: string, index: number, count: number): number;
      GetBytes(chars: System.Char[]): Byte[];
      GetBytes(chars: System.Char[], index: number, count: number): Byte[];
      GetBytes(s: string): Byte[];
      GetCharCount(bytes: Byte[]): number;
      GetChars(bytes: Byte[]): System.Char[];
      GetChars(bytes: Byte[], index: number, count: number): System.Char[];
      GetChars(bytes: System.ReadOnlySpan<Byte>, chars: System.Span<System.Char>): number;
      GetString(bytes: System.ReadOnlySpan<Byte>): string;
      IsAlwaysNormalized(): boolean;
      IsAlwaysNormalized(form: System.Text.NormalizationForm): boolean;
      GetString(bytes: Byte[]): string;
      GetCharCount(bytes: System.ReadOnlySpan<Byte>): number;
      GetByteCount(chars: System.ReadOnlySpan<System.Char>): number;
      GetBytes(chars: System.ReadOnlySpan<System.Char>, bytes: System.Span<Byte>): number;
      GetBytes(s: string, index: number, count: number): Byte[];
      GetType(): System.Type;
      ToString(): string;
    }
    export class Encoding {
      Preamble: System.ReadOnlySpan<Byte>;
      BodyName: string;
      EncodingName: string;
      HeaderName: string;
      WebName: string;
      WindowsCodePage: number;
      IsBrowserDisplay: boolean;
      IsBrowserSave: boolean;
      IsMailNewsDisplay: boolean;
      IsMailNewsSave: boolean;
      IsSingleByte: boolean;
      EncoderFallback: System.Text.EncoderFallback;
      DecoderFallback: System.Text.DecoderFallback;
      IsReadOnly: boolean;
      static ASCII: System.Text.Encoding;
      CodePage: number;
      static Default: System.Text.Encoding;
      static Unicode: System.Text.Encoding;
      static BigEndianUnicode: System.Text.Encoding;
      static UTF7: System.Text.Encoding;
      static UTF8: System.Text.Encoding;
      static UTF32: System.Text.Encoding;
      static Convert(srcEncoding: System.Text.Encoding, dstEncoding: System.Text.Encoding, bytes: Byte[]): Byte[];
      static Convert(srcEncoding: System.Text.Encoding, dstEncoding: System.Text.Encoding, bytes: Byte[], index: number, count: number): Byte[];
      static RegisterProvider(provider: System.Text.EncodingProvider): void;
      static GetEncoding(codepage: number): System.Text.Encoding;
      static GetEncoding(codepage: number, encoderFallback: System.Text.EncoderFallback, decoderFallback: System.Text.DecoderFallback): System.Text.Encoding;
      static GetEncoding(name: string): System.Text.Encoding;
      static GetEncoding(name: string, encoderFallback: System.Text.EncoderFallback, decoderFallback: System.Text.DecoderFallback): System.Text.Encoding;
      static GetEncodings(): System.Text.EncodingInfo[];
      GetPreamble(): Byte[];
      Clone(): any;
      GetByteCount(chars: System.Char[]): number;
      GetByteCount(s: string): number;
      GetByteCount(chars: System.Char[], index: number, count: number): number;
      GetByteCount(str: string, index: number, count: number): number;
      GetBytes(chars: System.Char[]): Byte[];
      GetBytes(chars: System.Char[], index: number, count: number): Byte[];
      GetBytes(chars: System.Char[], charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetBytes(s: string): Byte[];
      GetBytes(s: string, charIndex: number, charCount: number, bytes: Byte[], byteIndex: number): number;
      GetCharCount(bytes: Byte[]): number;
      GetCharCount(bytes: Byte[], index: number, count: number): number;
      GetChars(bytes: Byte[]): System.Char[];
      GetChars(bytes: Byte[], index: number, count: number): System.Char[];
      GetChars(bytes: Byte[], byteIndex: number, byteCount: number, chars: System.Char[], charIndex: number): number;
      GetChars(bytes: System.ReadOnlySpan<Byte>, chars: System.Span<System.Char>): number;
      GetString(bytes: System.ReadOnlySpan<Byte>): string;
      IsAlwaysNormalized(): boolean;
      IsAlwaysNormalized(form: System.Text.NormalizationForm): boolean;
      GetDecoder(): System.Text.Decoder;
      GetEncoder(): System.Text.Encoder;
      GetMaxByteCount(charCount: number): number;
      GetMaxCharCount(byteCount: number): number;
      GetString(bytes: Byte[]): string;
      GetString(bytes: Byte[], index: number, count: number): string;
      Equals(value: any): boolean;
      GetHashCode(): number;
      GetCharCount(bytes: System.ReadOnlySpan<Byte>): number;
      GetByteCount(chars: System.ReadOnlySpan<System.Char>): number;
      GetBytes(chars: System.ReadOnlySpan<System.Char>, bytes: System.Span<Byte>): number;
      GetBytes(s: string, index: number, count: number): Byte[];
      GetType(): System.Type;
      ToString(): string;
    }
    export namespace RegularExpressions {
      export class Capture {
        Index: number;
        Length: number;
        Value: string;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class CaptureCollection {
        IsReadOnly: boolean;
        Count: number;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        GetEnumerator(): System.Collections.IEnumerator;
        CopyTo(array: System.Array, arrayIndex: number): void;
        CopyTo(array: System.Text.RegularExpressions.Capture[], arrayIndex: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Group {
        Success: boolean;
        Name: string;
        Captures: System.Text.RegularExpressions.Capture[];
        Index: number;
        Length: number;
        Value: string;
        static Synchronized(inner: System.Text.RegularExpressions.Group): System.Text.RegularExpressions.Group;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class GroupCollection {
        IsReadOnly: boolean;
        Count: number;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        GetEnumerator(): System.Collections.IEnumerator;
        CopyTo(array: System.Array, arrayIndex: number): void;
        CopyTo(array: System.Text.RegularExpressions.Group[], arrayIndex: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Match {
        static Empty: System.Text.RegularExpressions.Match;
        Groups: System.Text.RegularExpressions.Group[];
        Success: boolean;
        Name: string;
        Captures: System.Text.RegularExpressions.Capture[];
        Index: number;
        Length: number;
        Value: string;
        NextMatch(): System.Text.RegularExpressions.Match;
        Result(replacement: string): string;
        static Synchronized(inner: System.Text.RegularExpressions.Match): System.Text.RegularExpressions.Match;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MatchCollection {
        IsReadOnly: boolean;
        Count: number;
        IsSynchronized: boolean;
        SyncRoot: any; // System.Object
        GetEnumerator(): System.Collections.IEnumerator;
        CopyTo(array: System.Array, arrayIndex: number): void;
        CopyTo(array: System.Text.RegularExpressions.Match[], arrayIndex: number): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Regex {
        constructor(pattern: string);
        constructor(pattern: string, options: System.Text.RegularExpressions.RegexOptions);
        constructor(pattern: string, options: System.Text.RegularExpressions.RegexOptions, matchTimeout: System.TimeSpan);
        static CacheSize: number;
        MatchTimeout: System.TimeSpan;
        Options: System.Text.RegularExpressions.RegexOptions;
        RightToLeft: boolean;
        static InfiniteMatchTimeout: System.TimeSpan;
        static IsMatch(input: string, pattern: string): boolean;
        static IsMatch(input: string, pattern: string, options: System.Text.RegularExpressions.RegexOptions): boolean;
        static IsMatch(input: string, pattern: string, options: System.Text.RegularExpressions.RegexOptions, matchTimeout: System.TimeSpan): boolean;
        IsMatch(input: string): boolean;
        IsMatch(input: string, startat: number): boolean;
        static Match(input: string, pattern: string): System.Text.RegularExpressions.Match;
        static Match(input: string, pattern: string, options: System.Text.RegularExpressions.RegexOptions): System.Text.RegularExpressions.Match;
        static Match(input: string, pattern: string, options: System.Text.RegularExpressions.RegexOptions, matchTimeout: System.TimeSpan): System.Text.RegularExpressions.Match;
        Match(input: string): System.Text.RegularExpressions.Match;
        Match(input: string, startat: number): System.Text.RegularExpressions.Match;
        Match(input: string, beginning: number, length: number): System.Text.RegularExpressions.Match;
        static Matches(input: string, pattern: string): System.Text.RegularExpressions.Match[];
        static Matches(input: string, pattern: string, options: System.Text.RegularExpressions.RegexOptions): System.Text.RegularExpressions.Match[];
        static Matches(input: string, pattern: string, options: System.Text.RegularExpressions.RegexOptions, matchTimeout: System.TimeSpan): System.Text.RegularExpressions.Match[];
        Matches(input: string): System.Text.RegularExpressions.Match[];
        Matches(input: string, startat: number): System.Text.RegularExpressions.Match[];
        static Replace(input: string, pattern: string, replacement: string): string;
        static Replace(input: string, pattern: string, replacement: string, options: System.Text.RegularExpressions.RegexOptions): string;
        static Replace(input: string, pattern: string, replacement: string, options: System.Text.RegularExpressions.RegexOptions, matchTimeout: System.TimeSpan): string;
        Replace(input: string, replacement: string): string;
        Replace(input: string, replacement: string, count: number): string;
        Replace(input: string, replacement: string, count: number, startat: number): string;
        static Replace(input: string, pattern: string, evaluator: ((match: System.Text.RegularExpressions.Match) => string)): string;
        static Replace(input: string, pattern: string, evaluator: ((match: System.Text.RegularExpressions.Match) => string), options: System.Text.RegularExpressions.RegexOptions): string;
        static Replace(input: string, pattern: string, evaluator: ((match: System.Text.RegularExpressions.Match) => string), options: System.Text.RegularExpressions.RegexOptions, matchTimeout: System.TimeSpan): string;
        Replace(input: string, evaluator: ((match: System.Text.RegularExpressions.Match) => string)): string;
        Replace(input: string, evaluator: ((match: System.Text.RegularExpressions.Match) => string), count: number): string;
        Replace(input: string, evaluator: ((match: System.Text.RegularExpressions.Match) => string), count: number, startat: number): string;
        static Split(input: string, pattern: string): string[];
        static Split(input: string, pattern: string, options: System.Text.RegularExpressions.RegexOptions): string[];
        static Split(input: string, pattern: string, options: System.Text.RegularExpressions.RegexOptions, matchTimeout: System.TimeSpan): string[];
        Split(input: string): string[];
        Split(input: string, count: number): string[];
        Split(input: string, count: number, startat: number): string[];
        static CompileToAssembly(regexinfos: System.Text.RegularExpressions.RegexCompilationInfo[], assemblyname: System.Reflection.AssemblyName): void;
        static CompileToAssembly(regexinfos: System.Text.RegularExpressions.RegexCompilationInfo[], assemblyname: System.Reflection.AssemblyName, attributes: System.Reflection.Emit.CustomAttributeBuilder[]): void;
        static CompileToAssembly(regexinfos: System.Text.RegularExpressions.RegexCompilationInfo[], assemblyname: System.Reflection.AssemblyName, attributes: System.Reflection.Emit.CustomAttributeBuilder[], resourceFile: string): void;
        static Escape(str: string): string;
        static Unescape(str: string): string;
        ToString(): string;
        GetGroupNames(): string[];
        GetGroupNumbers(): number[];
        GroupNameFromNumber(i: number): string;
        GroupNumberFromName(name: string): number;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class MatchEvaluator {
        constructor(object: any, method: System.IntPtr);
        Method: System.Reflection.MethodInfo;
        Target: any; // System.Object
        Invoke(match: System.Text.RegularExpressions.Match): string;
        BeginInvoke(match: System.Text.RegularExpressions.Match, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
        EndInvoke(result: System.IAsyncResult): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetInvocationList(): System.Delegate[];
        DynamicInvoke(...args: any[]): any;
        Clone(): any;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RegexCompilationInfo {
        constructor(pattern: string, options: System.Text.RegularExpressions.RegexOptions, name: string, fullnamespace: string, ispublic: boolean);
        constructor(pattern: string, options: System.Text.RegularExpressions.RegexOptions, name: string, fullnamespace: string, ispublic: boolean, matchTimeout: System.TimeSpan);
        IsPublic: boolean;
        MatchTimeout: System.TimeSpan;
        Name: string;
        Namespace: string;
        Options: System.Text.RegularExpressions.RegexOptions;
        Pattern: string;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RegexMatchTimeoutException {
        constructor(regexInput: string, regexPattern: string, matchTimeout: System.TimeSpan);
        constructor();
        constructor(message: string);
        constructor(message: string, inner: System.Exception);
        Input: string;
        Pattern: string;
        MatchTimeout: System.TimeSpan;
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export enum RegexOptions {
        None = 0,
        IgnoreCase = 1,
        Multiline = 2,
        ExplicitCapture = 4,
        Compiled = 8,
        Singleline = 16,
        IgnorePatternWhitespace = 32,
        RightToLeft = 64,
        ECMAScript = 256,
        CultureInvariant = 512,
      }
      export class RegexRunner {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class RegexRunnerFactory {
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
  }
  export namespace Threading {
    export class AbandonedMutexException {
      constructor();
      constructor(message: string);
      constructor(message: string, inner: System.Exception);
      constructor(location: number, handle: System.Threading.WaitHandle);
      constructor(message: string, location: number, handle: System.Threading.WaitHandle);
      constructor(message: string, inner: System.Exception, location: number, handle: System.Threading.WaitHandle);
      Mutex: System.Threading.Mutex;
      MutexIndex: number;
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum ApartmentState {
      STA = 0,
      MTA = 1,
      Unknown = 2,
    }
    export class AsyncLocal<T = any> {
      constructor();
      constructor(valueChangedHandler: ((obj: System.Threading.AsyncLocalValueChangedArgs<T>) => void));
      Value: T;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AsyncLocalValueChangedArgs<T = any> {
      PreviousValue: T;
      CurrentValue: T;
      ThreadContextChanged: boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class AutoResetEvent {
      constructor(initialState: boolean);
      Handle: System.IntPtr;
      SafeWaitHandle: any; // Microsoft.Win32.SafeHandles.SafeWaitHandle
      Reset(): boolean;
      Set(): boolean;
      GetAccessControl(): System.Security.AccessControl.EventWaitHandleSecurity;
      SetAccessControl(eventSecurity: System.Security.AccessControl.EventWaitHandleSecurity): void;
      WaitOne(millisecondsTimeout: number, exitContext: boolean): boolean;
      WaitOne(timeout: System.TimeSpan, exitContext: boolean): boolean;
      WaitOne(): boolean;
      WaitOne(millisecondsTimeout: number): boolean;
      WaitOne(timeout: System.TimeSpan): boolean;
      Close(): void;
      Dispose(): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum EventResetMode {
      AutoReset = 0,
      ManualReset = 1,
    }
    export class LazyInitializer {
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum LazyThreadSafetyMode {
      None = 0,
      PublicationOnly = 1,
      ExecutionAndPublication = 2,
    }
    export class LockRecursionException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ManualResetEvent {
      constructor(initialState: boolean);
      Handle: System.IntPtr;
      SafeWaitHandle: any; // Microsoft.Win32.SafeHandles.SafeWaitHandle
      Reset(): boolean;
      Set(): boolean;
      GetAccessControl(): System.Security.AccessControl.EventWaitHandleSecurity;
      SetAccessControl(eventSecurity: System.Security.AccessControl.EventWaitHandleSecurity): void;
      WaitOne(millisecondsTimeout: number, exitContext: boolean): boolean;
      WaitOne(timeout: System.TimeSpan, exitContext: boolean): boolean;
      WaitOne(): boolean;
      WaitOne(millisecondsTimeout: number): boolean;
      WaitOne(timeout: System.TimeSpan): boolean;
      Close(): void;
      Dispose(): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ParameterizedThreadStart {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(obj: any): void;
      BeginInvoke(obj: any, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SemaphoreFullException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class SendOrPostCallback {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(state: any): void;
      BeginInvoke(state: any, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SynchronizationLockException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum ThreadPriority {
      Lowest = 0,
      BelowNormal = 1,
      Normal = 2,
      AboveNormal = 3,
      Highest = 4,
    }
    export class ThreadStart {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(): void;
      BeginInvoke(callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ThreadStartException {
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export enum ThreadState {
      Running = 0,
      StopRequested = 1,
      SuspendRequested = 2,
      Background = 4,
      Unstarted = 8,
      Stopped = 16,
      WaitSleepJoin = 32,
      Suspended = 64,
      AbortRequested = 128,
      Aborted = 256,
    }
    export class ThreadStateException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class Timeout {
      static InfiniteTimeSpan: System.TimeSpan;
      static Infinite: number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class WaitHandleCannotBeOpenedException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class CountdownEvent {
      constructor(initialCount: number);
      CurrentCount: number;
      InitialCount: number;
      IsSet: boolean;
      WaitHandle: System.Threading.WaitHandle;
      Dispose(): void;
      Signal(): boolean;
      Signal(signalCount: number): boolean;
      AddCount(): void;
      TryAddCount(): boolean;
      AddCount(signalCount: number): void;
      TryAddCount(signalCount: number): boolean;
      Reset(): void;
      Reset(count: number): void;
      Wait(): void;
      Wait(cancellationToken: System.Threading.CancellationToken): void;
      Wait(timeout: System.TimeSpan): boolean;
      Wait(timeout: System.TimeSpan, cancellationToken: System.Threading.CancellationToken): boolean;
      Wait(millisecondsTimeout: number): boolean;
      Wait(millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CancellationToken {
      constructor(canceled: boolean);
      static None: System.Threading.CancellationToken;
      IsCancellationRequested: boolean;
      CanBeCanceled: boolean;
      WaitHandle: System.Threading.WaitHandle;
      Register(callback: (() => void)): System.Threading.CancellationTokenRegistration;
      Register(callback: (() => void), useSynchronizationContext: boolean): System.Threading.CancellationTokenRegistration;
      Register(callback: ((obj: any) => void), state: any): System.Threading.CancellationTokenRegistration;
      Register(callback: ((obj: any) => void), state: any, useSynchronizationContext: boolean): System.Threading.CancellationTokenRegistration;
      Register(callback: ((obj: any) => void), state: any, useSynchronizationContext: boolean, useExecutionContext: boolean): System.Threading.CancellationTokenRegistration;
      Equals(other: System.Threading.CancellationToken): boolean;
      Equals(other: any): boolean;
      GetHashCode(): number;
      ThrowIfCancellationRequested(): void;
      ToString(): string;
      GetType(): System.Type;
    }
    export class ManualResetEventSlim {
      constructor();
      constructor(initialState: boolean);
      constructor(initialState: boolean, spinCount: number);
      WaitHandle: System.Threading.WaitHandle;
      IsSet: boolean;
      SpinCount: number;
      Set(): void;
      Reset(): void;
      Wait(): void;
      Wait(cancellationToken: System.Threading.CancellationToken): void;
      Wait(timeout: System.TimeSpan): boolean;
      Wait(timeout: System.TimeSpan, cancellationToken: System.Threading.CancellationToken): boolean;
      Wait(millisecondsTimeout: number): boolean;
      Wait(millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken): boolean;
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class NativeOverlapped {
      InternalLow: System.IntPtr;
      InternalHigh: System.IntPtr;
      OffsetLow: number;
      OffsetHigh: number;
      EventHandle: System.IntPtr;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class SpinWait {
      Count: number;
      NextSpinWillYield: boolean;
      SpinOnce(): void;
      SpinOnce(sleep1Threshold: number): void;
      Reset(): void;
      static SpinUntil(condition: (() => boolean)): void;
      static SpinUntil(condition: (() => boolean), timeout: System.TimeSpan): boolean;
      static SpinUntil(condition: (() => boolean), millisecondsTimeout: number): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class CancellationTokenRegistration {
      Token: System.Threading.CancellationToken;
      Unregister(): boolean;
      Dispose(): void;
      Equals(obj: any): boolean;
      Equals(other: System.Threading.CancellationTokenRegistration): boolean;
      GetHashCode(): number;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      ToString(): string;
      GetType(): System.Type;
    }
    export class CancellationTokenSource {
      constructor();
      constructor(delay: System.TimeSpan);
      constructor(millisecondsDelay: number);
      IsCancellationRequested: boolean;
      Token: System.Threading.CancellationToken;
      Cancel(): void;
      Cancel(throwOnFirstException: boolean): void;
      CancelAfter(delay: System.TimeSpan): void;
      CancelAfter(millisecondsDelay: number): void;
      Dispose(): void;
      static CreateLinkedTokenSource(token1: System.Threading.CancellationToken, token2: System.Threading.CancellationToken): System.Threading.CancellationTokenSource;
      static CreateLinkedTokenSource(...tokens: System.Threading.CancellationToken[]): System.Threading.CancellationTokenSource;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class LockHolder {
      static Hold(l: System.Threading.Lock): System.Threading.LockHolder;
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class ThreadPoolBoundHandle {
      Handle: System.Runtime.InteropServices.SafeHandle;
      static BindHandle(handle: System.Runtime.InteropServices.SafeHandle): System.Threading.ThreadPoolBoundHandle;
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class PreAllocatedOverlapped {
      constructor(callback: ((errorCode: number, numBytes: number, pOVERLAP: Pointer<System.Threading.NativeOverlapped>) => void), state: any, pinData: any);
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Lock {
      constructor();
      Acquire(): void;
      Release(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SemaphoreSlim {
      constructor(initialCount: number);
      constructor(initialCount: number, maxCount: number);
      CurrentCount: number;
      AvailableWaitHandle: System.Threading.WaitHandle;
      Wait(): void;
      Wait(cancellationToken: System.Threading.CancellationToken): void;
      Wait(timeout: System.TimeSpan): boolean;
      Wait(timeout: System.TimeSpan, cancellationToken: System.Threading.CancellationToken): boolean;
      Wait(millisecondsTimeout: number): boolean;
      Wait(millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken): boolean;
      WaitAsync(): System.Threading.Tasks.Task;
      WaitAsync(cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
      WaitAsync(millisecondsTimeout: number): System.Threading.Tasks.Task<boolean>;
      WaitAsync(timeout: System.TimeSpan): System.Threading.Tasks.Task<boolean>;
      WaitAsync(timeout: System.TimeSpan, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<boolean>;
      WaitAsync(millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<boolean>;
      Release(): number;
      Release(releaseCount: number): number;
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SpinLock {
      constructor(enableThreadOwnerTracking: boolean);
      IsHeld: boolean;
      IsHeldByCurrentThread: boolean;
      IsThreadOwnerTrackingEnabled: boolean;
      Exit(): void;
      Exit(useMemoryBarrier: boolean): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      GetType(): System.Type;
    }
    export class ThreadLocal<T = any> {
      constructor();
      constructor(trackAllValues: boolean);
      constructor(valueFactory: (() => T));
      constructor(valueFactory: (() => T), trackAllValues: boolean);
      Value: T;
      Values: T[];
      IsValueCreated: boolean;
      Dispose(): void;
      ToString(): string;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class EventWaitHandle {
      constructor(initialState: boolean, mode: System.Threading.EventResetMode);
      constructor(initialState: boolean, mode: System.Threading.EventResetMode, name: string);
      Handle: System.IntPtr;
      SafeWaitHandle: any; // Microsoft.Win32.SafeHandles.SafeWaitHandle
      static OpenExisting(name: string): System.Threading.EventWaitHandle;
      static OpenExisting(name: string, rights: System.Security.AccessControl.EventWaitHandleRights): System.Threading.EventWaitHandle;
      Reset(): boolean;
      Set(): boolean;
      GetAccessControl(): System.Security.AccessControl.EventWaitHandleSecurity;
      SetAccessControl(eventSecurity: System.Security.AccessControl.EventWaitHandleSecurity): void;
      WaitOne(millisecondsTimeout: number, exitContext: boolean): boolean;
      WaitOne(timeout: System.TimeSpan, exitContext: boolean): boolean;
      WaitOne(): boolean;
      WaitOne(millisecondsTimeout: number): boolean;
      WaitOne(timeout: System.TimeSpan): boolean;
      Close(): void;
      Dispose(): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ContextCallback {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(state: any): void;
      BeginInvoke(state: any, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AsyncFlowControl {
      Dispose(): void;
      Undo(): void;
      GetHashCode(): number;
      Equals(obj: any): boolean;
      Equals(obj: System.Threading.AsyncFlowControl): boolean;
      ToString(): string;
      GetType(): System.Type;
    }
    export class ExecutionContext {
      Dispose(): void;
      static Run(executionContext: System.Threading.ExecutionContext, callback: ((state: any) => void), state: any): void;
      CreateCopy(): System.Threading.ExecutionContext;
      static SuppressFlow(): System.Threading.AsyncFlowControl;
      static RestoreFlow(): void;
      static IsFlowSuppressed(): boolean;
      static Capture(): System.Threading.ExecutionContext;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Monitor {
      static Enter(obj: any): void;
      static Exit(obj: any): void;
      static TryEnter(obj: any): boolean;
      static TryEnter(obj: any, millisecondsTimeout: number): boolean;
      static TryEnter(obj: any, timeout: System.TimeSpan): boolean;
      static IsEntered(obj: any): boolean;
      static Wait(obj: any, millisecondsTimeout: number, exitContext: boolean): boolean;
      static Wait(obj: any, timeout: System.TimeSpan, exitContext: boolean): boolean;
      static Wait(obj: any, millisecondsTimeout: number): boolean;
      static Wait(obj: any, timeout: System.TimeSpan): boolean;
      static Wait(obj: any): boolean;
      static Pulse(obj: any): void;
      static PulseAll(obj: any): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class SynchronizationContext {
      constructor();
      static Current: System.Threading.SynchronizationContext;
      IsWaitNotificationRequired(): boolean;
      Send(d: ((state: any) => void), state: any): void;
      Post(d: ((state: any) => void), state: any): void;
      OperationStarted(): void;
      OperationCompleted(): void;
      Wait(waitHandles: System.IntPtr[], waitAll: boolean, millisecondsTimeout: number): number;
      static SetSynchronizationContext(syncContext: System.Threading.SynchronizationContext): void;
      CreateCopy(): System.Threading.SynchronizationContext;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Thread {
      constructor(start: (() => void));
      constructor(start: (() => void), maxStackSize: number);
      constructor(start: ((obj: any) => void));
      constructor(start: ((obj: any) => void), maxStackSize: number);
      ExecutionContext: System.Threading.ExecutionContext;
      Priority: System.Threading.ThreadPriority;
      CurrentUICulture: System.Globalization.CultureInfo;
      CurrentCulture: System.Globalization.CultureInfo;
      static CurrentContext: System.Runtime.Remoting.Contexts.Context;
      static CurrentPrincipal: System.Security.Principal.IPrincipal;
      static CurrentThread: System.Threading.Thread;
      ApartmentState: System.Threading.ApartmentState;
      IsThreadPoolThread: boolean;
      IsAlive: boolean;
      IsBackground: boolean;
      Name: string;
      ThreadState: System.Threading.ThreadState;
      ManagedThreadId: number;
      Start(): void;
      Start(parameter: any): void;
      SetCompressedStack(stack: System.Threading.CompressedStack): void;
      GetCompressedStack(): System.Threading.CompressedStack;
      static ResetAbort(): void;
      Suspend(): void;
      Resume(): void;
      Interrupt(): void;
      Join(): void;
      Join(millisecondsTimeout: number): boolean;
      Join(timeout: System.TimeSpan): boolean;
      static Sleep(millisecondsTimeout: number): void;
      static Sleep(timeout: System.TimeSpan): void;
      static Yield(): boolean;
      static AllocateDataSlot(): System.LocalDataStoreSlot;
      static AllocateNamedDataSlot(name: string): System.LocalDataStoreSlot;
      static GetNamedDataSlot(name: string): System.LocalDataStoreSlot;
      static FreeNamedDataSlot(name: string): void;
      static GetData(slot: System.LocalDataStoreSlot): any;
      static SetData(slot: System.LocalDataStoreSlot, data: any): void;
      static MemoryBarrier(): void;
      static GetDomain(): System.AppDomain;
      static GetDomainID(): number;
      Abort(): void;
      Abort(stateInfo: any): void;
      static SpinWait(iterations: number): void;
      static BeginCriticalRegion(): void;
      static EndCriticalRegion(): void;
      static BeginThreadAffinity(): void;
      static EndThreadAffinity(): void;
      GetApartmentState(): System.Threading.ApartmentState;
      SetApartmentState(state: System.Threading.ApartmentState): void;
      TrySetApartmentState(state: System.Threading.ApartmentState): boolean;
      GetHashCode(): number;
      DisableComObjectEagerCleanup(): void;
      static GetCurrentProcessorId(): number;
      Equals(obj: any): boolean;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ThreadAbortException {
      ExceptionState: any; // System.Object
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ThreadInterruptedException {
      constructor();
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class WaitCallback {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(state: any): void;
      BeginInvoke(state: any, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class WaitOrTimerCallback {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(state: any, timedOut: boolean): void;
      BeginInvoke(state: any, timedOut: boolean, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class IOCompletionCallback {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ThreadPool {
      static SetMaxThreads(workerThreads: number, completionPortThreads: number): boolean;
      static SetMinThreads(workerThreads: number, completionPortThreads: number): boolean;
      static RegisterWaitForSingleObject(waitObject: System.Threading.WaitHandle, callBack: ((state: any, timedOut: boolean) => void), state: any, millisecondsTimeOutInterval: number, executeOnlyOnce: boolean): System.Threading.RegisteredWaitHandle;
      static UnsafeRegisterWaitForSingleObject(waitObject: System.Threading.WaitHandle, callBack: ((state: any, timedOut: boolean) => void), state: any, millisecondsTimeOutInterval: number, executeOnlyOnce: boolean): System.Threading.RegisteredWaitHandle;
      static RegisterWaitForSingleObject(waitObject: System.Threading.WaitHandle, callBack: ((state: any, timedOut: boolean) => void), state: any, millisecondsTimeOutInterval: number, executeOnlyOnce: boolean): System.Threading.RegisteredWaitHandle;
      static UnsafeRegisterWaitForSingleObject(waitObject: System.Threading.WaitHandle, callBack: ((state: any, timedOut: boolean) => void), state: any, millisecondsTimeOutInterval: number, executeOnlyOnce: boolean): System.Threading.RegisteredWaitHandle;
      static RegisterWaitForSingleObject(waitObject: System.Threading.WaitHandle, callBack: ((state: any, timedOut: boolean) => void), state: any, millisecondsTimeOutInterval: number, executeOnlyOnce: boolean): System.Threading.RegisteredWaitHandle;
      static UnsafeRegisterWaitForSingleObject(waitObject: System.Threading.WaitHandle, callBack: ((state: any, timedOut: boolean) => void), state: any, millisecondsTimeOutInterval: number, executeOnlyOnce: boolean): System.Threading.RegisteredWaitHandle;
      static RegisterWaitForSingleObject(waitObject: System.Threading.WaitHandle, callBack: ((state: any, timedOut: boolean) => void), state: any, timeout: System.TimeSpan, executeOnlyOnce: boolean): System.Threading.RegisteredWaitHandle;
      static UnsafeRegisterWaitForSingleObject(waitObject: System.Threading.WaitHandle, callBack: ((state: any, timedOut: boolean) => void), state: any, timeout: System.TimeSpan, executeOnlyOnce: boolean): System.Threading.RegisteredWaitHandle;
      static QueueUserWorkItem(callBack: ((state: any) => void), state: any): boolean;
      static QueueUserWorkItem(callBack: ((state: any) => void)): boolean;
      static UnsafeQueueUserWorkItem(callBack: ((state: any) => void), state: any): boolean;
      static BindHandle(osHandle: System.IntPtr): boolean;
      static BindHandle(osHandle: System.Runtime.InteropServices.SafeHandle): boolean;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class WaitHandle {
      Handle: System.IntPtr;
      SafeWaitHandle: any; // Microsoft.Win32.SafeHandles.SafeWaitHandle
      static WaitTimeout: number;
      WaitOne(millisecondsTimeout: number, exitContext: boolean): boolean;
      WaitOne(timeout: System.TimeSpan, exitContext: boolean): boolean;
      WaitOne(): boolean;
      WaitOne(millisecondsTimeout: number): boolean;
      WaitOne(timeout: System.TimeSpan): boolean;
      static WaitAll(waitHandles: System.Threading.WaitHandle[], millisecondsTimeout: number, exitContext: boolean): boolean;
      static WaitAll(waitHandles: System.Threading.WaitHandle[], timeout: System.TimeSpan, exitContext: boolean): boolean;
      static WaitAll(waitHandles: System.Threading.WaitHandle[]): boolean;
      static WaitAll(waitHandles: System.Threading.WaitHandle[], millisecondsTimeout: number): boolean;
      static WaitAll(waitHandles: System.Threading.WaitHandle[], timeout: System.TimeSpan): boolean;
      static WaitAny(waitHandles: System.Threading.WaitHandle[], millisecondsTimeout: number, exitContext: boolean): number;
      static WaitAny(waitHandles: System.Threading.WaitHandle[], timeout: System.TimeSpan, exitContext: boolean): number;
      static WaitAny(waitHandles: System.Threading.WaitHandle[], timeout: System.TimeSpan): number;
      static WaitAny(waitHandles: System.Threading.WaitHandle[]): number;
      static WaitAny(waitHandles: System.Threading.WaitHandle[], millisecondsTimeout: number): number;
      static SignalAndWait(toSignal: System.Threading.WaitHandle, toWaitOn: System.Threading.WaitHandle): boolean;
      static SignalAndWait(toSignal: System.Threading.WaitHandle, toWaitOn: System.Threading.WaitHandle, timeout: System.TimeSpan, exitContext: boolean): boolean;
      static SignalAndWait(toSignal: System.Threading.WaitHandle, toWaitOn: System.Threading.WaitHandle, millisecondsTimeout: number, exitContext: boolean): boolean;
      Close(): void;
      Dispose(): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class WaitHandleExtensions {
      static GetSafeWaitHandle(waitHandle: System.Threading.WaitHandle): any;
      static SetSafeWaitHandle(waitHandle: System.Threading.WaitHandle, value: any): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class CompressedStack {
      CreateCopy(): System.Threading.CompressedStack;
      static Capture(): System.Threading.CompressedStack;
      static GetCompressedStack(): System.Threading.CompressedStack;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      static Run(compressedStack: System.Threading.CompressedStack, callback: ((state: any) => void), state: any): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class HostExecutionContext {
      constructor();
      constructor(state: any);
      CreateCopy(): System.Threading.HostExecutionContext;
      Dispose(): void;
      Dispose(disposing: boolean): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class HostExecutionContextManager {
      constructor();
      Capture(): System.Threading.HostExecutionContext;
      Revert(previousState: any): void;
      SetHostExecutionContext(hostExecutionContext: System.Threading.HostExecutionContext): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Interlocked {
      static MemoryBarrier(): void;
      static MemoryBarrierProcessWide(): void;
      static SpeculationBarrier(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class LockCookie {
      GetHashCode(): number;
      Equals(obj: System.Threading.LockCookie): boolean;
      Equals(obj: any): boolean;
      ToString(): string;
      GetType(): System.Type;
    }
    export class Mutex {
      constructor();
      constructor(initiallyOwned: boolean);
      constructor(initiallyOwned: boolean, name: string);
      Handle: System.IntPtr;
      SafeWaitHandle: any; // Microsoft.Win32.SafeHandles.SafeWaitHandle
      GetAccessControl(): System.Security.AccessControl.MutexSecurity;
      static OpenExisting(name: string): System.Threading.Mutex;
      static OpenExisting(name: string, rights: System.Security.AccessControl.MutexRights): System.Threading.Mutex;
      ReleaseMutex(): void;
      SetAccessControl(mutexSecurity: System.Security.AccessControl.MutexSecurity): void;
      WaitOne(millisecondsTimeout: number, exitContext: boolean): boolean;
      WaitOne(timeout: System.TimeSpan, exitContext: boolean): boolean;
      WaitOne(): boolean;
      WaitOne(millisecondsTimeout: number): boolean;
      WaitOne(timeout: System.TimeSpan): boolean;
      Close(): void;
      Dispose(): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Overlapped {
      constructor();
      constructor(offsetLo: number, offsetHi: number, hEvent: number, ar: System.IAsyncResult);
      constructor(offsetLo: number, offsetHi: number, hEvent: System.IntPtr, ar: System.IAsyncResult);
      AsyncResult: System.IAsyncResult;
      EventHandle: number;
      EventHandleIntPtr: System.IntPtr;
      OffsetHigh: number;
      OffsetLow: number;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ReaderWriterLock {
      constructor();
      IsReaderLockHeld: boolean;
      IsWriterLockHeld: boolean;
      WriterSeqNum: number;
      AcquireReaderLock(millisecondsTimeout: number): void;
      AcquireReaderLock(timeout: System.TimeSpan): void;
      AcquireWriterLock(millisecondsTimeout: number): void;
      AcquireWriterLock(timeout: System.TimeSpan): void;
      AnyWritersSince(seqNum: number): boolean;
      ReleaseLock(): System.Threading.LockCookie;
      ReleaseReaderLock(): void;
      ReleaseWriterLock(): void;
      UpgradeToWriterLock(millisecondsTimeout: number): System.Threading.LockCookie;
      UpgradeToWriterLock(timeout: System.TimeSpan): System.Threading.LockCookie;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class RegisteredWaitHandle {
      Unregister(waitObject: System.Threading.WaitHandle): boolean;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Timer {
      constructor(callback: ((state: any) => void), state: any, dueTime: number, period: number);
      constructor(callback: ((state: any) => void), state: any, dueTime: number, period: number);
      constructor(callback: ((state: any) => void), state: any, dueTime: System.TimeSpan, period: System.TimeSpan);
      constructor(callback: ((state: any) => void), state: any, dueTime: number, period: number);
      constructor(callback: ((state: any) => void));
      Change(dueTime: number, period: number): boolean;
      Change(dueTime: System.TimeSpan, period: System.TimeSpan): boolean;
      Change(dueTime: number, period: number): boolean;
      Dispose(): void;
      Change(dueTime: number, period: number): boolean;
      Dispose(notifyObject: System.Threading.WaitHandle): boolean;
      DisposeAsync(): System.Threading.Tasks.ValueTask;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class TimerCallback {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(state: any): void;
      BeginInvoke(state: any, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Volatile {
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export enum LockRecursionPolicy {
      NoRecursion = 0,
      SupportsRecursion = 1,
    }
    export class ReaderWriterLockSlim {
      constructor();
      constructor(recursionPolicy: System.Threading.LockRecursionPolicy);
      IsReadLockHeld: boolean;
      IsUpgradeableReadLockHeld: boolean;
      IsWriteLockHeld: boolean;
      RecursionPolicy: System.Threading.LockRecursionPolicy;
      CurrentReadCount: number;
      RecursiveReadCount: number;
      RecursiveUpgradeCount: number;
      RecursiveWriteCount: number;
      WaitingReadCount: number;
      WaitingUpgradeCount: number;
      WaitingWriteCount: number;
      EnterReadLock(): void;
      TryEnterReadLock(timeout: System.TimeSpan): boolean;
      TryEnterReadLock(millisecondsTimeout: number): boolean;
      EnterWriteLock(): void;
      TryEnterWriteLock(timeout: System.TimeSpan): boolean;
      TryEnterWriteLock(millisecondsTimeout: number): boolean;
      EnterUpgradeableReadLock(): void;
      TryEnterUpgradeableReadLock(timeout: System.TimeSpan): boolean;
      TryEnterUpgradeableReadLock(millisecondsTimeout: number): boolean;
      ExitReadLock(): void;
      ExitWriteLock(): void;
      ExitUpgradeableReadLock(): void;
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class BarrierPostPhaseException {
      constructor();
      constructor(innerException: System.Exception);
      constructor(message: string);
      constructor(message: string, innerException: System.Exception);
      Message: string;
      Data: System.Collections.IDictionary;
      InnerException: System.Exception;
      TargetSite: System.Reflection.MethodBase;
      StackTrace: string;
      HelpLink: string;
      Source: string;
      HResult: number;
      GetBaseException(): System.Exception;
      ToString(): string;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      GetType(): System.Type;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class Barrier {
      constructor(participantCount: number);
      constructor(participantCount: number, postPhaseAction: ((obj: System.Threading.Barrier) => void));
      ParticipantsRemaining: number;
      ParticipantCount: number;
      CurrentPhaseNumber: number;
      AddParticipant(): number;
      AddParticipants(participantCount: number): number;
      RemoveParticipant(): void;
      RemoveParticipants(participantCount: number): void;
      SignalAndWait(): void;
      SignalAndWait(cancellationToken: System.Threading.CancellationToken): void;
      SignalAndWait(timeout: System.TimeSpan): boolean;
      SignalAndWait(timeout: System.TimeSpan, cancellationToken: System.Threading.CancellationToken): boolean;
      SignalAndWait(millisecondsTimeout: number): boolean;
      SignalAndWait(millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken): boolean;
      Dispose(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Semaphore {
      constructor(initialCount: number, maximumCount: number);
      constructor(initialCount: number, maximumCount: number, name: string);
      Handle: System.IntPtr;
      SafeWaitHandle: any; // Microsoft.Win32.SafeHandles.SafeWaitHandle
      static OpenExisting(name: string): System.Threading.Semaphore;
      static OpenExisting(name: string, rights: System.Security.AccessControl.SemaphoreRights): System.Threading.Semaphore;
      Release(): number;
      Release(releaseCount: number): number;
      GetAccessControl(): System.Security.AccessControl.SemaphoreSecurity;
      SetAccessControl(semaphoreSecurity: System.Security.AccessControl.SemaphoreSecurity): void;
      WaitOne(millisecondsTimeout: number, exitContext: boolean): boolean;
      WaitOne(timeout: System.TimeSpan, exitContext: boolean): boolean;
      WaitOne(): boolean;
      WaitOne(millisecondsTimeout: number): boolean;
      WaitOne(timeout: System.TimeSpan): boolean;
      Close(): void;
      Dispose(): void;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ThreadExceptionEventArgs {
      constructor(t: System.Exception);
      Exception: System.Exception;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class ThreadExceptionEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.Threading.ThreadExceptionEventArgs): void;
      BeginInvoke(sender: any, e: System.Threading.ThreadExceptionEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export namespace Tasks {
      export class TaskCanceledException {
        constructor();
        constructor(message: string);
        constructor(message: string, innerException: System.Exception);
        constructor(message: string, innerException: System.Exception, token: System.Threading.CancellationToken);
        constructor(task: System.Threading.Tasks.Task);
        Task: System.Threading.Tasks.Task;
        CancellationToken: System.Threading.CancellationToken;
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class TaskCompletionSource<TResult = any> {
        constructor();
        constructor(creationOptions: System.Threading.Tasks.TaskCreationOptions);
        constructor(state: any);
        constructor(state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions);
        Task: System.Threading.Tasks.Task<TResult>;
        TrySetException(exception: System.Exception): boolean;
        TrySetException(exceptions: System.Collections.Generic.IEnumerable<System.Exception>): boolean;
        SetException(exception: System.Exception): void;
        SetException(exceptions: System.Collections.Generic.IEnumerable<System.Exception>): void;
        TrySetResult(result: TResult): boolean;
        SetResult(result: TResult): void;
        TrySetCanceled(): boolean;
        TrySetCanceled(cancellationToken: System.Threading.CancellationToken): boolean;
        SetCanceled(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class TaskSchedulerException {
        constructor();
        constructor(message: string);
        constructor(innerException: System.Exception);
        constructor(message: string, innerException: System.Exception);
        Message: string;
        Data: System.Collections.IDictionary;
        InnerException: System.Exception;
        TargetSite: System.Reflection.MethodBase;
        StackTrace: string;
        HelpLink: string;
        Source: string;
        HResult: number;
        GetBaseException(): System.Exception;
        ToString(): string;
        GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
        GetType(): System.Type;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
      }
      export class ValueTask<TResult = any> {
        constructor(result: TResult);
        constructor(task: System.Threading.Tasks.Task<TResult>);
        constructor(source: System.Threading.Tasks.Sources.IValueTaskSource<TResult>, token: number);
        IsCompleted: boolean;
        IsCompletedSuccessfully: boolean;
        IsFaulted: boolean;
        IsCanceled: boolean;
        Result: TResult;
        GetHashCode(): number;
        Equals(obj: any): boolean;
        Equals(other: System.Threading.Tasks.ValueTask<TResult>): boolean;
        AsTask(): System.Threading.Tasks.Task<TResult>;
        Preserve(): System.Threading.Tasks.ValueTask<TResult>;
        GetAwaiter(): System.Runtime.CompilerServices.ValueTaskAwaiter<TResult>;
        ConfigureAwait(continueOnCapturedContext: boolean): System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<TResult>;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ParallelOptions {
        constructor();
        TaskScheduler: System.Threading.Tasks.TaskScheduler;
        MaxDegreeOfParallelism: number;
        CancellationToken: System.Threading.CancellationToken;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Parallel {
        static Invoke(...actions: (() => void)[]): void;
        static Invoke(parallelOptions: System.Threading.Tasks.ParallelOptions, ...actions: (() => void)[]): void;
        static For(fromInclusive: number, toExclusive: number, body: ((obj: number) => void)): System.Threading.Tasks.ParallelLoopResult;
        static For(fromInclusive: number, toExclusive: number, body: ((obj: number) => void)): System.Threading.Tasks.ParallelLoopResult;
        static For(fromInclusive: number, toExclusive: number, parallelOptions: System.Threading.Tasks.ParallelOptions, body: ((obj: number) => void)): System.Threading.Tasks.ParallelLoopResult;
        static For(fromInclusive: number, toExclusive: number, parallelOptions: System.Threading.Tasks.ParallelOptions, body: ((obj: number) => void)): System.Threading.Tasks.ParallelLoopResult;
        static For(fromInclusive: number, toExclusive: number, body: ((arg1: number, arg2: System.Threading.Tasks.ParallelLoopState) => void)): System.Threading.Tasks.ParallelLoopResult;
        static For(fromInclusive: number, toExclusive: number, body: ((arg1: number, arg2: System.Threading.Tasks.ParallelLoopState) => void)): System.Threading.Tasks.ParallelLoopResult;
        static For(fromInclusive: number, toExclusive: number, parallelOptions: System.Threading.Tasks.ParallelOptions, body: ((arg1: number, arg2: System.Threading.Tasks.ParallelLoopState) => void)): System.Threading.Tasks.ParallelLoopResult;
        static For(fromInclusive: number, toExclusive: number, parallelOptions: System.Threading.Tasks.ParallelOptions, body: ((arg1: number, arg2: System.Threading.Tasks.ParallelLoopState) => void)): System.Threading.Tasks.ParallelLoopResult;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ParallelLoopState {
        ShouldExitCurrentIteration: boolean;
        IsStopped: boolean;
        IsExceptional: boolean;
        LowestBreakIteration?: number | undefined;
        Stop(): void;
        Break(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class ParallelLoopResult {
        IsCompleted: boolean;
        LowestBreakIteration?: number | undefined;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        ToString(): string;
        GetType(): System.Type;
      }
      export class ConcurrentExclusiveSchedulerPair {
        constructor();
        constructor(taskScheduler: System.Threading.Tasks.TaskScheduler);
        constructor(taskScheduler: System.Threading.Tasks.TaskScheduler, maxConcurrencyLevel: number);
        constructor(taskScheduler: System.Threading.Tasks.TaskScheduler, maxConcurrencyLevel: number, maxItemsPerTask: number);
        Completion: System.Threading.Tasks.Task;
        ConcurrentScheduler: System.Threading.Tasks.TaskScheduler;
        ExclusiveScheduler: System.Threading.Tasks.TaskScheduler;
        Complete(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class Task<TResult = any> {
        constructor(functionCS: (() => TResult));
        constructor(functionCS: (() => TResult), cancellationToken: System.Threading.CancellationToken);
        constructor(functionCS: (() => TResult), creationOptions: System.Threading.Tasks.TaskCreationOptions);
        constructor(functionCS: (() => TResult), cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions);
        constructor(functionCS: ((arg: any) => TResult), state: any);
        constructor(functionCS: ((arg: any) => TResult), state: any, cancellationToken: System.Threading.CancellationToken);
        constructor(functionCS: ((arg: any) => TResult), state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions);
        constructor(functionCS: ((arg: any) => TResult), state: any, cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions);
        Result: TResult;
        static Factory: any; // System.Threading.Tasks.TaskFactory`1[TResult]
        Id: number;
        Exception: System.AggregateException;
        Status: System.Threading.Tasks.TaskStatus;
        IsCanceled: boolean;
        IsCompleted: boolean;
        IsCompletedSuccessfully: boolean;
        CreationOptions: System.Threading.Tasks.TaskCreationOptions;
        AsyncState: any; // System.Object
        IsFaulted: boolean;
        GetAwaiter(): System.Runtime.CompilerServices.TaskAwaiter<TResult>;
        ConfigureAwait(continueOnCapturedContext: boolean): System.Runtime.CompilerServices.ConfiguredTaskAwaitable<TResult>;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task<TResult>) => void)): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task<TResult>) => void), cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task<TResult>) => void), scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task<TResult>) => void), continuationOptions: System.Threading.Tasks.TaskContinuationOptions): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task<TResult>) => void), cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task<TResult>, arg2: any) => void), state: any): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task<TResult>, arg2: any) => void), state: any, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task<TResult>, arg2: any) => void), state: any, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task<TResult>, arg2: any) => void), state: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task<TResult>, arg2: any) => void), state: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task;
        Start(): void;
        Start(scheduler: System.Threading.Tasks.TaskScheduler): void;
        RunSynchronously(): void;
        RunSynchronously(scheduler: System.Threading.Tasks.TaskScheduler): void;
        Dispose(): void;
        GetAwaiter(): System.Runtime.CompilerServices.TaskAwaiter;
        ConfigureAwait(continueOnCapturedContext: boolean): System.Runtime.CompilerServices.ConfiguredTaskAwaitable;
        Wait(): void;
        Wait(timeout: System.TimeSpan): boolean;
        Wait(cancellationToken: System.Threading.CancellationToken): void;
        Wait(millisecondsTimeout: number): boolean;
        Wait(millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken): boolean;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task) => void)): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task) => void), cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task) => void), scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task) => void), continuationOptions: System.Threading.Tasks.TaskContinuationOptions): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((obj: System.Threading.Tasks.Task) => void), cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task, arg2: any) => void), state: any): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task, arg2: any) => void), state: any, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task, arg2: any) => void), state: any, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task, arg2: any) => void), state: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions): System.Threading.Tasks.Task;
        ContinueWith(continuationAction: ((arg1: System.Threading.Tasks.Task, arg2: any) => void), state: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task;
        MarkAborted(e: System.Threading.ThreadAbortException): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class TaskFactory<TResult = any> {
        constructor();
        constructor(cancellationToken: System.Threading.CancellationToken);
        constructor(scheduler: System.Threading.Tasks.TaskScheduler);
        constructor(creationOptions: System.Threading.Tasks.TaskCreationOptions, continuationOptions: System.Threading.Tasks.TaskContinuationOptions);
        constructor(cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler);
        CancellationToken: System.Threading.CancellationToken;
        Scheduler: System.Threading.Tasks.TaskScheduler;
        CreationOptions: System.Threading.Tasks.TaskCreationOptions;
        ContinuationOptions: System.Threading.Tasks.TaskContinuationOptions;
        StartNew(functionCS: (() => TResult)): System.Threading.Tasks.Task<TResult>;
        StartNew(functionCS: (() => TResult), cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<TResult>;
        StartNew(functionCS: (() => TResult), creationOptions: System.Threading.Tasks.TaskCreationOptions): System.Threading.Tasks.Task<TResult>;
        StartNew(functionCS: (() => TResult), cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task<TResult>;
        StartNew(functionCS: ((arg: any) => TResult), state: any): System.Threading.Tasks.Task<TResult>;
        StartNew(functionCS: ((arg: any) => TResult), state: any, cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<TResult>;
        StartNew(functionCS: ((arg: any) => TResult), state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions): System.Threading.Tasks.Task<TResult>;
        StartNew(functionCS: ((arg: any) => TResult), state: any, cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task<TResult>;
        FromAsync(asyncResult: System.IAsyncResult, endMethod: ((arg: System.IAsyncResult) => TResult)): System.Threading.Tasks.Task<TResult>;
        FromAsync(asyncResult: System.IAsyncResult, endMethod: ((arg: System.IAsyncResult) => TResult), creationOptions: System.Threading.Tasks.TaskCreationOptions): System.Threading.Tasks.Task<TResult>;
        FromAsync(asyncResult: System.IAsyncResult, endMethod: ((arg: System.IAsyncResult) => TResult), creationOptions: System.Threading.Tasks.TaskCreationOptions, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task<TResult>;
        FromAsync(beginMethod: ((arg1: ((ar: System.IAsyncResult) => void), arg2: any) => System.IAsyncResult), endMethod: ((arg: System.IAsyncResult) => TResult), state: any): System.Threading.Tasks.Task<TResult>;
        FromAsync(beginMethod: ((arg1: ((ar: System.IAsyncResult) => void), arg2: any) => System.IAsyncResult), endMethod: ((arg: System.IAsyncResult) => TResult), state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions): System.Threading.Tasks.Task<TResult>;
        ContinueWhenAll(tasks: System.Threading.Tasks.Task[], continuationFunction: ((arg: System.Threading.Tasks.Task[]) => TResult)): System.Threading.Tasks.Task<TResult>;
        ContinueWhenAll(tasks: System.Threading.Tasks.Task[], continuationFunction: ((arg: System.Threading.Tasks.Task[]) => TResult), cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<TResult>;
        ContinueWhenAll(tasks: System.Threading.Tasks.Task[], continuationFunction: ((arg: System.Threading.Tasks.Task[]) => TResult), continuationOptions: System.Threading.Tasks.TaskContinuationOptions): System.Threading.Tasks.Task<TResult>;
        ContinueWhenAll(tasks: System.Threading.Tasks.Task[], continuationFunction: ((arg: System.Threading.Tasks.Task[]) => TResult), cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task<TResult>;
        ContinueWhenAny(tasks: System.Threading.Tasks.Task[], continuationFunction: ((arg: System.Threading.Tasks.Task) => TResult)): System.Threading.Tasks.Task<TResult>;
        ContinueWhenAny(tasks: System.Threading.Tasks.Task[], continuationFunction: ((arg: System.Threading.Tasks.Task) => TResult), cancellationToken: System.Threading.CancellationToken): System.Threading.Tasks.Task<TResult>;
        ContinueWhenAny(tasks: System.Threading.Tasks.Task[], continuationFunction: ((arg: System.Threading.Tasks.Task) => TResult), continuationOptions: System.Threading.Tasks.TaskContinuationOptions): System.Threading.Tasks.Task<TResult>;
        ContinueWhenAny(tasks: System.Threading.Tasks.Task[], continuationFunction: ((arg: System.Threading.Tasks.Task) => TResult), cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler): System.Threading.Tasks.Task<TResult>;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export enum TaskStatus {
        Created = 0,
        WaitingForActivation = 1,
        WaitingToRun = 2,
        Running = 3,
        WaitingForChildrenToComplete = 4,
        RanToCompletion = 5,
        Canceled = 6,
        Faulted = 7,
      }
      export enum TaskCreationOptions {
        None = 0,
        PreferFairness = 1,
        LongRunning = 2,
        AttachedToParent = 4,
        DenyChildAttach = 8,
        HideScheduler = 16,
        RunContinuationsAsynchronously = 64,
      }
      export enum TaskContinuationOptions {
        None = 0,
        PreferFairness = 1,
        LongRunning = 2,
        AttachedToParent = 4,
        DenyChildAttach = 8,
        HideScheduler = 16,
        LazyCancellation = 32,
        RunContinuationsAsynchronously = 64,
        NotOnRanToCompletion = 65536,
        NotOnFaulted = 131072,
        NotOnCanceled = 262144,
        OnlyOnRanToCompletion = 393216,
        OnlyOnFaulted = 327680,
        OnlyOnCanceled = 196608,
        ExecuteSynchronously = 524288,
      }
      export class TaskScheduler {
        MaximumConcurrencyLevel: number;
        static Default: System.Threading.Tasks.TaskScheduler;
        static Current: System.Threading.Tasks.TaskScheduler;
        Id: number;
        static FromCurrentSynchronizationContext(): System.Threading.Tasks.TaskScheduler;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class UnobservedTaskExceptionEventArgs {
        constructor(exception: System.AggregateException);
        Observed: boolean;
        Exception: System.AggregateException;
        SetObserved(): void;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class TaskAsyncEnumerableExtensions {
        static ConfigureAwait(source: System.IAsyncDisposable, continueOnCapturedContext: boolean): System.Runtime.CompilerServices.ConfiguredAsyncDisposable;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export class TaskExtensions {
        static Unwrap(task: any): System.Threading.Tasks.Task;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
      export namespace Sources {
        export enum ValueTaskSourceOnCompletedFlags {
          None = 0,
          UseSchedulingContext = 1,
          FlowExecutionContext = 2,
        }
        export enum ValueTaskSourceStatus {
          Pending = 0,
          Succeeded = 1,
          Faulted = 2,
          Canceled = 3,
        }
        export interface IValueTaskSource<TResult = any> {
          GetStatus(token: number): System.Threading.Tasks.Sources.ValueTaskSourceStatus;
          OnCompleted(continuation: ((obj: any) => void), state: any, token: number, flags: System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags): void;
          GetResult(token: number): TResult;
        }
        export class ManualResetValueTaskSourceCore<TResult = any> {
          RunContinuationsAsynchronously: boolean;
          Version: number;
          Reset(): void;
          SetResult(result: TResult): void;
          SetException(error: System.Exception): void;
          GetStatus(token: number): System.Threading.Tasks.Sources.ValueTaskSourceStatus;
          GetResult(token: number): TResult;
          OnCompleted(continuation: ((obj: any) => void), state: any, token: number, flags: System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags): void;
          Equals(obj: any): boolean;
          GetHashCode(): number;
          ToString(): string;
          GetType(): System.Type;
        }
      }
    }
  }
  export namespace Timers {
    export class ElapsedEventHandler {
      constructor(object: any, method: System.IntPtr);
      Method: System.Reflection.MethodInfo;
      Target: any; // System.Object
      Invoke(sender: any, e: System.Timers.ElapsedEventArgs): void;
      BeginInvoke(sender: any, e: System.Timers.ElapsedEventArgs, callback: ((ar: System.IAsyncResult) => void), object: any): System.IAsyncResult;
      EndInvoke(result: System.IAsyncResult): void;
      GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetInvocationList(): System.Delegate[];
      DynamicInvoke(...args: any[]): any;
      Clone(): any;
      GetType(): System.Type;
      ToString(): string;
    }
    export class Timer {
      constructor();
      constructor(interval: number);
      AutoReset: boolean;
      Enabled: boolean;
      Interval: number;
      Site: System.ComponentModel.ISite;
      SynchronizingObject: System.ComponentModel.ISynchronizeInvoke;
      Container: System.ComponentModel.IContainer;
      BeginInit(): void;
      Close(): void;
      EndInit(): void;
      Start(): void;
      Stop(): void;
      Dispose(): void;
      ToString(): string;
      CreateObjRef(requestedType: System.Type): System.Runtime.Remoting.ObjRef;
      GetLifetimeService(): any;
      InitializeLifetimeService(): any;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
    }
    export class ElapsedEventArgs {
      SignalTime: System.DateTime;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
  }
  export namespace Web {
    export class HttpUtility {
      constructor();
      static HtmlAttributeEncode(s: string, output: System.IO.TextWriter): void;
      static HtmlAttributeEncode(s: string): string;
      static UrlDecode(str: string): string;
      static UrlDecode(str: string, e: System.Text.Encoding): string;
      static UrlDecode(bytes: Byte[], e: System.Text.Encoding): string;
      static UrlDecode(bytes: Byte[], offset: number, count: number, e: System.Text.Encoding): string;
      static UrlDecodeToBytes(bytes: Byte[]): Byte[];
      static UrlDecodeToBytes(str: string): Byte[];
      static UrlDecodeToBytes(str: string, e: System.Text.Encoding): Byte[];
      static UrlDecodeToBytes(bytes: Byte[], offset: number, count: number): Byte[];
      static UrlEncode(str: string): string;
      static UrlEncode(str: string, e: System.Text.Encoding): string;
      static UrlEncode(bytes: Byte[]): string;
      static UrlEncode(bytes: Byte[], offset: number, count: number): string;
      static UrlEncodeToBytes(str: string): Byte[];
      static UrlEncodeToBytes(str: string, e: System.Text.Encoding): Byte[];
      static UrlEncodeToBytes(bytes: Byte[]): Byte[];
      static UrlEncodeToBytes(bytes: Byte[], offset: number, count: number): Byte[];
      static UrlEncodeUnicode(str: string): string;
      static UrlEncodeUnicodeToBytes(str: string): Byte[];
      static HtmlDecode(s: string): string;
      static HtmlDecode(s: string, output: System.IO.TextWriter): void;
      static HtmlEncode(s: string): string;
      static HtmlEncode(s: string, output: System.IO.TextWriter): void;
      static HtmlEncode(value: any): string;
      static JavaScriptStringEncode(value: string): string;
      static JavaScriptStringEncode(value: string, addDoubleQuotes: boolean): string;
      static UrlPathEncode(str: string): string;
      static ParseQueryString(query: string): System.Collections.Specialized.NameValueCollection;
      static ParseQueryString(query: string, encoding: System.Text.Encoding): System.Collections.Specialized.NameValueCollection;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      GetType(): System.Type;
      ToString(): string;
    }
    export class AspNetHostingPermission {
      constructor(level: System.Web.AspNetHostingPermissionLevel);
      constructor(state: System.Security.Permissions.PermissionState);
      Level: System.Web.AspNetHostingPermissionLevel;
      IsUnrestricted(): boolean;
      Copy(): System.Security.IPermission;
      FromXml(securityElement: System.Security.SecurityElement): void;
      ToXml(): System.Security.SecurityElement;
      Intersect(target: System.Security.IPermission): System.Security.IPermission;
      IsSubsetOf(target: System.Security.IPermission): boolean;
      Union(target: System.Security.IPermission): System.Security.IPermission;
      Assert(): void;
      Demand(): void;
      Deny(): void;
      Equals(obj: any): boolean;
      GetHashCode(): number;
      ToString(): string;
      PermitOnly(): void;
      GetType(): System.Type;
    }
    export enum AspNetHostingPermissionLevel {
      None = 100,
      Minimal = 200,
      Low = 300,
      Medium = 400,
      High = 500,
      Unrestricted = 600,
    }
    export namespace Util {
      export class HttpEncoder {
        constructor();
        static Current: System.Web.Util.HttpEncoder;
        static Default: System.Web.Util.HttpEncoder;
        Equals(obj: any): boolean;
        GetHashCode(): number;
        GetType(): System.Type;
        ToString(): string;
      }
    }
  }
  export namespace Windows {
    export namespace Input {
      export interface ICommand {
        CanExecute(parameter: any): boolean;
        Execute(parameter: any): void;
      }
    }
  }
}
